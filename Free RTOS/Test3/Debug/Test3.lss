
Test3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000229c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a6  00800060  0000229c  00002330  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045e  00800106  00800106  000023d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000023d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002408  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000528  00000000  00000000  00002444  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005539  00000000  00000000  0000296c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013c9  00000000  00000000  00007ea5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000330b  00000000  00000000  0000926e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ff8  00000000  00000000  0000c57c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000189b  00000000  00000000  0000d574  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005218  00000000  00000000  0000ee0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f0  00000000  00000000  00014027  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 64 04 	jmp	0x8c8	; 0x8c8 <__vector_1>
       8:	0c 94 8b 04 	jmp	0x916	; 0x916 <__vector_2>
       c:	0c 94 b2 04 	jmp	0x964	; 0x964 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 86 07 	jmp	0xf0c	; 0xf0c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 93 0f 	jmp	0x1f26	; 0x1f26 <__vector_10>
      2c:	0c 94 6c 0f 	jmp	0x1ed8	; 0x1ed8 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e9       	ldi	r30, 0x9C	; 156
      68:	f2 e2       	ldi	r31, 0x22	; 34
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a6 30       	cpi	r26, 0x06	; 6
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	25 e0       	ldi	r18, 0x05	; 5
      78:	a6 e0       	ldi	r26, 0x06	; 6
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 36       	cpi	r26, 0x64	; 100
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e6 01 	call	0x3cc	; 0x3cc <main>
      8a:	0c 94 4c 11 	jmp	0x2298	; 0x2298 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <task1>:
QueueHandle_t queue1;
QueueHandle_t queue2;


void task1()
{
      92:	cf 93       	push	r28
      94:	df 93       	push	r29
      96:	1f 92       	push	r1
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
	u8 key;
	xSemaphoreTake(semaphore , 100);
      9c:	20 e0       	ldi	r18, 0x00	; 0
      9e:	44 e6       	ldi	r20, 0x64	; 100
      a0:	50 e0       	ldi	r21, 0x00	; 0
      a2:	60 e0       	ldi	r22, 0x00	; 0
      a4:	70 e0       	ldi	r23, 0x00	; 0
      a6:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
      aa:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
      ae:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
	key = UART_u8RX();
      b2:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <UART_u8RX>
      b6:	89 83       	std	Y+1, r24	; 0x01
	xQueueSend(queue1 , &key , 100);
      b8:	20 e0       	ldi	r18, 0x00	; 0
      ba:	44 e6       	ldi	r20, 0x64	; 100
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	be 01       	movw	r22, r28
      c0:	6f 5f       	subi	r22, 0xFF	; 255
      c2:	7f 4f       	sbci	r23, 0xFF	; 255
      c4:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <queue1>
      c8:	90 91 63 05 	lds	r25, 0x0563	; 0x800563 <queue1+0x1>
      cc:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xQueueGenericSend>
	xSemaphoreGive(semaphore);
      d0:	20 e0       	ldi	r18, 0x00	; 0
      d2:	40 e0       	ldi	r20, 0x00	; 0
      d4:	50 e0       	ldi	r21, 0x00	; 0
      d6:	60 e0       	ldi	r22, 0x00	; 0
      d8:	70 e0       	ldi	r23, 0x00	; 0
      da:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
      de:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
      e2:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xQueueGenericSend>
	vTaskDelay(1000);
      e6:	88 ee       	ldi	r24, 0xE8	; 232
      e8:	93 e0       	ldi	r25, 0x03	; 3
      ea:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskDelay>
}
      ee:	0f 90       	pop	r0
      f0:	df 91       	pop	r29
      f2:	cf 91       	pop	r28
      f4:	08 95       	ret

000000f6 <task2>:



void task2()
{
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
      fa:	1f 92       	push	r1
      fc:	cd b7       	in	r28, 0x3d	; 61
      fe:	de b7       	in	r29, 0x3e	; 62
	u8 key;
	xSemaphoreTake(semaphore , 200);
     100:	20 e0       	ldi	r18, 0x00	; 0
     102:	48 ec       	ldi	r20, 0xC8	; 200
     104:	50 e0       	ldi	r21, 0x00	; 0
     106:	60 e0       	ldi	r22, 0x00	; 0
     108:	70 e0       	ldi	r23, 0x00	; 0
     10a:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
     10e:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
     112:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
	xQueueReceive(queue1 , &key , 100);
     116:	20 e0       	ldi	r18, 0x00	; 0
     118:	44 e6       	ldi	r20, 0x64	; 100
     11a:	50 e0       	ldi	r21, 0x00	; 0
     11c:	be 01       	movw	r22, r28
     11e:	6f 5f       	subi	r22, 0xFF	; 255
     120:	7f 4f       	sbci	r23, 0xFF	; 255
     122:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <queue1>
     126:	90 91 63 05 	lds	r25, 0x0563	; 0x800563 <queue1+0x1>
     12a:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
	switch (key)
     12e:	89 81       	ldd	r24, Y+1	; 0x01
     130:	81 36       	cpi	r24, 0x61	; 97
     132:	f1 f4       	brne	.+60     	; 0x170 <task2+0x7a>
	{
		case 'a' :
		LCD_voidSendString("Correct Password.");
     134:	82 e6       	ldi	r24, 0x62	; 98
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
		DIO_voidSetPinVal(DIO_PORTB , DIO_PIN7 , HIGH);
     13c:	41 e0       	ldi	r20, 0x01	; 1
     13e:	67 e0       	ldi	r22, 0x07	; 7
     140:	81 e0       	ldi	r24, 0x01	; 1
     142:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     146:	2f ef       	ldi	r18, 0xFF	; 255
     148:	33 ed       	ldi	r19, 0xD3	; 211
     14a:	80 e3       	ldi	r24, 0x30	; 48
     14c:	21 50       	subi	r18, 0x01	; 1
     14e:	30 40       	sbci	r19, 0x00	; 0
     150:	80 40       	sbci	r24, 0x00	; 0
     152:	e1 f7       	brne	.-8      	; 0x14c <task2+0x56>
     154:	00 c0       	rjmp	.+0      	; 0x156 <task2+0x60>
     156:	00 00       	nop
		_delay_ms(1000);
		xSemaphoreGive(semaphore);
     158:	20 e0       	ldi	r18, 0x00	; 0
     15a:	40 e0       	ldi	r20, 0x00	; 0
     15c:	50 e0       	ldi	r21, 0x00	; 0
     15e:	60 e0       	ldi	r22, 0x00	; 0
     160:	70 e0       	ldi	r23, 0x00	; 0
     162:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
     166:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
     16a:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xQueueGenericSend>
		break;
     16e:	20 c0       	rjmp	.+64     	; 0x1b0 <task2+0xba>
		
		default  :
		LCD_voidGotoxy(0,0);
     170:	60 e0       	ldi	r22, 0x00	; 0
     172:	80 e0       	ldi	r24, 0x00	; 0
     174:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
		LCD_voidSendString("Wrong Password!!");
     178:	84 e7       	ldi	r24, 0x74	; 116
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
		LCD_voidGotoxy(0,1);
     180:	61 e0       	ldi	r22, 0x01	; 1
     182:	80 e0       	ldi	r24, 0x00	; 0
     184:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
		LCD_voidSendString("System is Closed !!");
     188:	85 e8       	ldi	r24, 0x85	; 133
     18a:	90 e0       	ldi	r25, 0x00	; 0
     18c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
		DIO_voidSetPinVal(DIO_PORTB , DIO_PIN6 , HIGH);
     190:	41 e0       	ldi	r20, 0x01	; 1
     192:	66 e0       	ldi	r22, 0x06	; 6
     194:	81 e0       	ldi	r24, 0x01	; 1
     196:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     19a:	9f ef       	ldi	r25, 0xFF	; 255
     19c:	23 eb       	ldi	r18, 0xB3	; 179
     19e:	34 ec       	ldi	r19, 0xC4	; 196
     1a0:	84 e0       	ldi	r24, 0x04	; 4
     1a2:	91 50       	subi	r25, 0x01	; 1
     1a4:	20 40       	sbci	r18, 0x00	; 0
     1a6:	30 40       	sbci	r19, 0x00	; 0
     1a8:	80 40       	sbci	r24, 0x00	; 0
     1aa:	d9 f7       	brne	.-10     	; 0x1a2 <task2+0xac>
     1ac:	00 c0       	rjmp	.+0      	; 0x1ae <task2+0xb8>
     1ae:	00 00       	nop
		_delay_ms(30000);
	}	
	vTaskDelay(2000);
     1b0:	80 ed       	ldi	r24, 0xD0	; 208
     1b2:	97 e0       	ldi	r25, 0x07	; 7
     1b4:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskDelay>
}
     1b8:	0f 90       	pop	r0
     1ba:	df 91       	pop	r29
     1bc:	cf 91       	pop	r28
     1be:	08 95       	ret

000001c0 <task3>:



void task3()
{
     1c0:	cf 93       	push	r28
     1c2:	df 93       	push	r29
     1c4:	00 d0       	rcall	.+0      	; 0x1c6 <task3+0x6>
     1c6:	00 d0       	rcall	.+0      	; 0x1c8 <task3+0x8>
     1c8:	cd b7       	in	r28, 0x3d	; 61
     1ca:	de b7       	in	r29, 0x3e	; 62
	u16 val = 0;
	f32 temp = 0;
     1cc:	19 82       	std	Y+1, r1	; 0x01
     1ce:	1a 82       	std	Y+2, r1	; 0x02
     1d0:	1b 82       	std	Y+3, r1	; 0x03
     1d2:	1c 82       	std	Y+4, r1	; 0x04
	if (xSemaphoreTake(semaphore , 300) == 1)
     1d4:	20 e0       	ldi	r18, 0x00	; 0
     1d6:	4c e2       	ldi	r20, 0x2C	; 44
     1d8:	51 e0       	ldi	r21, 0x01	; 1
     1da:	60 e0       	ldi	r22, 0x00	; 0
     1dc:	70 e0       	ldi	r23, 0x00	; 0
     1de:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
     1e2:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
     1e6:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
     1ea:	81 30       	cpi	r24, 0x01	; 1
     1ec:	29 f5       	brne	.+74     	; 0x238 <task3+0x78>
	{
		while(1)
		{
			val = ADC_u16ReadChannel(ADC_0);						
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	0e 94 5d 03 	call	0x6ba	; 0x6ba <ADC_u16ReadChannel>
			temp = (f32)val * 500 / 1024;				
     1f4:	bc 01       	movw	r22, r24
     1f6:	80 e0       	ldi	r24, 0x00	; 0
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <__floatunsisf>
     1fe:	20 e0       	ldi	r18, 0x00	; 0
     200:	30 e0       	ldi	r19, 0x00	; 0
     202:	4a ef       	ldi	r20, 0xFA	; 250
     204:	53 e4       	ldi	r21, 0x43	; 67
     206:	0e 94 8c 10 	call	0x2118	; 0x2118 <__mulsf3>
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	30 e0       	ldi	r19, 0x00	; 0
     20e:	40 e8       	ldi	r20, 0x80	; 128
     210:	5a e3       	ldi	r21, 0x3A	; 58
     212:	0e 94 8c 10 	call	0x2118	; 0x2118 <__mulsf3>
     216:	69 83       	std	Y+1, r22	; 0x01
     218:	7a 83       	std	Y+2, r23	; 0x02
     21a:	8b 83       	std	Y+3, r24	; 0x03
     21c:	9c 83       	std	Y+4, r25	; 0x04
			xQueueSend(queue2 , &temp , 200);
     21e:	20 e0       	ldi	r18, 0x00	; 0
     220:	48 ec       	ldi	r20, 0xC8	; 200
     222:	50 e0       	ldi	r21, 0x00	; 0
     224:	be 01       	movw	r22, r28
     226:	6f 5f       	subi	r22, 0xFF	; 255
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <queue2>
     22e:	90 91 61 05 	lds	r25, 0x0561	; 0x800561 <queue2+0x1>
     232:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xQueueGenericSend>
     236:	db cf       	rjmp	.-74     	; 0x1ee <task3+0x2e>
		}	
	}
	xSemaphoreGive(semaphore);
     238:	20 e0       	ldi	r18, 0x00	; 0
     23a:	40 e0       	ldi	r20, 0x00	; 0
     23c:	50 e0       	ldi	r21, 0x00	; 0
     23e:	60 e0       	ldi	r22, 0x00	; 0
     240:	70 e0       	ldi	r23, 0x00	; 0
     242:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
     246:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
     24a:	0e 94 d4 08 	call	0x11a8	; 0x11a8 <xQueueGenericSend>
	vTaskDelay(3000);
     24e:	88 eb       	ldi	r24, 0xB8	; 184
     250:	9b e0       	ldi	r25, 0x0B	; 11
     252:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskDelay>
}
     256:	0f 90       	pop	r0
     258:	0f 90       	pop	r0
     25a:	0f 90       	pop	r0
     25c:	0f 90       	pop	r0
     25e:	df 91       	pop	r29
     260:	cf 91       	pop	r28
     262:	08 95       	ret

00000264 <task4>:


void task4()
{
     264:	cf 92       	push	r12
     266:	df 92       	push	r13
     268:	ef 92       	push	r14
     26a:	ff 92       	push	r15
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	00 d0       	rcall	.+0      	; 0x272 <task4+0xe>
     272:	00 d0       	rcall	.+0      	; 0x274 <task4+0x10>
     274:	cd b7       	in	r28, 0x3d	; 61
     276:	de b7       	in	r29, 0x3e	; 62
	f32 temp;
	u8 dc = 0;
	if (xSemaphoreTake(semaphore , 400) == 1)
     278:	20 e0       	ldi	r18, 0x00	; 0
     27a:	40 e9       	ldi	r20, 0x90	; 144
     27c:	51 e0       	ldi	r21, 0x01	; 1
     27e:	60 e0       	ldi	r22, 0x00	; 0
     280:	70 e0       	ldi	r23, 0x00	; 0
     282:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <semaphore>
     286:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <semaphore+0x1>
     28a:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
     28e:	81 30       	cpi	r24, 0x01	; 1
     290:	09 f0       	breq	.+2      	; 0x294 <task4+0x30>
     292:	8d c0       	rjmp	.+282    	; 0x3ae <task4+0x14a>
	{
		while(1)
		{
			xQueueReceive(queue2 , &temp , 200);
     294:	20 e0       	ldi	r18, 0x00	; 0
     296:	48 ec       	ldi	r20, 0xC8	; 200
     298:	50 e0       	ldi	r21, 0x00	; 0
     29a:	be 01       	movw	r22, r28
     29c:	6f 5f       	subi	r22, 0xFF	; 255
     29e:	7f 4f       	sbci	r23, 0xFF	; 255
     2a0:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <queue2>
     2a4:	90 91 61 05 	lds	r25, 0x0561	; 0x800561 <queue2+0x1>
     2a8:	0e 94 66 09 	call	0x12cc	; 0x12cc <xQueueGenericReceive>
			LCD_voidGotoxy(0,0);
     2ac:	60 e0       	ldi	r22, 0x00	; 0
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
			LCD_voidSendString("Temperature = ");
     2b4:	89 e9       	ldi	r24, 0x99	; 153
     2b6:	90 e0       	ldi	r25, 0x00	; 0
     2b8:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
			LCD_voidSendNumber(temp);
     2bc:	69 81       	ldd	r22, Y+1	; 0x01
     2be:	7a 81       	ldd	r23, Y+2	; 0x02
     2c0:	8b 81       	ldd	r24, Y+3	; 0x03
     2c2:	9c 81       	ldd	r25, Y+4	; 0x04
     2c4:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <__fixunssfsi>
     2c8:	0e 94 03 03 	call	0x606	; 0x606 <LCD_voidSendNumber>
			if (temp < 30)
     2cc:	c9 80       	ldd	r12, Y+1	; 0x01
     2ce:	da 80       	ldd	r13, Y+2	; 0x02
     2d0:	eb 80       	ldd	r14, Y+3	; 0x03
     2d2:	fc 80       	ldd	r15, Y+4	; 0x04
     2d4:	20 e0       	ldi	r18, 0x00	; 0
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	40 ef       	ldi	r20, 0xF0	; 240
     2da:	51 e4       	ldi	r21, 0x41	; 65
     2dc:	c7 01       	movw	r24, r14
     2de:	b6 01       	movw	r22, r12
     2e0:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__cmpsf2>
     2e4:	88 23       	and	r24, r24
     2e6:	64 f4       	brge	.+24     	; 0x300 <task4+0x9c>
			{
				dc = 0;
				TIMER0_voidFastPWM(dc);
     2e8:	80 e0       	ldi	r24, 0x00	; 0
     2ea:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0,1);
     2ee:	61 e0       	ldi	r22, 0x01	; 1
     2f0:	80 e0       	ldi	r24, 0x00	; 0
     2f2:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 0%");
     2f6:	88 ea       	ldi	r24, 0xA8	; 168
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
     2fe:	ca cf       	rjmp	.-108    	; 0x294 <task4+0x30>
			}
			else if ((temp >= 30) && (temp < 40))
     300:	20 e0       	ldi	r18, 0x00	; 0
     302:	30 e0       	ldi	r19, 0x00	; 0
     304:	40 ef       	ldi	r20, 0xF0	; 240
     306:	51 e4       	ldi	r21, 0x41	; 65
     308:	c7 01       	movw	r24, r14
     30a:	b6 01       	movw	r22, r12
     30c:	0e 94 87 10 	call	0x210e	; 0x210e <__gesf2>
     310:	88 23       	and	r24, r24
     312:	b4 f0       	brlt	.+44     	; 0x340 <task4+0xdc>
     314:	20 e0       	ldi	r18, 0x00	; 0
     316:	30 e0       	ldi	r19, 0x00	; 0
     318:	40 e2       	ldi	r20, 0x20	; 32
     31a:	52 e4       	ldi	r21, 0x42	; 66
     31c:	c7 01       	movw	r24, r14
     31e:	b6 01       	movw	r22, r12
     320:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__cmpsf2>
     324:	88 23       	and	r24, r24
     326:	64 f4       	brge	.+24     	; 0x340 <task4+0xdc>
			{
				dc = 30;
				TIMER0_voidFastPWM(dc);
     328:	8e e1       	ldi	r24, 0x1E	; 30
     32a:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0,1);
     32e:	61 e0       	ldi	r22, 0x01	; 1
     330:	80 e0       	ldi	r24, 0x00	; 0
     332:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 30%");
     336:	87 eb       	ldi	r24, 0xB7	; 183
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
     33e:	aa cf       	rjmp	.-172    	; 0x294 <task4+0x30>
			}
			else if ((temp >= 40) && (temp < 50))
     340:	20 e0       	ldi	r18, 0x00	; 0
     342:	30 e0       	ldi	r19, 0x00	; 0
     344:	40 e2       	ldi	r20, 0x20	; 32
     346:	52 e4       	ldi	r21, 0x42	; 66
     348:	c7 01       	movw	r24, r14
     34a:	b6 01       	movw	r22, r12
     34c:	0e 94 87 10 	call	0x210e	; 0x210e <__gesf2>
     350:	88 23       	and	r24, r24
     352:	b4 f0       	brlt	.+44     	; 0x380 <task4+0x11c>
     354:	20 e0       	ldi	r18, 0x00	; 0
     356:	30 e0       	ldi	r19, 0x00	; 0
     358:	48 e4       	ldi	r20, 0x48	; 72
     35a:	52 e4       	ldi	r21, 0x42	; 66
     35c:	c7 01       	movw	r24, r14
     35e:	b6 01       	movw	r22, r12
     360:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <__cmpsf2>
     364:	88 23       	and	r24, r24
     366:	64 f4       	brge	.+24     	; 0x380 <task4+0x11c>
			{
				dc = 50;
				TIMER0_voidFastPWM(dc);
     368:	82 e3       	ldi	r24, 0x32	; 50
     36a:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0,1);
     36e:	61 e0       	ldi	r22, 0x01	; 1
     370:	80 e0       	ldi	r24, 0x00	; 0
     372:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 50%");
     376:	87 ec       	ldi	r24, 0xC7	; 199
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
     37e:	8a cf       	rjmp	.-236    	; 0x294 <task4+0x30>
			}
			else if (temp >= 50)
     380:	20 e0       	ldi	r18, 0x00	; 0
     382:	30 e0       	ldi	r19, 0x00	; 0
     384:	48 e4       	ldi	r20, 0x48	; 72
     386:	52 e4       	ldi	r21, 0x42	; 66
     388:	c7 01       	movw	r24, r14
     38a:	b6 01       	movw	r22, r12
     38c:	0e 94 87 10 	call	0x210e	; 0x210e <__gesf2>
     390:	88 23       	and	r24, r24
     392:	0c f4       	brge	.+2      	; 0x396 <task4+0x132>
     394:	7f cf       	rjmp	.-258    	; 0x294 <task4+0x30>
			{
				dc = 99;
				TIMER0_voidFastPWM(dc);
     396:	83 e6       	ldi	r24, 0x63	; 99
     398:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <TIMER0_voidFastPWM>
				LCD_voidGotoxy(0,1);
     39c:	61 e0       	ldi	r22, 0x01	; 1
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <LCD_voidGotoxy>
				LCD_voidSendString("Fan Speed = 100%");
     3a4:	87 ed       	ldi	r24, 0xD7	; 215
     3a6:	90 e0       	ldi	r25, 0x00	; 0
     3a8:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <LCD_voidSendString>
     3ac:	73 cf       	rjmp	.-282    	; 0x294 <task4+0x30>
			}
		}
	}
	vTaskDelay(4000);
     3ae:	80 ea       	ldi	r24, 0xA0	; 160
     3b0:	9f e0       	ldi	r25, 0x0F	; 15
     3b2:	0e 94 59 0d 	call	0x1ab2	; 0x1ab2 <vTaskDelay>
}
     3b6:	0f 90       	pop	r0
     3b8:	0f 90       	pop	r0
     3ba:	0f 90       	pop	r0
     3bc:	0f 90       	pop	r0
     3be:	df 91       	pop	r29
     3c0:	cf 91       	pop	r28
     3c2:	ff 90       	pop	r15
     3c4:	ef 90       	pop	r14
     3c6:	df 90       	pop	r13
     3c8:	cf 90       	pop	r12
     3ca:	08 95       	ret

000003cc <main>:

int main(void)
{
     3cc:	ef 92       	push	r14
     3ce:	ff 92       	push	r15
     3d0:	0f 93       	push	r16
	DIO_voidSetPortDir(DIO_PORTA , 0xf0);
     3d2:	60 ef       	ldi	r22, 0xF0	; 240
     3d4:	80 e0       	ldi	r24, 0x00	; 0
     3d6:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_voidSetPortDir>
	DIO_voidSetPinDir(DIO_PORTD , DIO_PIN0 , INPUT);
     3da:	40 e0       	ldi	r20, 0x00	; 0
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	83 e0       	ldi	r24, 0x03	; 3
     3e0:	0e 94 6e 03 	call	0x6dc	; 0x6dc <DIO_voidSetPinDir>
	DIO_voidSetPinDir(DIO_PORTD , DIO_PIN1 , INPUT);
     3e4:	40 e0       	ldi	r20, 0x00	; 0
     3e6:	61 e0       	ldi	r22, 0x01	; 1
     3e8:	83 e0       	ldi	r24, 0x03	; 3
     3ea:	0e 94 6e 03 	call	0x6dc	; 0x6dc <DIO_voidSetPinDir>
	DIO_voidSetPortDir(DIO_PORTB , 0xcf);
     3ee:	6f ec       	ldi	r22, 0xCF	; 207
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	0e 94 54 04 	call	0x8a8	; 0x8a8 <DIO_voidSetPortDir>
	LCD_voidInit();
     3f6:	0e 94 c9 02 	call	0x592	; 0x592 <LCD_voidInit>
	ADC_voidInit();
     3fa:	0e 94 4d 03 	call	0x69a	; 0x69a <ADC_voidInit>
	UART_voidInit();
     3fe:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <UART_voidInit>
	xTaskCreate(task1 , "task1" , 80 , NULL , 4 , NULL);
     402:	e1 2c       	mov	r14, r1
     404:	f1 2c       	mov	r15, r1
     406:	04 e0       	ldi	r16, 0x04	; 4
     408:	20 e0       	ldi	r18, 0x00	; 0
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	40 e5       	ldi	r20, 0x50	; 80
     40e:	50 e0       	ldi	r21, 0x00	; 0
     410:	68 ee       	ldi	r22, 0xE8	; 232
     412:	70 e0       	ldi	r23, 0x00	; 0
     414:	89 e4       	ldi	r24, 0x49	; 73
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xTaskCreate>
	xTaskCreate(task2 , "task2" , 80 , NULL , 3 , NULL);
     41c:	03 e0       	ldi	r16, 0x03	; 3
     41e:	20 e0       	ldi	r18, 0x00	; 0
     420:	30 e0       	ldi	r19, 0x00	; 0
     422:	40 e5       	ldi	r20, 0x50	; 80
     424:	50 e0       	ldi	r21, 0x00	; 0
     426:	6e ee       	ldi	r22, 0xEE	; 238
     428:	70 e0       	ldi	r23, 0x00	; 0
     42a:	8b e7       	ldi	r24, 0x7B	; 123
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xTaskCreate>
	xTaskCreate(task3 , "task3" , 80 , NULL , 2 , NULL);
     432:	02 e0       	ldi	r16, 0x02	; 2
     434:	20 e0       	ldi	r18, 0x00	; 0
     436:	30 e0       	ldi	r19, 0x00	; 0
     438:	40 e5       	ldi	r20, 0x50	; 80
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	64 ef       	ldi	r22, 0xF4	; 244
     43e:	70 e0       	ldi	r23, 0x00	; 0
     440:	80 ee       	ldi	r24, 0xE0	; 224
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xTaskCreate>
	xTaskCreate(task4 , "task4" , 80 , NULL , 1 , NULL);
     448:	01 e0       	ldi	r16, 0x01	; 1
     44a:	20 e0       	ldi	r18, 0x00	; 0
     44c:	30 e0       	ldi	r19, 0x00	; 0
     44e:	40 e5       	ldi	r20, 0x50	; 80
     450:	50 e0       	ldi	r21, 0x00	; 0
     452:	6a ef       	ldi	r22, 0xFA	; 250
     454:	70 e0       	ldi	r23, 0x00	; 0
     456:	82 e3       	ldi	r24, 0x32	; 50
     458:	91 e0       	ldi	r25, 0x01	; 1
     45a:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xTaskCreate>
	semaphore = xSemaphoreCreateBinary();
     45e:	43 e0       	ldi	r20, 0x03	; 3
     460:	60 e0       	ldi	r22, 0x00	; 0
     462:	81 e0       	ldi	r24, 0x01	; 1
     464:	0e 94 aa 08 	call	0x1154	; 0x1154 <xQueueGenericCreate>
     468:	90 93 5f 05 	sts	0x055F, r25	; 0x80055f <semaphore+0x1>
     46c:	80 93 5e 05 	sts	0x055E, r24	; 0x80055e <semaphore>
	queue1 = xQueueCreate(1 , sizeof(u8));
     470:	40 e0       	ldi	r20, 0x00	; 0
     472:	61 e0       	ldi	r22, 0x01	; 1
     474:	81 e0       	ldi	r24, 0x01	; 1
     476:	0e 94 aa 08 	call	0x1154	; 0x1154 <xQueueGenericCreate>
     47a:	90 93 63 05 	sts	0x0563, r25	; 0x800563 <queue1+0x1>
     47e:	80 93 62 05 	sts	0x0562, r24	; 0x800562 <queue1>
	queue2 = xQueueCreate(1 , sizeof(f32));
     482:	40 e0       	ldi	r20, 0x00	; 0
     484:	64 e0       	ldi	r22, 0x04	; 4
     486:	81 e0       	ldi	r24, 0x01	; 1
     488:	0e 94 aa 08 	call	0x1154	; 0x1154 <xQueueGenericCreate>
     48c:	90 93 61 05 	sts	0x0561, r25	; 0x800561 <queue2+0x1>
     490:	80 93 60 05 	sts	0x0560, r24	; 0x800560 <queue2>
	vTaskStartScheduler();
     494:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <vTaskStartScheduler>
}
     498:	80 e0       	ldi	r24, 0x00	; 0
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	0f 91       	pop	r16
     49e:	ff 90       	pop	r15
     4a0:	ef 90       	pop	r14
     4a2:	08 95       	ret

000004a4 <LCD_voidSHD>:
	  LCD_voidSendData(pattern) ; 
	  
	  
	
	
}
     4a4:	0f 93       	push	r16
     4a6:	1f 93       	push	r17
     4a8:	cf 93       	push	r28
     4aa:	df 93       	push	r29
     4ac:	00 d0       	rcall	.+0      	; 0x4ae <LCD_voidSHD+0xa>
     4ae:	00 d0       	rcall	.+0      	; 0x4b0 <LCD_voidSHD+0xc>
     4b0:	cd b7       	in	r28, 0x3d	; 61
     4b2:	de b7       	in	r29, 0x3e	; 62
     4b4:	08 2f       	mov	r16, r24
     4b6:	84 e0       	ldi	r24, 0x04	; 4
     4b8:	89 83       	std	Y+1, r24	; 0x01
     4ba:	85 e0       	ldi	r24, 0x05	; 5
     4bc:	8a 83       	std	Y+2, r24	; 0x02
     4be:	86 e0       	ldi	r24, 0x06	; 6
     4c0:	8b 83       	std	Y+3, r24	; 0x03
     4c2:	87 e0       	ldi	r24, 0x07	; 7
     4c4:	8c 83       	std	Y+4, r24	; 0x04
     4c6:	10 e0       	ldi	r17, 0x00	; 0
     4c8:	14 c0       	rjmp	.+40     	; 0x4f2 <LCD_voidSHD+0x4e>
     4ca:	40 2f       	mov	r20, r16
     4cc:	50 e0       	ldi	r21, 0x00	; 0
     4ce:	01 2e       	mov	r0, r17
     4d0:	02 c0       	rjmp	.+4      	; 0x4d6 <LCD_voidSHD+0x32>
     4d2:	55 95       	asr	r21
     4d4:	47 95       	ror	r20
     4d6:	0a 94       	dec	r0
     4d8:	e2 f7       	brpl	.-8      	; 0x4d2 <LCD_voidSHD+0x2e>
     4da:	41 70       	andi	r20, 0x01	; 1
     4dc:	e1 e0       	ldi	r30, 0x01	; 1
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	ec 0f       	add	r30, r28
     4e2:	fd 1f       	adc	r31, r29
     4e4:	e1 0f       	add	r30, r17
     4e6:	f1 1d       	adc	r31, r1
     4e8:	60 81       	ld	r22, Z
     4ea:	80 e0       	ldi	r24, 0x00	; 0
     4ec:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     4f0:	1f 5f       	subi	r17, 0xFF	; 255
     4f2:	14 30       	cpi	r17, 0x04	; 4
     4f4:	50 f3       	brcs	.-44     	; 0x4ca <LCD_voidSHD+0x26>
     4f6:	0f 90       	pop	r0
     4f8:	0f 90       	pop	r0
     4fa:	0f 90       	pop	r0
     4fc:	0f 90       	pop	r0
     4fe:	df 91       	pop	r29
     500:	cf 91       	pop	r28
     502:	1f 91       	pop	r17
     504:	0f 91       	pop	r16
     506:	08 95       	ret

00000508 <LCD_voidSendEnable>:
     508:	41 e0       	ldi	r20, 0x01	; 1
     50a:	62 e0       	ldi	r22, 0x02	; 2
     50c:	81 e0       	ldi	r24, 0x01	; 1
     50e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     512:	8f e3       	ldi	r24, 0x3F	; 63
     514:	9f e1       	ldi	r25, 0x1F	; 31
     516:	01 97       	sbiw	r24, 0x01	; 1
     518:	f1 f7       	brne	.-4      	; 0x516 <LCD_voidSendEnable+0xe>
     51a:	00 c0       	rjmp	.+0      	; 0x51c <LCD_voidSendEnable+0x14>
     51c:	00 00       	nop
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	62 e0       	ldi	r22, 0x02	; 2
     522:	81 e0       	ldi	r24, 0x01	; 1
     524:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     528:	08 95       	ret

0000052a <LCD_voidSendData>:
     52a:	cf 93       	push	r28
     52c:	c8 2f       	mov	r28, r24
     52e:	41 e0       	ldi	r20, 0x01	; 1
     530:	60 e0       	ldi	r22, 0x00	; 0
     532:	81 e0       	ldi	r24, 0x01	; 1
     534:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     538:	40 e0       	ldi	r20, 0x00	; 0
     53a:	61 e0       	ldi	r22, 0x01	; 1
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     542:	8c 2f       	mov	r24, r28
     544:	82 95       	swap	r24
     546:	8f 70       	andi	r24, 0x0F	; 15
     548:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     54c:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     550:	8c 2f       	mov	r24, r28
     552:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     556:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     55a:	cf 91       	pop	r28
     55c:	08 95       	ret

0000055e <LCD_voidSendCommand>:
     55e:	cf 93       	push	r28
     560:	c8 2f       	mov	r28, r24
     562:	40 e0       	ldi	r20, 0x00	; 0
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	81 e0       	ldi	r24, 0x01	; 1
     568:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	61 e0       	ldi	r22, 0x01	; 1
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <DIO_voidSetPinVal>
     576:	8c 2f       	mov	r24, r28
     578:	82 95       	swap	r24
     57a:	8f 70       	andi	r24, 0x0F	; 15
     57c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     580:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     584:	8c 2f       	mov	r24, r28
     586:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     58a:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     58e:	cf 91       	pop	r28
     590:	08 95       	ret

00000592 <LCD_voidInit>:
     592:	2f ef       	ldi	r18, 0xFF	; 255
     594:	83 ef       	ldi	r24, 0xF3	; 243
     596:	91 e0       	ldi	r25, 0x01	; 1
     598:	21 50       	subi	r18, 0x01	; 1
     59a:	80 40       	sbci	r24, 0x00	; 0
     59c:	90 40       	sbci	r25, 0x00	; 0
     59e:	e1 f7       	brne	.-8      	; 0x598 <LCD_voidInit+0x6>
     5a0:	00 c0       	rjmp	.+0      	; 0x5a2 <LCD_voidInit+0x10>
     5a2:	00 00       	nop
     5a4:	82 e0       	ldi	r24, 0x02	; 2
     5a6:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     5aa:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     5ae:	82 e0       	ldi	r24, 0x02	; 2
     5b0:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     5b4:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     5b8:	88 e0       	ldi	r24, 0x08	; 8
     5ba:	0e 94 52 02 	call	0x4a4	; 0x4a4 <LCD_voidSHD>
     5be:	0e 94 84 02 	call	0x508	; 0x508 <LCD_voidSendEnable>
     5c2:	8c e0       	ldi	r24, 0x0C	; 12
     5c4:	0e 94 af 02 	call	0x55e	; 0x55e <LCD_voidSendCommand>
     5c8:	81 e0       	ldi	r24, 0x01	; 1
     5ca:	0e 94 af 02 	call	0x55e	; 0x55e <LCD_voidSendCommand>
     5ce:	08 95       	ret

000005d0 <LCD_voidSendString>:
     5d0:	0f 93       	push	r16
     5d2:	1f 93       	push	r17
     5d4:	cf 93       	push	r28
     5d6:	8c 01       	movw	r16, r24
     5d8:	c0 e0       	ldi	r28, 0x00	; 0
     5da:	03 c0       	rjmp	.+6      	; 0x5e2 <LCD_voidSendString+0x12>
     5dc:	0e 94 95 02 	call	0x52a	; 0x52a <LCD_voidSendData>
     5e0:	cf 5f       	subi	r28, 0xFF	; 255
     5e2:	f8 01       	movw	r30, r16
     5e4:	ec 0f       	add	r30, r28
     5e6:	f1 1d       	adc	r31, r1
     5e8:	80 81       	ld	r24, Z
     5ea:	81 11       	cpse	r24, r1
     5ec:	f7 cf       	rjmp	.-18     	; 0x5dc <LCD_voidSendString+0xc>
     5ee:	cf 91       	pop	r28
     5f0:	1f 91       	pop	r17
     5f2:	0f 91       	pop	r16
     5f4:	08 95       	ret

000005f6 <LCD_voidGotoxy>:
     5f6:	90 e4       	ldi	r25, 0x40	; 64
     5f8:	69 9f       	mul	r22, r25
     5fa:	80 0d       	add	r24, r0
     5fc:	11 24       	eor	r1, r1
     5fe:	80 68       	ori	r24, 0x80	; 128
     600:	0e 94 af 02 	call	0x55e	; 0x55e <LCD_voidSendCommand>
     604:	08 95       	ret

00000606 <LCD_voidSendNumber>:
void LCD_voidSendNumber(u32 number){
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	2a 97       	sbiw	r28, 0x0a	; 10
     612:	0f b6       	in	r0, 0x3f	; 63
     614:	f8 94       	cli
     616:	de bf       	out	0x3e, r29	; 62
     618:	0f be       	out	0x3f, r0	; 63
     61a:	cd bf       	out	0x3d, r28	; 61
	
	s8 i=0;
	u8 array[10] ;
	
	if(number==0){
     61c:	61 15       	cp	r22, r1
     61e:	71 05       	cpc	r23, r1
     620:	81 05       	cpc	r24, r1
     622:	91 05       	cpc	r25, r1
     624:	d1 f4       	brne	.+52     	; 0x65a <LCD_voidSendNumber+0x54>
		
		LCD_voidSendData('0') ;
     626:	80 e3       	ldi	r24, 0x30	; 48
     628:	0e 94 95 02 	call	0x52a	; 0x52a <LCD_voidSendData>
     62c:	2c c0       	rjmp	.+88     	; 0x686 <LCD_voidSendNumber+0x80>
		return ;
	}
	for(i=0; number!=0 ;i++){
		
		array[i]= number % 10 + 48 ;
     62e:	2a e0       	ldi	r18, 0x0A	; 10
     630:	30 e0       	ldi	r19, 0x00	; 0
     632:	40 e0       	ldi	r20, 0x00	; 0
     634:	50 e0       	ldi	r21, 0x00	; 0
     636:	0e 94 21 11 	call	0x2242	; 0x2242 <__udivmodsi4>
     63a:	e1 e0       	ldi	r30, 0x01	; 1
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 0f       	add	r30, r28
     640:	fd 1f       	adc	r31, r29
     642:	e1 0f       	add	r30, r17
     644:	f1 1d       	adc	r31, r1
     646:	17 fd       	sbrc	r17, 7
     648:	fa 95       	dec	r31
     64a:	60 5d       	subi	r22, 0xD0	; 208
     64c:	60 83       	st	Z, r22
		number /= 10 ;
     64e:	62 2f       	mov	r22, r18
     650:	73 2f       	mov	r23, r19
     652:	84 2f       	mov	r24, r20
     654:	95 2f       	mov	r25, r21
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
     656:	1f 5f       	subi	r17, 0xFF	; 255
     658:	01 c0       	rjmp	.+2      	; 0x65c <LCD_voidSendNumber+0x56>
     65a:	10 e0       	ldi	r17, 0x00	; 0
     65c:	61 15       	cp	r22, r1
     65e:	71 05       	cpc	r23, r1
     660:	81 05       	cpc	r24, r1
     662:	91 05       	cpc	r25, r1
     664:	21 f7       	brne	.-56     	; 0x62e <LCD_voidSendNumber+0x28>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
     666:	11 50       	subi	r17, 0x01	; 1
	while(i >= 0){
     668:	0c c0       	rjmp	.+24     	; 0x682 <LCD_voidSendNumber+0x7c>
		
		LCD_voidSendData(array[i]) ;
     66a:	e1 e0       	ldi	r30, 0x01	; 1
     66c:	f0 e0       	ldi	r31, 0x00	; 0
     66e:	ec 0f       	add	r30, r28
     670:	fd 1f       	adc	r31, r29
     672:	e1 0f       	add	r30, r17
     674:	f1 1d       	adc	r31, r1
     676:	17 fd       	sbrc	r17, 7
     678:	fa 95       	dec	r31
     67a:	80 81       	ld	r24, Z
     67c:	0e 94 95 02 	call	0x52a	; 0x52a <LCD_voidSendData>
		i-- ;
     680:	11 50       	subi	r17, 0x01	; 1
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
     682:	11 23       	and	r17, r17
     684:	94 f7       	brge	.-28     	; 0x66a <LCD_voidSendNumber+0x64>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
     686:	2a 96       	adiw	r28, 0x0a	; 10
     688:	0f b6       	in	r0, 0x3f	; 63
     68a:	f8 94       	cli
     68c:	de bf       	out	0x3e, r29	; 62
     68e:	0f be       	out	0x3f, r0	; 63
     690:	cd bf       	out	0x3d, r28	; 61
     692:	df 91       	pop	r29
     694:	cf 91       	pop	r28
     696:	1f 91       	pop	r17
     698:	08 95       	ret

0000069a <ADC_voidInit>:


void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
     69a:	87 b1       	in	r24, 0x07	; 7
     69c:	8f 77       	andi	r24, 0x7F	; 127
     69e:	87 b9       	out	0x07, r24	; 7
	 SET_BIT(ADMUX_REG,6) ; 
     6a0:	87 b1       	in	r24, 0x07	; 7
     6a2:	80 64       	ori	r24, 0x40	; 64
     6a4:	87 b9       	out	0x07, r24	; 7
	 
	/*select prescaler */
	 
	 ADCSRA_REG&=0b11111000 ; 
     6a6:	86 b1       	in	r24, 0x06	; 6
     6a8:	88 7f       	andi	r24, 0xF8	; 248
     6aa:	86 b9       	out	0x06, r24	; 6
	 ADCSRA_REG|=ADC_PRESCALER ; 
     6ac:	86 b1       	in	r24, 0x06	; 6
     6ae:	87 60       	ori	r24, 0x07	; 7
     6b0:	86 b9       	out	0x06, r24	; 6
	
	
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
     6b2:	86 b1       	in	r24, 0x06	; 6
     6b4:	80 68       	ori	r24, 0x80	; 128
     6b6:	86 b9       	out	0x06, r24	; 6
     6b8:	08 95       	ret

000006ba <ADC_u16ReadChannel>:
}

u16 ADC_u16ReadChannel(u8 copy_u8channel){
	
	  /* select channel */
	  ADMUX_REG &=0b11100000 ; 
     6ba:	97 b1       	in	r25, 0x07	; 7
     6bc:	90 7e       	andi	r25, 0xE0	; 224
     6be:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG |=copy_u8channel ; 
     6c0:	97 b1       	in	r25, 0x07	; 7
     6c2:	89 2b       	or	r24, r25
     6c4:	87 b9       	out	0x07, r24	; 7
	  /* start conversion */
	  SET_BIT(ADCSRA_REG,6) ; 
     6c6:	86 b1       	in	r24, 0x06	; 6
     6c8:	80 64       	ori	r24, 0x40	; 64
     6ca:	86 b9       	out	0x06, r24	; 6
	  
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
     6cc:	34 9b       	sbis	0x06, 4	; 6
     6ce:	fe cf       	rjmp	.-4      	; 0x6cc <ADC_u16ReadChannel+0x12>
	  
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
     6d0:	86 b1       	in	r24, 0x06	; 6
     6d2:	80 61       	ori	r24, 0x10	; 16
     6d4:	86 b9       	out	0x06, r24	; 6
	  
	  return  ADC_REG ; 
     6d6:	84 b1       	in	r24, 0x04	; 4
     6d8:	95 b1       	in	r25, 0x05	; 5

     6da:	08 95       	ret

000006dc <DIO_voidSetPinDir>:
	
	
	return Loc_u8Val ; 
	
	
}
     6dc:	42 30       	cpi	r20, 0x02	; 2
     6de:	08 f0       	brcs	.+2      	; 0x6e2 <DIO_voidSetPinDir+0x6>
     6e0:	6f c0       	rjmp	.+222    	; 0x7c0 <DIO_voidSetPinDir+0xe4>
     6e2:	41 30       	cpi	r20, 0x01	; 1
     6e4:	a1 f5       	brne	.+104    	; 0x74e <DIO_voidSetPinDir+0x72>
     6e6:	81 30       	cpi	r24, 0x01	; 1
     6e8:	89 f0       	breq	.+34     	; 0x70c <DIO_voidSetPinDir+0x30>
     6ea:	28 f0       	brcs	.+10     	; 0x6f6 <DIO_voidSetPinDir+0x1a>
     6ec:	82 30       	cpi	r24, 0x02	; 2
     6ee:	c9 f0       	breq	.+50     	; 0x722 <DIO_voidSetPinDir+0x46>
     6f0:	83 30       	cpi	r24, 0x03	; 3
     6f2:	11 f1       	breq	.+68     	; 0x738 <DIO_voidSetPinDir+0x5c>
     6f4:	08 95       	ret
     6f6:	2a b3       	in	r18, 0x1a	; 26
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	02 c0       	rjmp	.+4      	; 0x702 <DIO_voidSetPinDir+0x26>
     6fe:	88 0f       	add	r24, r24
     700:	99 1f       	adc	r25, r25
     702:	6a 95       	dec	r22
     704:	e2 f7       	brpl	.-8      	; 0x6fe <DIO_voidSetPinDir+0x22>
     706:	82 2b       	or	r24, r18
     708:	8a bb       	out	0x1a, r24	; 26
     70a:	08 95       	ret
     70c:	27 b3       	in	r18, 0x17	; 23
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	02 c0       	rjmp	.+4      	; 0x718 <DIO_voidSetPinDir+0x3c>
     714:	88 0f       	add	r24, r24
     716:	99 1f       	adc	r25, r25
     718:	6a 95       	dec	r22
     71a:	e2 f7       	brpl	.-8      	; 0x714 <DIO_voidSetPinDir+0x38>
     71c:	82 2b       	or	r24, r18
     71e:	87 bb       	out	0x17, r24	; 23
     720:	08 95       	ret
     722:	24 b3       	in	r18, 0x14	; 20
     724:	81 e0       	ldi	r24, 0x01	; 1
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	02 c0       	rjmp	.+4      	; 0x72e <DIO_voidSetPinDir+0x52>
     72a:	88 0f       	add	r24, r24
     72c:	99 1f       	adc	r25, r25
     72e:	6a 95       	dec	r22
     730:	e2 f7       	brpl	.-8      	; 0x72a <DIO_voidSetPinDir+0x4e>
     732:	82 2b       	or	r24, r18
     734:	84 bb       	out	0x14, r24	; 20
     736:	08 95       	ret
     738:	21 b3       	in	r18, 0x11	; 17
     73a:	81 e0       	ldi	r24, 0x01	; 1
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	02 c0       	rjmp	.+4      	; 0x744 <DIO_voidSetPinDir+0x68>
     740:	88 0f       	add	r24, r24
     742:	99 1f       	adc	r25, r25
     744:	6a 95       	dec	r22
     746:	e2 f7       	brpl	.-8      	; 0x740 <DIO_voidSetPinDir+0x64>
     748:	82 2b       	or	r24, r18
     74a:	81 bb       	out	0x11, r24	; 17
     74c:	08 95       	ret
     74e:	41 11       	cpse	r20, r1
     750:	37 c0       	rjmp	.+110    	; 0x7c0 <DIO_voidSetPinDir+0xe4>
     752:	81 30       	cpi	r24, 0x01	; 1
     754:	91 f0       	breq	.+36     	; 0x77a <DIO_voidSetPinDir+0x9e>
     756:	28 f0       	brcs	.+10     	; 0x762 <DIO_voidSetPinDir+0x86>
     758:	82 30       	cpi	r24, 0x02	; 2
     75a:	d9 f0       	breq	.+54     	; 0x792 <DIO_voidSetPinDir+0xb6>
     75c:	83 30       	cpi	r24, 0x03	; 3
     75e:	29 f1       	breq	.+74     	; 0x7aa <DIO_voidSetPinDir+0xce>
     760:	08 95       	ret
     762:	2a b3       	in	r18, 0x1a	; 26
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_voidSetPinDir+0x92>
     76a:	88 0f       	add	r24, r24
     76c:	99 1f       	adc	r25, r25
     76e:	6a 95       	dec	r22
     770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_voidSetPinDir+0x8e>
     772:	80 95       	com	r24
     774:	82 23       	and	r24, r18
     776:	8a bb       	out	0x1a, r24	; 26
     778:	08 95       	ret
     77a:	27 b3       	in	r18, 0x17	; 23
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	90 e0       	ldi	r25, 0x00	; 0
     780:	02 c0       	rjmp	.+4      	; 0x786 <DIO_voidSetPinDir+0xaa>
     782:	88 0f       	add	r24, r24
     784:	99 1f       	adc	r25, r25
     786:	6a 95       	dec	r22
     788:	e2 f7       	brpl	.-8      	; 0x782 <DIO_voidSetPinDir+0xa6>
     78a:	80 95       	com	r24
     78c:	82 23       	and	r24, r18
     78e:	87 bb       	out	0x17, r24	; 23
     790:	08 95       	ret
     792:	24 b3       	in	r18, 0x14	; 20
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	02 c0       	rjmp	.+4      	; 0x79e <DIO_voidSetPinDir+0xc2>
     79a:	88 0f       	add	r24, r24
     79c:	99 1f       	adc	r25, r25
     79e:	6a 95       	dec	r22
     7a0:	e2 f7       	brpl	.-8      	; 0x79a <DIO_voidSetPinDir+0xbe>
     7a2:	80 95       	com	r24
     7a4:	82 23       	and	r24, r18
     7a6:	84 bb       	out	0x14, r24	; 20
     7a8:	08 95       	ret
     7aa:	21 b3       	in	r18, 0x11	; 17
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	02 c0       	rjmp	.+4      	; 0x7b6 <DIO_voidSetPinDir+0xda>
     7b2:	88 0f       	add	r24, r24
     7b4:	99 1f       	adc	r25, r25
     7b6:	6a 95       	dec	r22
     7b8:	e2 f7       	brpl	.-8      	; 0x7b2 <DIO_voidSetPinDir+0xd6>
     7ba:	80 95       	com	r24
     7bc:	82 23       	and	r24, r18
     7be:	81 bb       	out	0x11, r24	; 17
     7c0:	08 95       	ret

000007c2 <DIO_voidSetPinVal>:
     7c2:	42 30       	cpi	r20, 0x02	; 2
     7c4:	08 f0       	brcs	.+2      	; 0x7c8 <DIO_voidSetPinVal+0x6>
     7c6:	6f c0       	rjmp	.+222    	; 0x8a6 <__stack+0x47>
     7c8:	41 30       	cpi	r20, 0x01	; 1
     7ca:	a1 f5       	brne	.+104    	; 0x834 <__DATA_REGION_LENGTH__+0x34>
     7cc:	81 30       	cpi	r24, 0x01	; 1
     7ce:	89 f0       	breq	.+34     	; 0x7f2 <DIO_voidSetPinVal+0x30>
     7d0:	28 f0       	brcs	.+10     	; 0x7dc <DIO_voidSetPinVal+0x1a>
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	c9 f0       	breq	.+50     	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     7d6:	83 30       	cpi	r24, 0x03	; 3
     7d8:	11 f1       	breq	.+68     	; 0x81e <__DATA_REGION_LENGTH__+0x1e>
     7da:	08 95       	ret
     7dc:	2b b3       	in	r18, 0x1b	; 27
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	02 c0       	rjmp	.+4      	; 0x7e8 <DIO_voidSetPinVal+0x26>
     7e4:	88 0f       	add	r24, r24
     7e6:	99 1f       	adc	r25, r25
     7e8:	6a 95       	dec	r22
     7ea:	e2 f7       	brpl	.-8      	; 0x7e4 <DIO_voidSetPinVal+0x22>
     7ec:	82 2b       	or	r24, r18
     7ee:	8b bb       	out	0x1b, r24	; 27
     7f0:	08 95       	ret
     7f2:	28 b3       	in	r18, 0x18	; 24
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	02 c0       	rjmp	.+4      	; 0x7fe <DIO_voidSetPinVal+0x3c>
     7fa:	88 0f       	add	r24, r24
     7fc:	99 1f       	adc	r25, r25
     7fe:	6a 95       	dec	r22
     800:	e2 f7       	brpl	.-8      	; 0x7fa <DIO_voidSetPinVal+0x38>
     802:	82 2b       	or	r24, r18
     804:	88 bb       	out	0x18, r24	; 24
     806:	08 95       	ret
     808:	25 b3       	in	r18, 0x15	; 21
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	02 c0       	rjmp	.+4      	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     810:	88 0f       	add	r24, r24
     812:	99 1f       	adc	r25, r25
     814:	6a 95       	dec	r22
     816:	e2 f7       	brpl	.-8      	; 0x810 <__DATA_REGION_LENGTH__+0x10>
     818:	82 2b       	or	r24, r18
     81a:	85 bb       	out	0x15, r24	; 21
     81c:	08 95       	ret
     81e:	22 b3       	in	r18, 0x12	; 18
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	02 c0       	rjmp	.+4      	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
     826:	88 0f       	add	r24, r24
     828:	99 1f       	adc	r25, r25
     82a:	6a 95       	dec	r22
     82c:	e2 f7       	brpl	.-8      	; 0x826 <__DATA_REGION_LENGTH__+0x26>
     82e:	82 2b       	or	r24, r18
     830:	82 bb       	out	0x12, r24	; 18
     832:	08 95       	ret
     834:	41 11       	cpse	r20, r1
     836:	37 c0       	rjmp	.+110    	; 0x8a6 <__stack+0x47>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	91 f0       	breq	.+36     	; 0x860 <__stack+0x1>
     83c:	28 f0       	brcs	.+10     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
     83e:	82 30       	cpi	r24, 0x02	; 2
     840:	d9 f0       	breq	.+54     	; 0x878 <__stack+0x19>
     842:	83 30       	cpi	r24, 0x03	; 3
     844:	29 f1       	breq	.+74     	; 0x890 <__stack+0x31>
     846:	08 95       	ret
     848:	2b b3       	in	r18, 0x1b	; 27
     84a:	81 e0       	ldi	r24, 0x01	; 1
     84c:	90 e0       	ldi	r25, 0x00	; 0
     84e:	02 c0       	rjmp	.+4      	; 0x854 <__DATA_REGION_LENGTH__+0x54>
     850:	88 0f       	add	r24, r24
     852:	99 1f       	adc	r25, r25
     854:	6a 95       	dec	r22
     856:	e2 f7       	brpl	.-8      	; 0x850 <__DATA_REGION_LENGTH__+0x50>
     858:	80 95       	com	r24
     85a:	82 23       	and	r24, r18
     85c:	8b bb       	out	0x1b, r24	; 27
     85e:	08 95       	ret
     860:	28 b3       	in	r18, 0x18	; 24
     862:	81 e0       	ldi	r24, 0x01	; 1
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	02 c0       	rjmp	.+4      	; 0x86c <__stack+0xd>
     868:	88 0f       	add	r24, r24
     86a:	99 1f       	adc	r25, r25
     86c:	6a 95       	dec	r22
     86e:	e2 f7       	brpl	.-8      	; 0x868 <__stack+0x9>
     870:	80 95       	com	r24
     872:	82 23       	and	r24, r18
     874:	88 bb       	out	0x18, r24	; 24
     876:	08 95       	ret
     878:	25 b3       	in	r18, 0x15	; 21
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	02 c0       	rjmp	.+4      	; 0x884 <__stack+0x25>
     880:	88 0f       	add	r24, r24
     882:	99 1f       	adc	r25, r25
     884:	6a 95       	dec	r22
     886:	e2 f7       	brpl	.-8      	; 0x880 <__stack+0x21>
     888:	80 95       	com	r24
     88a:	82 23       	and	r24, r18
     88c:	85 bb       	out	0x15, r24	; 21
     88e:	08 95       	ret
     890:	22 b3       	in	r18, 0x12	; 18
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	90 e0       	ldi	r25, 0x00	; 0
     896:	02 c0       	rjmp	.+4      	; 0x89c <__stack+0x3d>
     898:	88 0f       	add	r24, r24
     89a:	99 1f       	adc	r25, r25
     89c:	6a 95       	dec	r22
     89e:	e2 f7       	brpl	.-8      	; 0x898 <__stack+0x39>
     8a0:	80 95       	com	r24
     8a2:	82 23       	and	r24, r18
     8a4:	82 bb       	out	0x12, r24	; 18
     8a6:	08 95       	ret

000008a8 <DIO_voidSetPortDir>:


void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir){
	
	switch(copy_u8port){
     8a8:	81 30       	cpi	r24, 0x01	; 1
     8aa:	41 f0       	breq	.+16     	; 0x8bc <DIO_voidSetPortDir+0x14>
     8ac:	28 f0       	brcs	.+10     	; 0x8b8 <DIO_voidSetPortDir+0x10>
     8ae:	82 30       	cpi	r24, 0x02	; 2
     8b0:	39 f0       	breq	.+14     	; 0x8c0 <DIO_voidSetPortDir+0x18>
     8b2:	83 30       	cpi	r24, 0x03	; 3
     8b4:	39 f0       	breq	.+14     	; 0x8c4 <DIO_voidSetPortDir+0x1c>
     8b6:	08 95       	ret
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ;break ; 
     8b8:	6a bb       	out	0x1a, r22	; 26
     8ba:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ;break ;
     8bc:	67 bb       	out	0x17, r22	; 23
     8be:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ;break ;
     8c0:	64 bb       	out	0x14, r22	; 20
     8c2:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ;break ;
     8c4:	61 bb       	out	0x11, r22	; 17
     8c6:	08 95       	ret

000008c8 <__vector_1>:
}


/*int0*/
void __vector_1(void)__attribute__((signal)) ;
void __vector_1(void){
     8c8:	1f 92       	push	r1
     8ca:	0f 92       	push	r0
     8cc:	0f b6       	in	r0, 0x3f	; 63
     8ce:	0f 92       	push	r0
     8d0:	11 24       	eor	r1, r1
     8d2:	2f 93       	push	r18
     8d4:	3f 93       	push	r19
     8d6:	4f 93       	push	r20
     8d8:	5f 93       	push	r21
     8da:	6f 93       	push	r22
     8dc:	7f 93       	push	r23
     8de:	8f 93       	push	r24
     8e0:	9f 93       	push	r25
     8e2:	af 93       	push	r26
     8e4:	bf 93       	push	r27
     8e6:	ef 93       	push	r30
     8e8:	ff 93       	push	r31
	
	 EXTI_PTR[0]() ; 
     8ea:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <__data_end>
     8ee:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <__data_end+0x1>
     8f2:	09 95       	icall
	
	
}
     8f4:	ff 91       	pop	r31
     8f6:	ef 91       	pop	r30
     8f8:	bf 91       	pop	r27
     8fa:	af 91       	pop	r26
     8fc:	9f 91       	pop	r25
     8fe:	8f 91       	pop	r24
     900:	7f 91       	pop	r23
     902:	6f 91       	pop	r22
     904:	5f 91       	pop	r21
     906:	4f 91       	pop	r20
     908:	3f 91       	pop	r19
     90a:	2f 91       	pop	r18
     90c:	0f 90       	pop	r0
     90e:	0f be       	out	0x3f, r0	; 63
     910:	0f 90       	pop	r0
     912:	1f 90       	pop	r1
     914:	18 95       	reti

00000916 <__vector_2>:

/*int1*/
void __vector_2(void)__attribute__((signal)) ;
void __vector_2(void){
     916:	1f 92       	push	r1
     918:	0f 92       	push	r0
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	0f 92       	push	r0
     91e:	11 24       	eor	r1, r1
     920:	2f 93       	push	r18
     922:	3f 93       	push	r19
     924:	4f 93       	push	r20
     926:	5f 93       	push	r21
     928:	6f 93       	push	r22
     92a:	7f 93       	push	r23
     92c:	8f 93       	push	r24
     92e:	9f 93       	push	r25
     930:	af 93       	push	r26
     932:	bf 93       	push	r27
     934:	ef 93       	push	r30
     936:	ff 93       	push	r31
	
	
EXTI_PTR[1]() ; 
     938:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <__data_end+0x2>
     93c:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <__data_end+0x3>
     940:	09 95       	icall
	
	
}
     942:	ff 91       	pop	r31
     944:	ef 91       	pop	r30
     946:	bf 91       	pop	r27
     948:	af 91       	pop	r26
     94a:	9f 91       	pop	r25
     94c:	8f 91       	pop	r24
     94e:	7f 91       	pop	r23
     950:	6f 91       	pop	r22
     952:	5f 91       	pop	r21
     954:	4f 91       	pop	r20
     956:	3f 91       	pop	r19
     958:	2f 91       	pop	r18
     95a:	0f 90       	pop	r0
     95c:	0f be       	out	0x3f, r0	; 63
     95e:	0f 90       	pop	r0
     960:	1f 90       	pop	r1
     962:	18 95       	reti

00000964 <__vector_3>:
/*int2 */
void __vector_3(void)__attribute__((signal)) ;
void __vector_3(void){
     964:	1f 92       	push	r1
     966:	0f 92       	push	r0
     968:	0f b6       	in	r0, 0x3f	; 63
     96a:	0f 92       	push	r0
     96c:	11 24       	eor	r1, r1
     96e:	2f 93       	push	r18
     970:	3f 93       	push	r19
     972:	4f 93       	push	r20
     974:	5f 93       	push	r21
     976:	6f 93       	push	r22
     978:	7f 93       	push	r23
     97a:	8f 93       	push	r24
     97c:	9f 93       	push	r25
     97e:	af 93       	push	r26
     980:	bf 93       	push	r27
     982:	ef 93       	push	r30
     984:	ff 93       	push	r31
	
	
	EXTI_PTR[2]() ; 
     986:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <__data_end+0x4>
     98a:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <__data_end+0x5>
     98e:	09 95       	icall
	
	
}
     990:	ff 91       	pop	r31
     992:	ef 91       	pop	r30
     994:	bf 91       	pop	r27
     996:	af 91       	pop	r26
     998:	9f 91       	pop	r25
     99a:	8f 91       	pop	r24
     99c:	7f 91       	pop	r23
     99e:	6f 91       	pop	r22
     9a0:	5f 91       	pop	r21
     9a2:	4f 91       	pop	r20
     9a4:	3f 91       	pop	r19
     9a6:	2f 91       	pop	r18
     9a8:	0f 90       	pop	r0
     9aa:	0f be       	out	0x3f, r0	; 63
     9ac:	0f 90       	pop	r0
     9ae:	1f 90       	pop	r1
     9b0:	18 95       	reti

000009b2 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     9b2:	e1 e1       	ldi	r30, 0x11	; 17
     9b4:	f1 e0       	ldi	r31, 0x01	; 1
     9b6:	86 e1       	ldi	r24, 0x16	; 22
     9b8:	91 e0       	ldi	r25, 0x01	; 1
     9ba:	91 83       	std	Z+1, r25	; 0x01
     9bc:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     9be:	13 82       	std	Z+3, r1	; 0x03
     9c0:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     9c2:	ed e0       	ldi	r30, 0x0D	; 13
     9c4:	f1 e0       	ldi	r31, 0x01	; 1
     9c6:	87 ee       	ldi	r24, 0xE7	; 231
     9c8:	93 e0       	ldi	r25, 0x03	; 3
     9ca:	93 83       	std	Z+3, r25	; 0x03
     9cc:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     9ce:	11 82       	std	Z+1, r1	; 0x01
     9d0:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     9d2:	a5 e1       	ldi	r26, 0x15	; 21
     9d4:	b1 e0       	ldi	r27, 0x01	; 1
     9d6:	14 96       	adiw	r26, 0x04	; 4
     9d8:	9c 93       	st	X, r25
     9da:	8e 93       	st	-X, r24
     9dc:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     9de:	12 96       	adiw	r26, 0x02	; 2
     9e0:	fc 93       	st	X, r31
     9e2:	ee 93       	st	-X, r30
     9e4:	11 97       	sbiw	r26, 0x01	; 1
     9e6:	08 95       	ret

000009e8 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     9e8:	0f 93       	push	r16
     9ea:	1f 93       	push	r17
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     9f2:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     9f6:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xHeapHasBeenInitialised.2079>
     9fa:	81 11       	cpse	r24, r1
     9fc:	05 c0       	rjmp	.+10     	; 0xa08 <pvPortMalloc+0x20>
		{
			prvHeapInit();
     9fe:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     a02:	81 e0       	ldi	r24, 0x01	; 1
     a04:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     a08:	20 97       	sbiw	r28, 0x00	; 0
     a0a:	09 f0       	breq	.+2      	; 0xa0e <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     a0c:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     a0e:	ce 01       	movw	r24, r28
     a10:	01 97       	sbiw	r24, 0x01	; 1
     a12:	86 3e       	cpi	r24, 0xE6	; 230
     a14:	93 40       	sbci	r25, 0x03	; 3
     a16:	08 f0       	brcs	.+2      	; 0xa1a <pvPortMalloc+0x32>
     a18:	56 c0       	rjmp	.+172    	; 0xac6 <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     a1a:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <xStart>
     a1e:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     a22:	a1 e1       	ldi	r26, 0x11	; 17
     a24:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a26:	02 c0       	rjmp	.+4      	; 0xa2c <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     a28:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     a2a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a2c:	82 81       	ldd	r24, Z+2	; 0x02
     a2e:	93 81       	ldd	r25, Z+3	; 0x03
     a30:	8c 17       	cp	r24, r28
     a32:	9d 07       	cpc	r25, r29
     a34:	20 f4       	brcc	.+8      	; 0xa3e <pvPortMalloc+0x56>
     a36:	80 81       	ld	r24, Z
     a38:	91 81       	ldd	r25, Z+1	; 0x01
     a3a:	00 97       	sbiw	r24, 0x00	; 0
     a3c:	a9 f7       	brne	.-22     	; 0xa28 <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     a3e:	81 e0       	ldi	r24, 0x01	; 1
     a40:	ed 30       	cpi	r30, 0x0D	; 13
     a42:	f8 07       	cpc	r31, r24
     a44:	09 f4       	brne	.+2      	; 0xa48 <pvPortMalloc+0x60>
     a46:	42 c0       	rjmp	.+132    	; 0xacc <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     a48:	0d 91       	ld	r16, X+
     a4a:	1c 91       	ld	r17, X
     a4c:	11 97       	sbiw	r26, 0x01	; 1
     a4e:	0c 5f       	subi	r16, 0xFC	; 252
     a50:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     a52:	80 81       	ld	r24, Z
     a54:	91 81       	ldd	r25, Z+1	; 0x01
     a56:	8d 93       	st	X+, r24
     a58:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     a5a:	82 81       	ldd	r24, Z+2	; 0x02
     a5c:	93 81       	ldd	r25, Z+3	; 0x03
     a5e:	8c 1b       	sub	r24, r28
     a60:	9d 0b       	sbc	r25, r29
     a62:	89 30       	cpi	r24, 0x09	; 9
     a64:	91 05       	cpc	r25, r1
     a66:	10 f1       	brcs	.+68     	; 0xaac <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     a68:	af 01       	movw	r20, r30
     a6a:	4c 0f       	add	r20, r28
     a6c:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     a6e:	da 01       	movw	r26, r20
     a70:	13 96       	adiw	r26, 0x03	; 3
     a72:	9c 93       	st	X, r25
     a74:	8e 93       	st	-X, r24
     a76:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     a78:	d3 83       	std	Z+3, r29	; 0x03
     a7a:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     a7c:	12 96       	adiw	r26, 0x02	; 2
     a7e:	2d 91       	ld	r18, X+
     a80:	3c 91       	ld	r19, X
     a82:	13 97       	sbiw	r26, 0x03	; 3
     a84:	61 e1       	ldi	r22, 0x11	; 17
     a86:	71 e0       	ldi	r23, 0x01	; 1
     a88:	01 c0       	rjmp	.+2      	; 0xa8c <pvPortMalloc+0xa4>
     a8a:	bd 01       	movw	r22, r26
     a8c:	eb 01       	movw	r28, r22
     a8e:	a8 81       	ld	r26, Y
     a90:	b9 81       	ldd	r27, Y+1	; 0x01
     a92:	12 96       	adiw	r26, 0x02	; 2
     a94:	8d 91       	ld	r24, X+
     a96:	9c 91       	ld	r25, X
     a98:	13 97       	sbiw	r26, 0x03	; 3
     a9a:	82 17       	cp	r24, r18
     a9c:	93 07       	cpc	r25, r19
     a9e:	a8 f3       	brcs	.-22     	; 0xa8a <pvPortMalloc+0xa2>
     aa0:	ea 01       	movw	r28, r20
     aa2:	b9 83       	std	Y+1, r27	; 0x01
     aa4:	a8 83       	st	Y, r26
     aa6:	db 01       	movw	r26, r22
     aa8:	4d 93       	st	X+, r20
     aaa:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     aac:	22 81       	ldd	r18, Z+2	; 0x02
     aae:	33 81       	ldd	r19, Z+3	; 0x03
     ab0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     ab4:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ab8:	82 1b       	sub	r24, r18
     aba:	93 0b       	sbc	r25, r19
     abc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ac0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ac4:	05 c0       	rjmp	.+10     	; 0xad0 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     ac6:	00 e0       	ldi	r16, 0x00	; 0
     ac8:	10 e0       	ldi	r17, 0x00	; 0
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <pvPortMalloc+0xe8>
     acc:	00 e0       	ldi	r16, 0x00	; 0
     ace:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     ad0:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     ad4:	c8 01       	movw	r24, r16
     ad6:	df 91       	pop	r29
     ad8:	cf 91       	pop	r28
     ada:	1f 91       	pop	r17
     adc:	0f 91       	pop	r16
     ade:	08 95       	ret

00000ae0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     ae8:	00 97       	sbiw	r24, 0x00	; 0
     aea:	41 f1       	breq	.+80     	; 0xb3c <vPortFree+0x5c>
     aec:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     aee:	8c 01       	movw	r16, r24
     af0:	04 50       	subi	r16, 0x04	; 4
     af2:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     af4:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     af8:	f8 01       	movw	r30, r16
     afa:	42 81       	ldd	r20, Z+2	; 0x02
     afc:	53 81       	ldd	r21, Z+3	; 0x03
     afe:	a1 e1       	ldi	r26, 0x11	; 17
     b00:	b1 e0       	ldi	r27, 0x01	; 1
     b02:	01 c0       	rjmp	.+2      	; 0xb06 <vPortFree+0x26>
     b04:	df 01       	movw	r26, r30
     b06:	ed 91       	ld	r30, X+
     b08:	fc 91       	ld	r31, X
     b0a:	11 97       	sbiw	r26, 0x01	; 1
     b0c:	22 81       	ldd	r18, Z+2	; 0x02
     b0e:	33 81       	ldd	r19, Z+3	; 0x03
     b10:	24 17       	cp	r18, r20
     b12:	35 07       	cpc	r19, r21
     b14:	b8 f3       	brcs	.-18     	; 0xb04 <vPortFree+0x24>
     b16:	24 97       	sbiw	r28, 0x04	; 4
     b18:	f9 83       	std	Y+1, r31	; 0x01
     b1a:	e8 83       	st	Y, r30
     b1c:	0d 93       	st	X+, r16
     b1e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     b20:	8a 81       	ldd	r24, Y+2	; 0x02
     b22:	9b 81       	ldd	r25, Y+3	; 0x03
     b24:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     b28:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     b2c:	82 0f       	add	r24, r18
     b2e:	93 1f       	adc	r25, r19
     b30:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     b34:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     b38:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
	}
}
     b3c:	df 91       	pop	r29
     b3e:	cf 91       	pop	r28
     b40:	1f 91       	pop	r17
     b42:	0f 91       	pop	r16
     b44:	08 95       	ret

00000b46 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     b46:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b48:	03 96       	adiw	r24, 0x03	; 3
     b4a:	92 83       	std	Z+2, r25	; 0x02
     b4c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b4e:	2f ef       	ldi	r18, 0xFF	; 255
     b50:	3f ef       	ldi	r19, 0xFF	; 255
     b52:	34 83       	std	Z+4, r19	; 0x04
     b54:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b56:	96 83       	std	Z+6, r25	; 0x06
     b58:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b5a:	90 87       	std	Z+8, r25	; 0x08
     b5c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     b5e:	10 82       	st	Z, r1
     b60:	08 95       	ret

00000b62 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     b62:	fc 01       	movw	r30, r24
     b64:	11 86       	std	Z+9, r1	; 0x09
     b66:	10 86       	std	Z+8, r1	; 0x08
     b68:	08 95       	ret

00000b6a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b6a:	cf 93       	push	r28
     b6c:	df 93       	push	r29
     b6e:	9c 01       	movw	r18, r24
     b70:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     b72:	dc 01       	movw	r26, r24
     b74:	11 96       	adiw	r26, 0x01	; 1
     b76:	cd 91       	ld	r28, X+
     b78:	dc 91       	ld	r29, X
     b7a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     b7c:	d3 83       	std	Z+3, r29	; 0x03
     b7e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     b80:	8c 81       	ldd	r24, Y+4	; 0x04
     b82:	9d 81       	ldd	r25, Y+5	; 0x05
     b84:	95 83       	std	Z+5, r25	; 0x05
     b86:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     b88:	8c 81       	ldd	r24, Y+4	; 0x04
     b8a:	9d 81       	ldd	r25, Y+5	; 0x05
     b8c:	dc 01       	movw	r26, r24
     b8e:	13 96       	adiw	r26, 0x03	; 3
     b90:	7c 93       	st	X, r23
     b92:	6e 93       	st	-X, r22
     b94:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     b96:	7d 83       	std	Y+5, r23	; 0x05
     b98:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b9a:	31 87       	std	Z+9, r19	; 0x09
     b9c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     b9e:	f9 01       	movw	r30, r18
     ba0:	80 81       	ld	r24, Z
     ba2:	8f 5f       	subi	r24, 0xFF	; 255
     ba4:	80 83       	st	Z, r24
}
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	08 95       	ret

00000bac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     bb2:	48 81       	ld	r20, Y
     bb4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     bb6:	4f 3f       	cpi	r20, 0xFF	; 255
     bb8:	2f ef       	ldi	r18, 0xFF	; 255
     bba:	52 07       	cpc	r21, r18
     bbc:	21 f4       	brne	.+8      	; 0xbc6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     bbe:	fc 01       	movw	r30, r24
     bc0:	a7 81       	ldd	r26, Z+7	; 0x07
     bc2:	b0 85       	ldd	r27, Z+8	; 0x08
     bc4:	0d c0       	rjmp	.+26     	; 0xbe0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bc6:	dc 01       	movw	r26, r24
     bc8:	13 96       	adiw	r26, 0x03	; 3
     bca:	01 c0       	rjmp	.+2      	; 0xbce <vListInsert+0x22>
     bcc:	df 01       	movw	r26, r30
     bce:	12 96       	adiw	r26, 0x02	; 2
     bd0:	ed 91       	ld	r30, X+
     bd2:	fc 91       	ld	r31, X
     bd4:	13 97       	sbiw	r26, 0x03	; 3
     bd6:	20 81       	ld	r18, Z
     bd8:	31 81       	ldd	r19, Z+1	; 0x01
     bda:	42 17       	cp	r20, r18
     bdc:	53 07       	cpc	r21, r19
     bde:	b0 f7       	brcc	.-20     	; 0xbcc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     be0:	12 96       	adiw	r26, 0x02	; 2
     be2:	ed 91       	ld	r30, X+
     be4:	fc 91       	ld	r31, X
     be6:	13 97       	sbiw	r26, 0x03	; 3
     be8:	fb 83       	std	Y+3, r31	; 0x03
     bea:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     bec:	d5 83       	std	Z+5, r29	; 0x05
     bee:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     bf0:	bd 83       	std	Y+5, r27	; 0x05
     bf2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     bf4:	13 96       	adiw	r26, 0x03	; 3
     bf6:	dc 93       	st	X, r29
     bf8:	ce 93       	st	-X, r28
     bfa:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bfc:	99 87       	std	Y+9, r25	; 0x09
     bfe:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     c00:	fc 01       	movw	r30, r24
     c02:	20 81       	ld	r18, Z
     c04:	2f 5f       	subi	r18, 0xFF	; 255
     c06:	20 83       	st	Z, r18
}
     c08:	df 91       	pop	r29
     c0a:	cf 91       	pop	r28
     c0c:	08 95       	ret

00000c0e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     c0e:	cf 93       	push	r28
     c10:	df 93       	push	r29
     c12:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     c14:	a0 85       	ldd	r26, Z+8	; 0x08
     c16:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c18:	c2 81       	ldd	r28, Z+2	; 0x02
     c1a:	d3 81       	ldd	r29, Z+3	; 0x03
     c1c:	84 81       	ldd	r24, Z+4	; 0x04
     c1e:	95 81       	ldd	r25, Z+5	; 0x05
     c20:	9d 83       	std	Y+5, r25	; 0x05
     c22:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c24:	c4 81       	ldd	r28, Z+4	; 0x04
     c26:	d5 81       	ldd	r29, Z+5	; 0x05
     c28:	82 81       	ldd	r24, Z+2	; 0x02
     c2a:	93 81       	ldd	r25, Z+3	; 0x03
     c2c:	9b 83       	std	Y+3, r25	; 0x03
     c2e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	8d 91       	ld	r24, X+
     c34:	9c 91       	ld	r25, X
     c36:	12 97       	sbiw	r26, 0x02	; 2
     c38:	e8 17       	cp	r30, r24
     c3a:	f9 07       	cpc	r31, r25
     c3c:	31 f4       	brne	.+12     	; 0xc4a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     c3e:	84 81       	ldd	r24, Z+4	; 0x04
     c40:	95 81       	ldd	r25, Z+5	; 0x05
     c42:	12 96       	adiw	r26, 0x02	; 2
     c44:	9c 93       	st	X, r25
     c46:	8e 93       	st	-X, r24
     c48:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     c4a:	11 86       	std	Z+9, r1	; 0x09
     c4c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     c4e:	8c 91       	ld	r24, X
     c50:	81 50       	subi	r24, 0x01	; 1
     c52:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	08 95       	ret

00000c5a <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c5a:	1b bc       	out	0x2b, r1	; 43
     c5c:	89 ef       	ldi	r24, 0xF9	; 249
     c5e:	8a bd       	out	0x2a, r24	; 42
     c60:	8b e0       	ldi	r24, 0x0B	; 11
     c62:	8e bd       	out	0x2e, r24	; 46
     c64:	89 b7       	in	r24, 0x39	; 57
     c66:	80 61       	ori	r24, 0x10	; 16
     c68:	89 bf       	out	0x39, r24	; 57
     c6a:	08 95       	ret

00000c6c <pxPortInitialiseStack>:
     c6c:	31 e1       	ldi	r19, 0x11	; 17
     c6e:	fc 01       	movw	r30, r24
     c70:	30 83       	st	Z, r19
     c72:	31 97       	sbiw	r30, 0x01	; 1
     c74:	22 e2       	ldi	r18, 0x22	; 34
     c76:	20 83       	st	Z, r18
     c78:	31 97       	sbiw	r30, 0x01	; 1
     c7a:	a3 e3       	ldi	r26, 0x33	; 51
     c7c:	a0 83       	st	Z, r26
     c7e:	31 97       	sbiw	r30, 0x01	; 1
     c80:	60 83       	st	Z, r22
     c82:	31 97       	sbiw	r30, 0x01	; 1
     c84:	70 83       	st	Z, r23
     c86:	31 97       	sbiw	r30, 0x01	; 1
     c88:	10 82       	st	Z, r1
     c8a:	31 97       	sbiw	r30, 0x01	; 1
     c8c:	60 e8       	ldi	r22, 0x80	; 128
     c8e:	60 83       	st	Z, r22
     c90:	31 97       	sbiw	r30, 0x01	; 1
     c92:	10 82       	st	Z, r1
     c94:	31 97       	sbiw	r30, 0x01	; 1
     c96:	62 e0       	ldi	r22, 0x02	; 2
     c98:	60 83       	st	Z, r22
     c9a:	31 97       	sbiw	r30, 0x01	; 1
     c9c:	63 e0       	ldi	r22, 0x03	; 3
     c9e:	60 83       	st	Z, r22
     ca0:	31 97       	sbiw	r30, 0x01	; 1
     ca2:	64 e0       	ldi	r22, 0x04	; 4
     ca4:	60 83       	st	Z, r22
     ca6:	31 97       	sbiw	r30, 0x01	; 1
     ca8:	65 e0       	ldi	r22, 0x05	; 5
     caa:	60 83       	st	Z, r22
     cac:	31 97       	sbiw	r30, 0x01	; 1
     cae:	66 e0       	ldi	r22, 0x06	; 6
     cb0:	60 83       	st	Z, r22
     cb2:	31 97       	sbiw	r30, 0x01	; 1
     cb4:	67 e0       	ldi	r22, 0x07	; 7
     cb6:	60 83       	st	Z, r22
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	68 e0       	ldi	r22, 0x08	; 8
     cbc:	60 83       	st	Z, r22
     cbe:	31 97       	sbiw	r30, 0x01	; 1
     cc0:	69 e0       	ldi	r22, 0x09	; 9
     cc2:	60 83       	st	Z, r22
     cc4:	31 97       	sbiw	r30, 0x01	; 1
     cc6:	60 e1       	ldi	r22, 0x10	; 16
     cc8:	60 83       	st	Z, r22
     cca:	31 97       	sbiw	r30, 0x01	; 1
     ccc:	30 83       	st	Z, r19
     cce:	31 97       	sbiw	r30, 0x01	; 1
     cd0:	32 e1       	ldi	r19, 0x12	; 18
     cd2:	30 83       	st	Z, r19
     cd4:	31 97       	sbiw	r30, 0x01	; 1
     cd6:	33 e1       	ldi	r19, 0x13	; 19
     cd8:	30 83       	st	Z, r19
     cda:	31 97       	sbiw	r30, 0x01	; 1
     cdc:	34 e1       	ldi	r19, 0x14	; 20
     cde:	30 83       	st	Z, r19
     ce0:	31 97       	sbiw	r30, 0x01	; 1
     ce2:	35 e1       	ldi	r19, 0x15	; 21
     ce4:	30 83       	st	Z, r19
     ce6:	31 97       	sbiw	r30, 0x01	; 1
     ce8:	36 e1       	ldi	r19, 0x16	; 22
     cea:	30 83       	st	Z, r19
     cec:	31 97       	sbiw	r30, 0x01	; 1
     cee:	37 e1       	ldi	r19, 0x17	; 23
     cf0:	30 83       	st	Z, r19
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	38 e1       	ldi	r19, 0x18	; 24
     cf6:	30 83       	st	Z, r19
     cf8:	31 97       	sbiw	r30, 0x01	; 1
     cfa:	39 e1       	ldi	r19, 0x19	; 25
     cfc:	30 83       	st	Z, r19
     cfe:	31 97       	sbiw	r30, 0x01	; 1
     d00:	30 e2       	ldi	r19, 0x20	; 32
     d02:	30 83       	st	Z, r19
     d04:	31 97       	sbiw	r30, 0x01	; 1
     d06:	31 e2       	ldi	r19, 0x21	; 33
     d08:	30 83       	st	Z, r19
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	20 83       	st	Z, r18
     d0e:	31 97       	sbiw	r30, 0x01	; 1
     d10:	23 e2       	ldi	r18, 0x23	; 35
     d12:	20 83       	st	Z, r18
     d14:	31 97       	sbiw	r30, 0x01	; 1
     d16:	40 83       	st	Z, r20
     d18:	31 97       	sbiw	r30, 0x01	; 1
     d1a:	50 83       	st	Z, r21
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	26 e2       	ldi	r18, 0x26	; 38
     d20:	20 83       	st	Z, r18
     d22:	31 97       	sbiw	r30, 0x01	; 1
     d24:	27 e2       	ldi	r18, 0x27	; 39
     d26:	20 83       	st	Z, r18
     d28:	31 97       	sbiw	r30, 0x01	; 1
     d2a:	28 e2       	ldi	r18, 0x28	; 40
     d2c:	20 83       	st	Z, r18
     d2e:	31 97       	sbiw	r30, 0x01	; 1
     d30:	29 e2       	ldi	r18, 0x29	; 41
     d32:	20 83       	st	Z, r18
     d34:	31 97       	sbiw	r30, 0x01	; 1
     d36:	20 e3       	ldi	r18, 0x30	; 48
     d38:	20 83       	st	Z, r18
     d3a:	31 97       	sbiw	r30, 0x01	; 1
     d3c:	21 e3       	ldi	r18, 0x31	; 49
     d3e:	20 83       	st	Z, r18
     d40:	86 97       	sbiw	r24, 0x26	; 38
     d42:	08 95       	ret

00000d44 <xPortStartScheduler>:
     d44:	0e 94 2d 06 	call	0xc5a	; 0xc5a <prvSetupTimerInterrupt>
     d48:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
     d4c:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
     d50:	cd 91       	ld	r28, X+
     d52:	cd bf       	out	0x3d, r28	; 61
     d54:	dd 91       	ld	r29, X+
     d56:	de bf       	out	0x3e, r29	; 62
     d58:	ff 91       	pop	r31
     d5a:	ef 91       	pop	r30
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	bf 91       	pop	r27
     d62:	af 91       	pop	r26
     d64:	9f 91       	pop	r25
     d66:	8f 91       	pop	r24
     d68:	7f 91       	pop	r23
     d6a:	6f 91       	pop	r22
     d6c:	5f 91       	pop	r21
     d6e:	4f 91       	pop	r20
     d70:	3f 91       	pop	r19
     d72:	2f 91       	pop	r18
     d74:	1f 91       	pop	r17
     d76:	0f 91       	pop	r16
     d78:	ff 90       	pop	r15
     d7a:	ef 90       	pop	r14
     d7c:	df 90       	pop	r13
     d7e:	cf 90       	pop	r12
     d80:	bf 90       	pop	r11
     d82:	af 90       	pop	r10
     d84:	9f 90       	pop	r9
     d86:	8f 90       	pop	r8
     d88:	7f 90       	pop	r7
     d8a:	6f 90       	pop	r6
     d8c:	5f 90       	pop	r5
     d8e:	4f 90       	pop	r4
     d90:	3f 90       	pop	r3
     d92:	2f 90       	pop	r2
     d94:	1f 90       	pop	r1
     d96:	0f 90       	pop	r0
     d98:	0f be       	out	0x3f, r0	; 63
     d9a:	0f 90       	pop	r0
     d9c:	08 95       	ret
     d9e:	81 e0       	ldi	r24, 0x01	; 1
     da0:	08 95       	ret

00000da2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     da2:	0f 92       	push	r0
     da4:	0f b6       	in	r0, 0x3f	; 63
     da6:	f8 94       	cli
     da8:	0f 92       	push	r0
     daa:	1f 92       	push	r1
     dac:	11 24       	eor	r1, r1
     dae:	2f 92       	push	r2
     db0:	3f 92       	push	r3
     db2:	4f 92       	push	r4
     db4:	5f 92       	push	r5
     db6:	6f 92       	push	r6
     db8:	7f 92       	push	r7
     dba:	8f 92       	push	r8
     dbc:	9f 92       	push	r9
     dbe:	af 92       	push	r10
     dc0:	bf 92       	push	r11
     dc2:	cf 92       	push	r12
     dc4:	df 92       	push	r13
     dc6:	ef 92       	push	r14
     dc8:	ff 92       	push	r15
     dca:	0f 93       	push	r16
     dcc:	1f 93       	push	r17
     dce:	2f 93       	push	r18
     dd0:	3f 93       	push	r19
     dd2:	4f 93       	push	r20
     dd4:	5f 93       	push	r21
     dd6:	6f 93       	push	r22
     dd8:	7f 93       	push	r23
     dda:	8f 93       	push	r24
     ddc:	9f 93       	push	r25
     dde:	af 93       	push	r26
     de0:	bf 93       	push	r27
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	ef 93       	push	r30
     de8:	ff 93       	push	r31
     dea:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
     dee:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
     df2:	0d b6       	in	r0, 0x3d	; 61
     df4:	0d 92       	st	X+, r0
     df6:	0e b6       	in	r0, 0x3e	; 62
     df8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     dfa:	0e 94 a0 0d 	call	0x1b40	; 0x1b40 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     dfe:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
     e02:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
     e06:	cd 91       	ld	r28, X+
     e08:	cd bf       	out	0x3d, r28	; 61
     e0a:	dd 91       	ld	r29, X+
     e0c:	de bf       	out	0x3e, r29	; 62
     e0e:	ff 91       	pop	r31
     e10:	ef 91       	pop	r30
     e12:	df 91       	pop	r29
     e14:	cf 91       	pop	r28
     e16:	bf 91       	pop	r27
     e18:	af 91       	pop	r26
     e1a:	9f 91       	pop	r25
     e1c:	8f 91       	pop	r24
     e1e:	7f 91       	pop	r23
     e20:	6f 91       	pop	r22
     e22:	5f 91       	pop	r21
     e24:	4f 91       	pop	r20
     e26:	3f 91       	pop	r19
     e28:	2f 91       	pop	r18
     e2a:	1f 91       	pop	r17
     e2c:	0f 91       	pop	r16
     e2e:	ff 90       	pop	r15
     e30:	ef 90       	pop	r14
     e32:	df 90       	pop	r13
     e34:	cf 90       	pop	r12
     e36:	bf 90       	pop	r11
     e38:	af 90       	pop	r10
     e3a:	9f 90       	pop	r9
     e3c:	8f 90       	pop	r8
     e3e:	7f 90       	pop	r7
     e40:	6f 90       	pop	r6
     e42:	5f 90       	pop	r5
     e44:	4f 90       	pop	r4
     e46:	3f 90       	pop	r3
     e48:	2f 90       	pop	r2
     e4a:	1f 90       	pop	r1
     e4c:	0f 90       	pop	r0
     e4e:	0f be       	out	0x3f, r0	; 63
     e50:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e52:	08 95       	ret

00000e54 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e54:	0f 92       	push	r0
     e56:	0f b6       	in	r0, 0x3f	; 63
     e58:	f8 94       	cli
     e5a:	0f 92       	push	r0
     e5c:	1f 92       	push	r1
     e5e:	11 24       	eor	r1, r1
     e60:	2f 92       	push	r2
     e62:	3f 92       	push	r3
     e64:	4f 92       	push	r4
     e66:	5f 92       	push	r5
     e68:	6f 92       	push	r6
     e6a:	7f 92       	push	r7
     e6c:	8f 92       	push	r8
     e6e:	9f 92       	push	r9
     e70:	af 92       	push	r10
     e72:	bf 92       	push	r11
     e74:	cf 92       	push	r12
     e76:	df 92       	push	r13
     e78:	ef 92       	push	r14
     e7a:	ff 92       	push	r15
     e7c:	0f 93       	push	r16
     e7e:	1f 93       	push	r17
     e80:	2f 93       	push	r18
     e82:	3f 93       	push	r19
     e84:	4f 93       	push	r20
     e86:	5f 93       	push	r21
     e88:	6f 93       	push	r22
     e8a:	7f 93       	push	r23
     e8c:	8f 93       	push	r24
     e8e:	9f 93       	push	r25
     e90:	af 93       	push	r26
     e92:	bf 93       	push	r27
     e94:	cf 93       	push	r28
     e96:	df 93       	push	r29
     e98:	ef 93       	push	r30
     e9a:	ff 93       	push	r31
     e9c:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
     ea0:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
     ea4:	0d b6       	in	r0, 0x3d	; 61
     ea6:	0d 92       	st	X+, r0
     ea8:	0e b6       	in	r0, 0x3e	; 62
     eaa:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     eac:	0e 94 2d 0c 	call	0x185a	; 0x185a <xTaskIncrementTick>
     eb0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     eb2:	0e 94 a0 0d 	call	0x1b40	; 0x1b40 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     eb6:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
     eba:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
     ebe:	cd 91       	ld	r28, X+
     ec0:	cd bf       	out	0x3d, r28	; 61
     ec2:	dd 91       	ld	r29, X+
     ec4:	de bf       	out	0x3e, r29	; 62
     ec6:	ff 91       	pop	r31
     ec8:	ef 91       	pop	r30
     eca:	df 91       	pop	r29
     ecc:	cf 91       	pop	r28
     ece:	bf 91       	pop	r27
     ed0:	af 91       	pop	r26
     ed2:	9f 91       	pop	r25
     ed4:	8f 91       	pop	r24
     ed6:	7f 91       	pop	r23
     ed8:	6f 91       	pop	r22
     eda:	5f 91       	pop	r21
     edc:	4f 91       	pop	r20
     ede:	3f 91       	pop	r19
     ee0:	2f 91       	pop	r18
     ee2:	1f 91       	pop	r17
     ee4:	0f 91       	pop	r16
     ee6:	ff 90       	pop	r15
     ee8:	ef 90       	pop	r14
     eea:	df 90       	pop	r13
     eec:	cf 90       	pop	r12
     eee:	bf 90       	pop	r11
     ef0:	af 90       	pop	r10
     ef2:	9f 90       	pop	r9
     ef4:	8f 90       	pop	r8
     ef6:	7f 90       	pop	r7
     ef8:	6f 90       	pop	r6
     efa:	5f 90       	pop	r5
     efc:	4f 90       	pop	r4
     efe:	3f 90       	pop	r3
     f00:	2f 90       	pop	r2
     f02:	1f 90       	pop	r1
     f04:	0f 90       	pop	r0
     f06:	0f be       	out	0x3f, r0	; 63
     f08:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f0a:	08 95       	ret

00000f0c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f0c:	0e 94 2a 07 	call	0xe54	; 0xe54 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f10:	18 95       	reti

00000f12 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	0f 92       	push	r0
     f18:	fc 01       	movw	r30, r24
     f1a:	82 8d       	ldd	r24, Z+26	; 0x1a
     f1c:	81 11       	cpse	r24, r1
     f1e:	02 c0       	rjmp	.+4      	; 0xf24 <prvIsQueueEmpty+0x12>
     f20:	81 e0       	ldi	r24, 0x01	; 1
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <prvIsQueueEmpty+0x14>
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	08 95       	ret

00000f2c <prvIsQueueFull>:
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	0f 92       	push	r0
     f32:	fc 01       	movw	r30, r24
     f34:	22 8d       	ldd	r18, Z+26	; 0x1a
     f36:	83 8d       	ldd	r24, Z+27	; 0x1b
     f38:	28 13       	cpse	r18, r24
     f3a:	02 c0       	rjmp	.+4      	; 0xf40 <prvIsQueueFull+0x14>
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	01 c0       	rjmp	.+2      	; 0xf42 <prvIsQueueFull+0x16>
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	0f 90       	pop	r0
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	08 95       	ret

00000f48 <prvCopyDataToQueue>:
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	ec 01       	movw	r28, r24
     f52:	04 2f       	mov	r16, r20
     f54:	1a 8d       	ldd	r17, Y+26	; 0x1a
     f56:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f58:	41 11       	cpse	r20, r1
     f5a:	0c c0       	rjmp	.+24     	; 0xf74 <prvCopyDataToQueue+0x2c>
     f5c:	88 81       	ld	r24, Y
     f5e:	99 81       	ldd	r25, Y+1	; 0x01
     f60:	89 2b       	or	r24, r25
     f62:	09 f0       	breq	.+2      	; 0xf66 <prvCopyDataToQueue+0x1e>
     f64:	42 c0       	rjmp	.+132    	; 0xfea <prvCopyDataToQueue+0xa2>
     f66:	8a 81       	ldd	r24, Y+2	; 0x02
     f68:	9b 81       	ldd	r25, Y+3	; 0x03
     f6a:	0e 94 f8 0e 	call	0x1df0	; 0x1df0 <xTaskPriorityDisinherit>
     f6e:	1b 82       	std	Y+3, r1	; 0x03
     f70:	1a 82       	std	Y+2, r1	; 0x02
     f72:	42 c0       	rjmp	.+132    	; 0xff8 <prvCopyDataToQueue+0xb0>
     f74:	01 11       	cpse	r16, r1
     f76:	17 c0       	rjmp	.+46     	; 0xfa6 <prvCopyDataToQueue+0x5e>
     f78:	50 e0       	ldi	r21, 0x00	; 0
     f7a:	8c 81       	ldd	r24, Y+4	; 0x04
     f7c:	9d 81       	ldd	r25, Y+5	; 0x05
     f7e:	0e 94 43 11 	call	0x2286	; 0x2286 <memcpy>
     f82:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f84:	8c 81       	ldd	r24, Y+4	; 0x04
     f86:	9d 81       	ldd	r25, Y+5	; 0x05
     f88:	82 0f       	add	r24, r18
     f8a:	91 1d       	adc	r25, r1
     f8c:	9d 83       	std	Y+5, r25	; 0x05
     f8e:	8c 83       	std	Y+4, r24	; 0x04
     f90:	2a 81       	ldd	r18, Y+2	; 0x02
     f92:	3b 81       	ldd	r19, Y+3	; 0x03
     f94:	82 17       	cp	r24, r18
     f96:	93 07       	cpc	r25, r19
     f98:	50 f1       	brcs	.+84     	; 0xfee <prvCopyDataToQueue+0xa6>
     f9a:	88 81       	ld	r24, Y
     f9c:	99 81       	ldd	r25, Y+1	; 0x01
     f9e:	9d 83       	std	Y+5, r25	; 0x05
     fa0:	8c 83       	std	Y+4, r24	; 0x04
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	29 c0       	rjmp	.+82     	; 0xff8 <prvCopyDataToQueue+0xb0>
     fa6:	50 e0       	ldi	r21, 0x00	; 0
     fa8:	8e 81       	ldd	r24, Y+6	; 0x06
     faa:	9f 81       	ldd	r25, Y+7	; 0x07
     fac:	0e 94 43 11 	call	0x2286	; 0x2286 <memcpy>
     fb0:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fb2:	90 e0       	ldi	r25, 0x00	; 0
     fb4:	91 95       	neg	r25
     fb6:	81 95       	neg	r24
     fb8:	91 09       	sbc	r25, r1
     fba:	2e 81       	ldd	r18, Y+6	; 0x06
     fbc:	3f 81       	ldd	r19, Y+7	; 0x07
     fbe:	28 0f       	add	r18, r24
     fc0:	39 1f       	adc	r19, r25
     fc2:	3f 83       	std	Y+7, r19	; 0x07
     fc4:	2e 83       	std	Y+6, r18	; 0x06
     fc6:	48 81       	ld	r20, Y
     fc8:	59 81       	ldd	r21, Y+1	; 0x01
     fca:	24 17       	cp	r18, r20
     fcc:	35 07       	cpc	r19, r21
     fce:	30 f4       	brcc	.+12     	; 0xfdc <prvCopyDataToQueue+0x94>
     fd0:	2a 81       	ldd	r18, Y+2	; 0x02
     fd2:	3b 81       	ldd	r19, Y+3	; 0x03
     fd4:	82 0f       	add	r24, r18
     fd6:	93 1f       	adc	r25, r19
     fd8:	9f 83       	std	Y+7, r25	; 0x07
     fda:	8e 83       	std	Y+6, r24	; 0x06
     fdc:	02 30       	cpi	r16, 0x02	; 2
     fde:	49 f4       	brne	.+18     	; 0xff2 <prvCopyDataToQueue+0xaa>
     fe0:	11 23       	and	r17, r17
     fe2:	49 f0       	breq	.+18     	; 0xff6 <prvCopyDataToQueue+0xae>
     fe4:	11 50       	subi	r17, 0x01	; 1
     fe6:	80 e0       	ldi	r24, 0x00	; 0
     fe8:	07 c0       	rjmp	.+14     	; 0xff8 <prvCopyDataToQueue+0xb0>
     fea:	80 e0       	ldi	r24, 0x00	; 0
     fec:	05 c0       	rjmp	.+10     	; 0xff8 <prvCopyDataToQueue+0xb0>
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	03 c0       	rjmp	.+6      	; 0xff8 <prvCopyDataToQueue+0xb0>
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	01 c0       	rjmp	.+2      	; 0xff8 <prvCopyDataToQueue+0xb0>
     ff6:	80 e0       	ldi	r24, 0x00	; 0
     ff8:	1f 5f       	subi	r17, 0xFF	; 255
     ffa:	1a 8f       	std	Y+26, r17	; 0x1a
     ffc:	df 91       	pop	r29
     ffe:	cf 91       	pop	r28
    1000:	1f 91       	pop	r17
    1002:	0f 91       	pop	r16
    1004:	08 95       	ret

00001006 <prvCopyDataFromQueue>:
    1006:	fc 01       	movw	r30, r24
    1008:	44 8d       	ldd	r20, Z+28	; 0x1c
    100a:	44 23       	and	r20, r20
    100c:	a9 f0       	breq	.+42     	; 0x1038 <prvCopyDataFromQueue+0x32>
    100e:	50 e0       	ldi	r21, 0x00	; 0
    1010:	26 81       	ldd	r18, Z+6	; 0x06
    1012:	37 81       	ldd	r19, Z+7	; 0x07
    1014:	24 0f       	add	r18, r20
    1016:	35 1f       	adc	r19, r21
    1018:	37 83       	std	Z+7, r19	; 0x07
    101a:	26 83       	std	Z+6, r18	; 0x06
    101c:	82 81       	ldd	r24, Z+2	; 0x02
    101e:	93 81       	ldd	r25, Z+3	; 0x03
    1020:	28 17       	cp	r18, r24
    1022:	39 07       	cpc	r19, r25
    1024:	20 f0       	brcs	.+8      	; 0x102e <prvCopyDataFromQueue+0x28>
    1026:	80 81       	ld	r24, Z
    1028:	91 81       	ldd	r25, Z+1	; 0x01
    102a:	97 83       	std	Z+7, r25	; 0x07
    102c:	86 83       	std	Z+6, r24	; 0x06
    102e:	cb 01       	movw	r24, r22
    1030:	66 81       	ldd	r22, Z+6	; 0x06
    1032:	77 81       	ldd	r23, Z+7	; 0x07
    1034:	0e 94 43 11 	call	0x2286	; 0x2286 <memcpy>
    1038:	08 95       	ret

0000103a <prvUnlockQueue>:
    103a:	1f 93       	push	r17
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	ec 01       	movw	r28, r24
    1042:	0f b6       	in	r0, 0x3f	; 63
    1044:	f8 94       	cli
    1046:	0f 92       	push	r0
    1048:	1e 8d       	ldd	r17, Y+30	; 0x1e
    104a:	0b c0       	rjmp	.+22     	; 0x1062 <prvUnlockQueue+0x28>
    104c:	89 89       	ldd	r24, Y+17	; 0x11
    104e:	88 23       	and	r24, r24
    1050:	51 f0       	breq	.+20     	; 0x1066 <prvUnlockQueue+0x2c>
    1052:	ce 01       	movw	r24, r28
    1054:	41 96       	adiw	r24, 0x11	; 17
    1056:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    105a:	81 11       	cpse	r24, r1
    105c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskMissedYield>
    1060:	11 50       	subi	r17, 0x01	; 1
    1062:	11 16       	cp	r1, r17
    1064:	9c f3       	brlt	.-26     	; 0x104c <prvUnlockQueue+0x12>
    1066:	8f ef       	ldi	r24, 0xFF	; 255
    1068:	8e 8f       	std	Y+30, r24	; 0x1e
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	0f b6       	in	r0, 0x3f	; 63
    1070:	f8 94       	cli
    1072:	0f 92       	push	r0
    1074:	1d 8d       	ldd	r17, Y+29	; 0x1d
    1076:	0b c0       	rjmp	.+22     	; 0x108e <prvUnlockQueue+0x54>
    1078:	88 85       	ldd	r24, Y+8	; 0x08
    107a:	88 23       	and	r24, r24
    107c:	51 f0       	breq	.+20     	; 0x1092 <prvUnlockQueue+0x58>
    107e:	ce 01       	movw	r24, r28
    1080:	08 96       	adiw	r24, 0x08	; 8
    1082:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    1086:	81 11       	cpse	r24, r1
    1088:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskMissedYield>
    108c:	11 50       	subi	r17, 0x01	; 1
    108e:	11 16       	cp	r1, r17
    1090:	9c f3       	brlt	.-26     	; 0x1078 <prvUnlockQueue+0x3e>
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	8d 8f       	std	Y+29, r24	; 0x1d
    1096:	0f 90       	pop	r0
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	df 91       	pop	r29
    109c:	cf 91       	pop	r28
    109e:	1f 91       	pop	r17
    10a0:	08 95       	ret

000010a2 <xQueueGenericReset>:
    10a2:	cf 93       	push	r28
    10a4:	df 93       	push	r29
    10a6:	ec 01       	movw	r28, r24
    10a8:	0f b6       	in	r0, 0x3f	; 63
    10aa:	f8 94       	cli
    10ac:	0f 92       	push	r0
    10ae:	e8 81       	ld	r30, Y
    10b0:	f9 81       	ldd	r31, Y+1	; 0x01
    10b2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	82 9f       	mul	r24, r18
    10bc:	a0 01       	movw	r20, r0
    10be:	83 9f       	mul	r24, r19
    10c0:	50 0d       	add	r21, r0
    10c2:	92 9f       	mul	r25, r18
    10c4:	50 0d       	add	r21, r0
    10c6:	11 24       	eor	r1, r1
    10c8:	4e 0f       	add	r20, r30
    10ca:	5f 1f       	adc	r21, r31
    10cc:	5b 83       	std	Y+3, r21	; 0x03
    10ce:	4a 83       	std	Y+2, r20	; 0x02
    10d0:	1a 8e       	std	Y+26, r1	; 0x1a
    10d2:	fd 83       	std	Y+5, r31	; 0x05
    10d4:	ec 83       	std	Y+4, r30	; 0x04
    10d6:	01 97       	sbiw	r24, 0x01	; 1
    10d8:	28 9f       	mul	r18, r24
    10da:	a0 01       	movw	r20, r0
    10dc:	29 9f       	mul	r18, r25
    10de:	50 0d       	add	r21, r0
    10e0:	38 9f       	mul	r19, r24
    10e2:	50 0d       	add	r21, r0
    10e4:	11 24       	eor	r1, r1
    10e6:	cf 01       	movw	r24, r30
    10e8:	84 0f       	add	r24, r20
    10ea:	95 1f       	adc	r25, r21
    10ec:	9f 83       	std	Y+7, r25	; 0x07
    10ee:	8e 83       	std	Y+6, r24	; 0x06
    10f0:	8f ef       	ldi	r24, 0xFF	; 255
    10f2:	8d 8f       	std	Y+29, r24	; 0x1d
    10f4:	8e 8f       	std	Y+30, r24	; 0x1e
    10f6:	61 11       	cpse	r22, r1
    10f8:	0c c0       	rjmp	.+24     	; 0x1112 <xQueueGenericReset+0x70>
    10fa:	88 85       	ldd	r24, Y+8	; 0x08
    10fc:	88 23       	and	r24, r24
    10fe:	89 f0       	breq	.+34     	; 0x1122 <xQueueGenericReset+0x80>
    1100:	ce 01       	movw	r24, r28
    1102:	08 96       	adiw	r24, 0x08	; 8
    1104:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    1108:	88 23       	and	r24, r24
    110a:	59 f0       	breq	.+22     	; 0x1122 <xQueueGenericReset+0x80>
    110c:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1110:	08 c0       	rjmp	.+16     	; 0x1122 <xQueueGenericReset+0x80>
    1112:	ce 01       	movw	r24, r28
    1114:	08 96       	adiw	r24, 0x08	; 8
    1116:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    111a:	ce 01       	movw	r24, r28
    111c:	41 96       	adiw	r24, 0x11	; 17
    111e:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    1122:	0f 90       	pop	r0
    1124:	0f be       	out	0x3f, r0	; 63
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	08 95       	ret

0000112e <prvInitialiseNewQueue>:
    112e:	0f 93       	push	r16
    1130:	1f 93       	push	r17
    1132:	f8 01       	movw	r30, r16
    1134:	61 11       	cpse	r22, r1
    1136:	03 c0       	rjmp	.+6      	; 0x113e <prvInitialiseNewQueue+0x10>
    1138:	11 83       	std	Z+1, r17	; 0x01
    113a:	00 83       	st	Z, r16
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <prvInitialiseNewQueue+0x14>
    113e:	51 83       	std	Z+1, r21	; 0x01
    1140:	40 83       	st	Z, r20
    1142:	83 8f       	std	Z+27, r24	; 0x1b
    1144:	64 8f       	std	Z+28, r22	; 0x1c
    1146:	61 e0       	ldi	r22, 0x01	; 1
    1148:	cf 01       	movw	r24, r30
    114a:	0e 94 51 08 	call	0x10a2	; 0x10a2 <xQueueGenericReset>
    114e:	1f 91       	pop	r17
    1150:	0f 91       	pop	r16
    1152:	08 95       	ret

00001154 <xQueueGenericCreate>:
    1154:	df 92       	push	r13
    1156:	ef 92       	push	r14
    1158:	ff 92       	push	r15
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	e8 2e       	mov	r14, r24
    1164:	f6 2e       	mov	r15, r22
    1166:	d4 2e       	mov	r13, r20
    1168:	66 23       	and	r22, r22
    116a:	21 f0       	breq	.+8      	; 0x1174 <xQueueGenericCreate+0x20>
    116c:	86 9f       	mul	r24, r22
    116e:	c0 01       	movw	r24, r0
    1170:	11 24       	eor	r1, r1
    1172:	02 c0       	rjmp	.+4      	; 0x1178 <xQueueGenericCreate+0x24>
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	90 e0       	ldi	r25, 0x00	; 0
    1178:	4f 96       	adiw	r24, 0x1f	; 31
    117a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <pvPortMalloc>
    117e:	ec 01       	movw	r28, r24
    1180:	00 97       	sbiw	r24, 0x00	; 0
    1182:	49 f0       	breq	.+18     	; 0x1196 <xQueueGenericCreate+0x42>
    1184:	8c 01       	movw	r16, r24
    1186:	2d 2d       	mov	r18, r13
    1188:	ac 01       	movw	r20, r24
    118a:	41 5e       	subi	r20, 0xE1	; 225
    118c:	5f 4f       	sbci	r21, 0xFF	; 255
    118e:	6f 2d       	mov	r22, r15
    1190:	8e 2d       	mov	r24, r14
    1192:	0e 94 97 08 	call	0x112e	; 0x112e <prvInitialiseNewQueue>
    1196:	ce 01       	movw	r24, r28
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	1f 91       	pop	r17
    119e:	0f 91       	pop	r16
    11a0:	ff 90       	pop	r15
    11a2:	ef 90       	pop	r14
    11a4:	df 90       	pop	r13
    11a6:	08 95       	ret

000011a8 <xQueueGenericSend>:
    11a8:	cf 92       	push	r12
    11aa:	df 92       	push	r13
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	0f 93       	push	r16
    11b2:	1f 93       	push	r17
    11b4:	cf 93       	push	r28
    11b6:	df 93       	push	r29
    11b8:	00 d0       	rcall	.+0      	; 0x11ba <xQueueGenericSend+0x12>
    11ba:	00 d0       	rcall	.+0      	; 0x11bc <xQueueGenericSend+0x14>
    11bc:	1f 92       	push	r1
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
    11c2:	8c 01       	movw	r16, r24
    11c4:	7b 01       	movw	r14, r22
    11c6:	5d 83       	std	Y+5, r21	; 0x05
    11c8:	4c 83       	std	Y+4, r20	; 0x04
    11ca:	c2 2e       	mov	r12, r18
    11cc:	d1 2c       	mov	r13, r1
    11ce:	0f b6       	in	r0, 0x3f	; 63
    11d0:	f8 94       	cli
    11d2:	0f 92       	push	r0
    11d4:	f8 01       	movw	r30, r16
    11d6:	92 8d       	ldd	r25, Z+26	; 0x1a
    11d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    11da:	98 17       	cp	r25, r24
    11dc:	18 f0       	brcs	.+6      	; 0x11e4 <xQueueGenericSend+0x3c>
    11de:	f2 e0       	ldi	r31, 0x02	; 2
    11e0:	cf 12       	cpse	r12, r31
    11e2:	19 c0       	rjmp	.+50     	; 0x1216 <xQueueGenericSend+0x6e>
    11e4:	4c 2d       	mov	r20, r12
    11e6:	b7 01       	movw	r22, r14
    11e8:	c8 01       	movw	r24, r16
    11ea:	0e 94 a4 07 	call	0xf48	; 0xf48 <prvCopyDataToQueue>
    11ee:	f8 01       	movw	r30, r16
    11f0:	91 89       	ldd	r25, Z+17	; 0x11
    11f2:	99 23       	and	r25, r25
    11f4:	49 f0       	breq	.+18     	; 0x1208 <xQueueGenericSend+0x60>
    11f6:	c8 01       	movw	r24, r16
    11f8:	41 96       	adiw	r24, 0x11	; 17
    11fa:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    11fe:	88 23       	and	r24, r24
    1200:	31 f0       	breq	.+12     	; 0x120e <xQueueGenericSend+0x66>
    1202:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1206:	03 c0       	rjmp	.+6      	; 0x120e <xQueueGenericSend+0x66>
    1208:	81 11       	cpse	r24, r1
    120a:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    120e:	0f 90       	pop	r0
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	81 e0       	ldi	r24, 0x01	; 1
    1214:	4d c0       	rjmp	.+154    	; 0x12b0 <xQueueGenericSend+0x108>
    1216:	8c 81       	ldd	r24, Y+4	; 0x04
    1218:	9d 81       	ldd	r25, Y+5	; 0x05
    121a:	89 2b       	or	r24, r25
    121c:	21 f4       	brne	.+8      	; 0x1226 <xQueueGenericSend+0x7e>
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	80 e0       	ldi	r24, 0x00	; 0
    1224:	45 c0       	rjmp	.+138    	; 0x12b0 <xQueueGenericSend+0x108>
    1226:	d1 10       	cpse	r13, r1
    1228:	06 c0       	rjmp	.+12     	; 0x1236 <xQueueGenericSend+0x8e>
    122a:	ce 01       	movw	r24, r28
    122c:	01 96       	adiw	r24, 0x01	; 1
    122e:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskSetTimeOutState>
    1232:	dd 24       	eor	r13, r13
    1234:	d3 94       	inc	r13
    1236:	0f 90       	pop	r0
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	0f 92       	push	r0
    1244:	f8 01       	movw	r30, r16
    1246:	85 8d       	ldd	r24, Z+29	; 0x1d
    1248:	8f 3f       	cpi	r24, 0xFF	; 255
    124a:	09 f4       	brne	.+2      	; 0x124e <xQueueGenericSend+0xa6>
    124c:	15 8e       	std	Z+29, r1	; 0x1d
    124e:	f8 01       	movw	r30, r16
    1250:	86 8d       	ldd	r24, Z+30	; 0x1e
    1252:	8f 3f       	cpi	r24, 0xFF	; 255
    1254:	09 f4       	brne	.+2      	; 0x1258 <xQueueGenericSend+0xb0>
    1256:	16 8e       	std	Z+30, r1	; 0x1e
    1258:	0f 90       	pop	r0
    125a:	0f be       	out	0x3f, r0	; 63
    125c:	be 01       	movw	r22, r28
    125e:	6c 5f       	subi	r22, 0xFC	; 252
    1260:	7f 4f       	sbci	r23, 0xFF	; 255
    1262:	ce 01       	movw	r24, r28
    1264:	01 96       	adiw	r24, 0x01	; 1
    1266:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <xTaskCheckForTimeOut>
    126a:	81 11       	cpse	r24, r1
    126c:	1b c0       	rjmp	.+54     	; 0x12a4 <xQueueGenericSend+0xfc>
    126e:	c8 01       	movw	r24, r16
    1270:	0e 94 96 07 	call	0xf2c	; 0xf2c <prvIsQueueFull>
    1274:	88 23       	and	r24, r24
    1276:	81 f0       	breq	.+32     	; 0x1298 <xQueueGenericSend+0xf0>
    1278:	6c 81       	ldd	r22, Y+4	; 0x04
    127a:	7d 81       	ldd	r23, Y+5	; 0x05
    127c:	c8 01       	movw	r24, r16
    127e:	08 96       	adiw	r24, 0x08	; 8
    1280:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskPlaceOnEventList>
    1284:	c8 01       	movw	r24, r16
    1286:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
    128a:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    128e:	81 11       	cpse	r24, r1
    1290:	9e cf       	rjmp	.-196    	; 0x11ce <xQueueGenericSend+0x26>
    1292:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1296:	9b cf       	rjmp	.-202    	; 0x11ce <xQueueGenericSend+0x26>
    1298:	c8 01       	movw	r24, r16
    129a:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
    129e:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    12a2:	95 cf       	rjmp	.-214    	; 0x11ce <xQueueGenericSend+0x26>
    12a4:	c8 01       	movw	r24, r16
    12a6:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
    12aa:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    12ae:	80 e0       	ldi	r24, 0x00	; 0
    12b0:	0f 90       	pop	r0
    12b2:	0f 90       	pop	r0
    12b4:	0f 90       	pop	r0
    12b6:	0f 90       	pop	r0
    12b8:	0f 90       	pop	r0
    12ba:	df 91       	pop	r29
    12bc:	cf 91       	pop	r28
    12be:	1f 91       	pop	r17
    12c0:	0f 91       	pop	r16
    12c2:	ff 90       	pop	r15
    12c4:	ef 90       	pop	r14
    12c6:	df 90       	pop	r13
    12c8:	cf 90       	pop	r12
    12ca:	08 95       	ret

000012cc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    12cc:	8f 92       	push	r8
    12ce:	9f 92       	push	r9
    12d0:	bf 92       	push	r11
    12d2:	cf 92       	push	r12
    12d4:	df 92       	push	r13
    12d6:	ef 92       	push	r14
    12d8:	ff 92       	push	r15
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	00 d0       	rcall	.+0      	; 0x12e4 <xQueueGenericReceive+0x18>
    12e4:	00 d0       	rcall	.+0      	; 0x12e6 <xQueueGenericReceive+0x1a>
    12e6:	1f 92       	push	r1
    12e8:	cd b7       	in	r28, 0x3d	; 61
    12ea:	de b7       	in	r29, 0x3e	; 62
    12ec:	8c 01       	movw	r16, r24
    12ee:	6b 01       	movw	r12, r22
    12f0:	5d 83       	std	Y+5, r21	; 0x05
    12f2:	4c 83       	std	Y+4, r20	; 0x04
    12f4:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    12f6:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12f8:	0f b6       	in	r0, 0x3f	; 63
    12fa:	f8 94       	cli
    12fc:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    12fe:	f8 01       	movw	r30, r16
    1300:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1302:	ff 20       	and	r15, r15
    1304:	91 f1       	breq	.+100    	; 0x136a <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1306:	86 80       	ldd	r8, Z+6	; 0x06
    1308:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    130a:	b6 01       	movw	r22, r12
    130c:	c8 01       	movw	r24, r16
    130e:	0e 94 03 08 	call	0x1006	; 0x1006 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1312:	b1 10       	cpse	r11, r1
    1314:	19 c0       	rjmp	.+50     	; 0x1348 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1316:	fa 94       	dec	r15
    1318:	f8 01       	movw	r30, r16
    131a:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    131c:	80 81       	ld	r24, Z
    131e:	91 81       	ldd	r25, Z+1	; 0x01
    1320:	89 2b       	or	r24, r25
    1322:	29 f4       	brne	.+10     	; 0x132e <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1324:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <pvTaskIncrementMutexHeldCount>
    1328:	f8 01       	movw	r30, r16
    132a:	93 83       	std	Z+3, r25	; 0x03
    132c:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    132e:	f8 01       	movw	r30, r16
    1330:	80 85       	ldd	r24, Z+8	; 0x08
    1332:	88 23       	and	r24, r24
    1334:	b1 f0       	breq	.+44     	; 0x1362 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1336:	c8 01       	movw	r24, r16
    1338:	08 96       	adiw	r24, 0x08	; 8
    133a:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    133e:	88 23       	and	r24, r24
    1340:	81 f0       	breq	.+32     	; 0x1362 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1342:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1346:	0d c0       	rjmp	.+26     	; 0x1362 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1348:	f8 01       	movw	r30, r16
    134a:	97 82       	std	Z+7, r9	; 0x07
    134c:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    134e:	81 89       	ldd	r24, Z+17	; 0x11
    1350:	88 23       	and	r24, r24
    1352:	39 f0       	breq	.+14     	; 0x1362 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1354:	c8 01       	movw	r24, r16
    1356:	41 96       	adiw	r24, 0x11	; 17
    1358:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xTaskRemoveFromEventList>
    135c:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    135e:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1366:	81 e0       	ldi	r24, 0x01	; 1
    1368:	61 c0       	rjmp	.+194    	; 0x142c <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    136a:	8c 81       	ldd	r24, Y+4	; 0x04
    136c:	9d 81       	ldd	r25, Y+5	; 0x05
    136e:	89 2b       	or	r24, r25
    1370:	21 f4       	brne	.+8      	; 0x137a <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1372:	0f 90       	pop	r0
    1374:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1376:	80 e0       	ldi	r24, 0x00	; 0
    1378:	59 c0       	rjmp	.+178    	; 0x142c <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    137a:	e1 10       	cpse	r14, r1
    137c:	06 c0       	rjmp	.+12     	; 0x138a <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    137e:	ce 01       	movw	r24, r28
    1380:	01 96       	adiw	r24, 0x01	; 1
    1382:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1386:	ee 24       	eor	r14, r14
    1388:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    138a:	0f 90       	pop	r0
    138c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    138e:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	f8 94       	cli
    1396:	0f 92       	push	r0
    1398:	f8 01       	movw	r30, r16
    139a:	85 8d       	ldd	r24, Z+29	; 0x1d
    139c:	8f 3f       	cpi	r24, 0xFF	; 255
    139e:	09 f4       	brne	.+2      	; 0x13a2 <xQueueGenericReceive+0xd6>
    13a0:	15 8e       	std	Z+29, r1	; 0x1d
    13a2:	f8 01       	movw	r30, r16
    13a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13a6:	8f 3f       	cpi	r24, 0xFF	; 255
    13a8:	09 f4       	brne	.+2      	; 0x13ac <xQueueGenericReceive+0xe0>
    13aa:	16 8e       	std	Z+30, r1	; 0x1e
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13b0:	be 01       	movw	r22, r28
    13b2:	6c 5f       	subi	r22, 0xFC	; 252
    13b4:	7f 4f       	sbci	r23, 0xFF	; 255
    13b6:	ce 01       	movw	r24, r28
    13b8:	01 96       	adiw	r24, 0x01	; 1
    13ba:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <xTaskCheckForTimeOut>
    13be:	81 11       	cpse	r24, r1
    13c0:	29 c0       	rjmp	.+82     	; 0x1414 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    13c2:	c8 01       	movw	r24, r16
    13c4:	0e 94 89 07 	call	0xf12	; 0xf12 <prvIsQueueEmpty>
    13c8:	88 23       	and	r24, r24
    13ca:	f1 f0       	breq	.+60     	; 0x1408 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13cc:	f8 01       	movw	r30, r16
    13ce:	80 81       	ld	r24, Z
    13d0:	91 81       	ldd	r25, Z+1	; 0x01
    13d2:	89 2b       	or	r24, r25
    13d4:	49 f4       	brne	.+18     	; 0x13e8 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    13dc:	82 81       	ldd	r24, Z+2	; 0x02
    13de:	93 81       	ldd	r25, Z+3	; 0x03
    13e0:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    13e4:	0f 90       	pop	r0
    13e6:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13e8:	6c 81       	ldd	r22, Y+4	; 0x04
    13ea:	7d 81       	ldd	r23, Y+5	; 0x05
    13ec:	c8 01       	movw	r24, r16
    13ee:	41 96       	adiw	r24, 0x11	; 17
    13f0:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    13f4:	c8 01       	movw	r24, r16
    13f6:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    13fa:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    13fe:	81 11       	cpse	r24, r1
    1400:	7b cf       	rjmp	.-266    	; 0x12f8 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1402:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1406:	78 cf       	rjmp	.-272    	; 0x12f8 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1408:	c8 01       	movw	r24, r16
    140a:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    140e:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    1412:	72 cf       	rjmp	.-284    	; 0x12f8 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1414:	c8 01       	movw	r24, r16
    1416:	0e 94 1d 08 	call	0x103a	; 0x103a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    141a:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    141e:	c8 01       	movw	r24, r16
    1420:	0e 94 89 07 	call	0xf12	; 0xf12 <prvIsQueueEmpty>
    1424:	88 23       	and	r24, r24
    1426:	09 f4       	brne	.+2      	; 0x142a <xQueueGenericReceive+0x15e>
    1428:	67 cf       	rjmp	.-306    	; 0x12f8 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    142a:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    142c:	0f 90       	pop	r0
    142e:	0f 90       	pop	r0
    1430:	0f 90       	pop	r0
    1432:	0f 90       	pop	r0
    1434:	0f 90       	pop	r0
    1436:	df 91       	pop	r29
    1438:	cf 91       	pop	r28
    143a:	1f 91       	pop	r17
    143c:	0f 91       	pop	r16
    143e:	ff 90       	pop	r15
    1440:	ef 90       	pop	r14
    1442:	df 90       	pop	r13
    1444:	cf 90       	pop	r12
    1446:	bf 90       	pop	r11
    1448:	9f 90       	pop	r9
    144a:	8f 90       	pop	r8
    144c:	08 95       	ret

0000144e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    144e:	e0 91 29 05 	lds	r30, 0x0529	; 0x800529 <pxDelayedTaskList>
    1452:	f0 91 2a 05 	lds	r31, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    1456:	80 81       	ld	r24, Z
    1458:	81 11       	cpse	r24, r1
    145a:	07 c0       	rjmp	.+14     	; 0x146a <prvResetNextTaskUnblockTime+0x1c>
    145c:	8f ef       	ldi	r24, 0xFF	; 255
    145e:	9f ef       	ldi	r25, 0xFF	; 255
    1460:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <xNextTaskUnblockTime+0x1>
    1464:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <xNextTaskUnblockTime>
    1468:	08 95       	ret
    146a:	e0 91 29 05 	lds	r30, 0x0529	; 0x800529 <pxDelayedTaskList>
    146e:	f0 91 2a 05 	lds	r31, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    1472:	05 80       	ldd	r0, Z+5	; 0x05
    1474:	f6 81       	ldd	r31, Z+6	; 0x06
    1476:	e0 2d       	mov	r30, r0
    1478:	06 80       	ldd	r0, Z+6	; 0x06
    147a:	f7 81       	ldd	r31, Z+7	; 0x07
    147c:	e0 2d       	mov	r30, r0
    147e:	82 81       	ldd	r24, Z+2	; 0x02
    1480:	93 81       	ldd	r25, Z+3	; 0x03
    1482:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <xNextTaskUnblockTime+0x1>
    1486:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <xNextTaskUnblockTime>
    148a:	08 95       	ret

0000148c <prvDeleteTCB>:
    148c:	cf 93       	push	r28
    148e:	df 93       	push	r29
    1490:	ec 01       	movw	r28, r24
    1492:	8f 89       	ldd	r24, Y+23	; 0x17
    1494:	98 8d       	ldd	r25, Y+24	; 0x18
    1496:	0e 94 70 05 	call	0xae0	; 0xae0 <vPortFree>
    149a:	ce 01       	movw	r24, r28
    149c:	0e 94 70 05 	call	0xae0	; 0xae0 <vPortFree>
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <prvInitialiseNewTask>:
    14a6:	6f 92       	push	r6
    14a8:	7f 92       	push	r7
    14aa:	8f 92       	push	r8
    14ac:	9f 92       	push	r9
    14ae:	af 92       	push	r10
    14b0:	bf 92       	push	r11
    14b2:	cf 92       	push	r12
    14b4:	df 92       	push	r13
    14b6:	ef 92       	push	r14
    14b8:	0f 93       	push	r16
    14ba:	1f 93       	push	r17
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	cd b7       	in	r28, 0x3d	; 61
    14c2:	de b7       	in	r29, 0x3e	; 62
    14c4:	4c 01       	movw	r8, r24
    14c6:	f5 01       	movw	r30, r10
    14c8:	87 89       	ldd	r24, Z+23	; 0x17
    14ca:	90 8d       	ldd	r25, Z+24	; 0x18
    14cc:	21 50       	subi	r18, 0x01	; 1
    14ce:	31 09       	sbc	r19, r1
    14d0:	3c 01       	movw	r6, r24
    14d2:	62 0e       	add	r6, r18
    14d4:	73 1e       	adc	r7, r19
    14d6:	20 e0       	ldi	r18, 0x00	; 0
    14d8:	0f c0       	rjmp	.+30     	; 0x14f8 <prvInitialiseNewTask+0x52>
    14da:	82 2f       	mov	r24, r18
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	fb 01       	movw	r30, r22
    14e0:	e8 0f       	add	r30, r24
    14e2:	f9 1f       	adc	r31, r25
    14e4:	30 81       	ld	r19, Z
    14e6:	d5 01       	movw	r26, r10
    14e8:	a8 0f       	add	r26, r24
    14ea:	b9 1f       	adc	r27, r25
    14ec:	59 96       	adiw	r26, 0x19	; 25
    14ee:	3c 93       	st	X, r19
    14f0:	80 81       	ld	r24, Z
    14f2:	88 23       	and	r24, r24
    14f4:	19 f0       	breq	.+6      	; 0x14fc <prvInitialiseNewTask+0x56>
    14f6:	2f 5f       	subi	r18, 0xFF	; 255
    14f8:	28 30       	cpi	r18, 0x08	; 8
    14fa:	78 f3       	brcs	.-34     	; 0x14da <prvInitialiseNewTask+0x34>
    14fc:	f5 01       	movw	r30, r10
    14fe:	10 a2       	std	Z+32, r1	; 0x20
    1500:	f2 e0       	ldi	r31, 0x02	; 2
    1502:	fe 15       	cp	r31, r14
    1504:	18 f4       	brcc	.+6      	; 0x150c <prvInitialiseNewTask+0x66>
    1506:	68 94       	set
    1508:	ee 24       	eor	r14, r14
    150a:	e1 f8       	bld	r14, 1
    150c:	f5 01       	movw	r30, r10
    150e:	e6 8a       	std	Z+22, r14	; 0x16
    1510:	e1 a2       	std	Z+33, r14	; 0x21
    1512:	12 a2       	std	Z+34, r1	; 0x22
    1514:	c5 01       	movw	r24, r10
    1516:	02 96       	adiw	r24, 0x02	; 2
    1518:	0e 94 b1 05 	call	0xb62	; 0xb62 <vListInitialiseItem>
    151c:	c5 01       	movw	r24, r10
    151e:	0c 96       	adiw	r24, 0x0c	; 12
    1520:	0e 94 b1 05 	call	0xb62	; 0xb62 <vListInitialiseItem>
    1524:	f5 01       	movw	r30, r10
    1526:	b1 86       	std	Z+9, r11	; 0x09
    1528:	a0 86       	std	Z+8, r10	; 0x08
    152a:	83 e0       	ldi	r24, 0x03	; 3
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	8e 19       	sub	r24, r14
    1530:	91 09       	sbc	r25, r1
    1532:	95 87       	std	Z+13, r25	; 0x0d
    1534:	84 87       	std	Z+12, r24	; 0x0c
    1536:	b3 8a       	std	Z+19, r11	; 0x13
    1538:	a2 8a       	std	Z+18, r10	; 0x12
    153a:	13 a2       	std	Z+35, r1	; 0x23
    153c:	14 a2       	std	Z+36, r1	; 0x24
    153e:	15 a2       	std	Z+37, r1	; 0x25
    1540:	16 a2       	std	Z+38, r1	; 0x26
    1542:	17 a2       	std	Z+39, r1	; 0x27
    1544:	a8 01       	movw	r20, r16
    1546:	b4 01       	movw	r22, r8
    1548:	c3 01       	movw	r24, r6
    154a:	0e 94 36 06 	call	0xc6c	; 0xc6c <pxPortInitialiseStack>
    154e:	f5 01       	movw	r30, r10
    1550:	91 83       	std	Z+1, r25	; 0x01
    1552:	80 83       	st	Z, r24
    1554:	c1 14       	cp	r12, r1
    1556:	d1 04       	cpc	r13, r1
    1558:	19 f0       	breq	.+6      	; 0x1560 <prvInitialiseNewTask+0xba>
    155a:	f6 01       	movw	r30, r12
    155c:	b1 82       	std	Z+1, r11	; 0x01
    155e:	a0 82       	st	Z, r10
    1560:	df 91       	pop	r29
    1562:	cf 91       	pop	r28
    1564:	1f 91       	pop	r17
    1566:	0f 91       	pop	r16
    1568:	ef 90       	pop	r14
    156a:	df 90       	pop	r13
    156c:	cf 90       	pop	r12
    156e:	bf 90       	pop	r11
    1570:	af 90       	pop	r10
    1572:	9f 90       	pop	r9
    1574:	8f 90       	pop	r8
    1576:	7f 90       	pop	r7
    1578:	6f 90       	pop	r6
    157a:	08 95       	ret

0000157c <prvInitialiseTaskLists>:
    157c:	cf 93       	push	r28
    157e:	c0 e0       	ldi	r28, 0x00	; 0
    1580:	10 c0       	rjmp	.+32     	; 0x15a2 <prvInitialiseTaskLists+0x26>
    1582:	8c 2f       	mov	r24, r28
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	9c 01       	movw	r18, r24
    1588:	22 0f       	add	r18, r18
    158a:	33 1f       	adc	r19, r19
    158c:	22 0f       	add	r18, r18
    158e:	33 1f       	adc	r19, r19
    1590:	22 0f       	add	r18, r18
    1592:	33 1f       	adc	r19, r19
    1594:	82 0f       	add	r24, r18
    1596:	93 1f       	adc	r25, r19
    1598:	83 5c       	subi	r24, 0xC3	; 195
    159a:	9a 4f       	sbci	r25, 0xFA	; 250
    159c:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15a0:	cf 5f       	subi	r28, 0xFF	; 255
    15a2:	c3 30       	cpi	r28, 0x03	; 3
    15a4:	70 f3       	brcs	.-36     	; 0x1582 <prvInitialiseTaskLists+0x6>
    15a6:	84 e3       	ldi	r24, 0x34	; 52
    15a8:	95 e0       	ldi	r25, 0x05	; 5
    15aa:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15ae:	8b e2       	ldi	r24, 0x2B	; 43
    15b0:	95 e0       	ldi	r25, 0x05	; 5
    15b2:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15b6:	8e e1       	ldi	r24, 0x1E	; 30
    15b8:	95 e0       	ldi	r25, 0x05	; 5
    15ba:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15be:	85 e1       	ldi	r24, 0x15	; 21
    15c0:	95 e0       	ldi	r25, 0x05	; 5
    15c2:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15c6:	8b e0       	ldi	r24, 0x0B	; 11
    15c8:	95 e0       	ldi	r25, 0x05	; 5
    15ca:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInitialise>
    15ce:	84 e3       	ldi	r24, 0x34	; 52
    15d0:	95 e0       	ldi	r25, 0x05	; 5
    15d2:	90 93 2a 05 	sts	0x052A, r25	; 0x80052a <pxDelayedTaskList+0x1>
    15d6:	80 93 29 05 	sts	0x0529, r24	; 0x800529 <pxDelayedTaskList>
    15da:	8b e2       	ldi	r24, 0x2B	; 43
    15dc:	95 e0       	ldi	r25, 0x05	; 5
    15de:	90 93 28 05 	sts	0x0528, r25	; 0x800528 <pxOverflowDelayedTaskList+0x1>
    15e2:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <pxOverflowDelayedTaskList>
    15e6:	cf 91       	pop	r28
    15e8:	08 95       	ret

000015ea <prvAddNewTaskToReadyList>:
    15ea:	cf 93       	push	r28
    15ec:	df 93       	push	r29
    15ee:	ec 01       	movw	r28, r24
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
    15f6:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxCurrentNumberOfTasks>
    15fa:	8f 5f       	subi	r24, 0xFF	; 255
    15fc:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <uxCurrentNumberOfTasks>
    1600:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <pxCurrentTCB>
    1604:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1608:	89 2b       	or	r24, r25
    160a:	59 f4       	brne	.+22     	; 0x1622 <prvAddNewTaskToReadyList+0x38>
    160c:	d0 93 59 05 	sts	0x0559, r29	; 0x800559 <pxCurrentTCB+0x1>
    1610:	c0 93 58 05 	sts	0x0558, r28	; 0x800558 <pxCurrentTCB>
    1614:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxCurrentNumberOfTasks>
    1618:	81 30       	cpi	r24, 0x01	; 1
    161a:	99 f4       	brne	.+38     	; 0x1642 <prvAddNewTaskToReadyList+0x58>
    161c:	0e 94 be 0a 	call	0x157c	; 0x157c <prvInitialiseTaskLists>
    1620:	10 c0       	rjmp	.+32     	; 0x1642 <prvAddNewTaskToReadyList+0x58>
    1622:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xSchedulerRunning>
    1626:	81 11       	cpse	r24, r1
    1628:	0c c0       	rjmp	.+24     	; 0x1642 <prvAddNewTaskToReadyList+0x58>
    162a:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    162e:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1632:	96 89       	ldd	r25, Z+22	; 0x16
    1634:	8e 89       	ldd	r24, Y+22	; 0x16
    1636:	89 17       	cp	r24, r25
    1638:	20 f0       	brcs	.+8      	; 0x1642 <prvAddNewTaskToReadyList+0x58>
    163a:	d0 93 59 05 	sts	0x0559, r29	; 0x800559 <pxCurrentTCB+0x1>
    163e:	c0 93 58 05 	sts	0x0558, r28	; 0x800558 <pxCurrentTCB>
    1642:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTaskNumber>
    1646:	8f 5f       	subi	r24, 0xFF	; 255
    1648:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <uxTaskNumber>
    164c:	8e 89       	ldd	r24, Y+22	; 0x16
    164e:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1652:	98 17       	cp	r25, r24
    1654:	10 f4       	brcc	.+4      	; 0x165a <prvAddNewTaskToReadyList+0x70>
    1656:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	9c 01       	movw	r18, r24
    165e:	22 0f       	add	r18, r18
    1660:	33 1f       	adc	r19, r19
    1662:	22 0f       	add	r18, r18
    1664:	33 1f       	adc	r19, r19
    1666:	22 0f       	add	r18, r18
    1668:	33 1f       	adc	r19, r19
    166a:	82 0f       	add	r24, r18
    166c:	93 1f       	adc	r25, r19
    166e:	be 01       	movw	r22, r28
    1670:	6e 5f       	subi	r22, 0xFE	; 254
    1672:	7f 4f       	sbci	r23, 0xFF	; 255
    1674:	83 5c       	subi	r24, 0xC3	; 195
    1676:	9a 4f       	sbci	r25, 0xFA	; 250
    1678:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
    1680:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xSchedulerRunning>
    1684:	88 23       	and	r24, r24
    1686:	51 f0       	breq	.+20     	; 0x169c <prvAddNewTaskToReadyList+0xb2>
    1688:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    168c:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1690:	96 89       	ldd	r25, Z+22	; 0x16
    1692:	8e 89       	ldd	r24, Y+22	; 0x16
    1694:	98 17       	cp	r25, r24
    1696:	10 f4       	brcc	.+4      	; 0x169c <prvAddNewTaskToReadyList+0xb2>
    1698:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	08 95       	ret

000016a2 <prvAddCurrentTaskToDelayedList>:
    16a2:	ff 92       	push	r15
    16a4:	0f 93       	push	r16
    16a6:	1f 93       	push	r17
    16a8:	cf 93       	push	r28
    16aa:	df 93       	push	r29
    16ac:	ec 01       	movw	r28, r24
    16ae:	f6 2e       	mov	r15, r22
    16b0:	00 91 08 05 	lds	r16, 0x0508	; 0x800508 <xTickCount>
    16b4:	10 91 09 05 	lds	r17, 0x0509	; 0x800509 <xTickCount+0x1>
    16b8:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <pxCurrentTCB>
    16bc:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    16c0:	02 96       	adiw	r24, 0x02	; 2
    16c2:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    16c6:	cf 3f       	cpi	r28, 0xFF	; 255
    16c8:	8f ef       	ldi	r24, 0xFF	; 255
    16ca:	d8 07       	cpc	r29, r24
    16cc:	69 f4       	brne	.+26     	; 0x16e8 <prvAddCurrentTaskToDelayedList+0x46>
    16ce:	ff 20       	and	r15, r15
    16d0:	59 f0       	breq	.+22     	; 0x16e8 <prvAddCurrentTaskToDelayedList+0x46>
    16d2:	60 91 58 05 	lds	r22, 0x0558	; 0x800558 <pxCurrentTCB>
    16d6:	70 91 59 05 	lds	r23, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    16da:	6e 5f       	subi	r22, 0xFE	; 254
    16dc:	7f 4f       	sbci	r23, 0xFF	; 255
    16de:	8b e0       	ldi	r24, 0x0B	; 11
    16e0:	95 e0       	ldi	r25, 0x05	; 5
    16e2:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    16e6:	2f c0       	rjmp	.+94     	; 0x1746 <prvAddCurrentTaskToDelayedList+0xa4>
    16e8:	c0 0f       	add	r28, r16
    16ea:	d1 1f       	adc	r29, r17
    16ec:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    16f0:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    16f4:	d3 83       	std	Z+3, r29	; 0x03
    16f6:	c2 83       	std	Z+2, r28	; 0x02
    16f8:	c0 17       	cp	r28, r16
    16fa:	d1 07       	cpc	r29, r17
    16fc:	68 f4       	brcc	.+26     	; 0x1718 <prvAddCurrentTaskToDelayedList+0x76>
    16fe:	60 91 58 05 	lds	r22, 0x0558	; 0x800558 <pxCurrentTCB>
    1702:	70 91 59 05 	lds	r23, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1706:	80 91 27 05 	lds	r24, 0x0527	; 0x800527 <pxOverflowDelayedTaskList>
    170a:	90 91 28 05 	lds	r25, 0x0528	; 0x800528 <pxOverflowDelayedTaskList+0x1>
    170e:	6e 5f       	subi	r22, 0xFE	; 254
    1710:	7f 4f       	sbci	r23, 0xFF	; 255
    1712:	0e 94 d6 05 	call	0xbac	; 0xbac <vListInsert>
    1716:	17 c0       	rjmp	.+46     	; 0x1746 <prvAddCurrentTaskToDelayedList+0xa4>
    1718:	60 91 58 05 	lds	r22, 0x0558	; 0x800558 <pxCurrentTCB>
    171c:	70 91 59 05 	lds	r23, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1720:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <pxDelayedTaskList>
    1724:	90 91 2a 05 	lds	r25, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    1728:	6e 5f       	subi	r22, 0xFE	; 254
    172a:	7f 4f       	sbci	r23, 0xFF	; 255
    172c:	0e 94 d6 05 	call	0xbac	; 0xbac <vListInsert>
    1730:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <xNextTaskUnblockTime>
    1734:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <xNextTaskUnblockTime+0x1>
    1738:	c8 17       	cp	r28, r24
    173a:	d9 07       	cpc	r29, r25
    173c:	20 f4       	brcc	.+8      	; 0x1746 <prvAddCurrentTaskToDelayedList+0xa4>
    173e:	d0 93 01 05 	sts	0x0501, r29	; 0x800501 <xNextTaskUnblockTime+0x1>
    1742:	c0 93 00 05 	sts	0x0500, r28	; 0x800500 <xNextTaskUnblockTime>
    1746:	df 91       	pop	r29
    1748:	cf 91       	pop	r28
    174a:	1f 91       	pop	r17
    174c:	0f 91       	pop	r16
    174e:	ff 90       	pop	r15
    1750:	08 95       	ret

00001752 <xTaskCreate>:
    1752:	2f 92       	push	r2
    1754:	3f 92       	push	r3
    1756:	4f 92       	push	r4
    1758:	5f 92       	push	r5
    175a:	6f 92       	push	r6
    175c:	7f 92       	push	r7
    175e:	8f 92       	push	r8
    1760:	9f 92       	push	r9
    1762:	af 92       	push	r10
    1764:	bf 92       	push	r11
    1766:	cf 92       	push	r12
    1768:	df 92       	push	r13
    176a:	ef 92       	push	r14
    176c:	ff 92       	push	r15
    176e:	0f 93       	push	r16
    1770:	1f 93       	push	r17
    1772:	cf 93       	push	r28
    1774:	df 93       	push	r29
    1776:	3c 01       	movw	r6, r24
    1778:	1b 01       	movw	r2, r22
    177a:	5a 01       	movw	r10, r20
    177c:	29 01       	movw	r4, r18
    177e:	ca 01       	movw	r24, r20
    1780:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <pvPortMalloc>
    1784:	6c 01       	movw	r12, r24
    1786:	89 2b       	or	r24, r25
    1788:	71 f0       	breq	.+28     	; 0x17a6 <xTaskCreate+0x54>
    178a:	88 e2       	ldi	r24, 0x28	; 40
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <pvPortMalloc>
    1792:	ec 01       	movw	r28, r24
    1794:	89 2b       	or	r24, r25
    1796:	19 f0       	breq	.+6      	; 0x179e <xTaskCreate+0x4c>
    1798:	d8 8e       	std	Y+24, r13	; 0x18
    179a:	cf 8a       	std	Y+23, r12	; 0x17
    179c:	06 c0       	rjmp	.+12     	; 0x17aa <xTaskCreate+0x58>
    179e:	c6 01       	movw	r24, r12
    17a0:	0e 94 70 05 	call	0xae0	; 0xae0 <vPortFree>
    17a4:	02 c0       	rjmp	.+4      	; 0x17aa <xTaskCreate+0x58>
    17a6:	c0 e0       	ldi	r28, 0x00	; 0
    17a8:	d0 e0       	ldi	r29, 0x00	; 0
    17aa:	20 97       	sbiw	r28, 0x00	; 0
    17ac:	91 f0       	breq	.+36     	; 0x17d2 <xTaskCreate+0x80>
    17ae:	95 01       	movw	r18, r10
    17b0:	40 e0       	ldi	r20, 0x00	; 0
    17b2:	50 e0       	ldi	r21, 0x00	; 0
    17b4:	81 2c       	mov	r8, r1
    17b6:	91 2c       	mov	r9, r1
    17b8:	5e 01       	movw	r10, r28
    17ba:	67 01       	movw	r12, r14
    17bc:	e0 2e       	mov	r14, r16
    17be:	82 01       	movw	r16, r4
    17c0:	b1 01       	movw	r22, r2
    17c2:	c3 01       	movw	r24, r6
    17c4:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <prvInitialiseNewTask>
    17c8:	ce 01       	movw	r24, r28
    17ca:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <prvAddNewTaskToReadyList>
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	01 c0       	rjmp	.+2      	; 0x17d4 <xTaskCreate+0x82>
    17d2:	8f ef       	ldi	r24, 0xFF	; 255
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	bf 90       	pop	r11
    17e6:	af 90       	pop	r10
    17e8:	9f 90       	pop	r9
    17ea:	8f 90       	pop	r8
    17ec:	7f 90       	pop	r7
    17ee:	6f 90       	pop	r6
    17f0:	5f 90       	pop	r5
    17f2:	4f 90       	pop	r4
    17f4:	3f 90       	pop	r3
    17f6:	2f 90       	pop	r2
    17f8:	08 95       	ret

000017fa <vTaskStartScheduler>:
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	0f 93       	push	r16
    1800:	0f 2e       	mov	r0, r31
    1802:	fe ef       	ldi	r31, 0xFE	; 254
    1804:	ef 2e       	mov	r14, r31
    1806:	f4 e0       	ldi	r31, 0x04	; 4
    1808:	ff 2e       	mov	r15, r31
    180a:	f0 2d       	mov	r31, r0
    180c:	00 e0       	ldi	r16, 0x00	; 0
    180e:	20 e0       	ldi	r18, 0x00	; 0
    1810:	30 e0       	ldi	r19, 0x00	; 0
    1812:	4c e2       	ldi	r20, 0x2C	; 44
    1814:	51 e0       	ldi	r21, 0x01	; 1
    1816:	60 e0       	ldi	r22, 0x00	; 0
    1818:	71 e0       	ldi	r23, 0x01	; 1
    181a:	8d e9       	ldi	r24, 0x9D	; 157
    181c:	9d e0       	ldi	r25, 0x0D	; 13
    181e:	0e 94 a9 0b 	call	0x1752	; 0x1752 <xTaskCreate>
    1822:	81 30       	cpi	r24, 0x01	; 1
    1824:	81 f4       	brne	.+32     	; 0x1846 <vTaskStartScheduler+0x4c>
    1826:	f8 94       	cli
    1828:	8f ef       	ldi	r24, 0xFF	; 255
    182a:	9f ef       	ldi	r25, 0xFF	; 255
    182c:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <xNextTaskUnblockTime+0x1>
    1830:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <xNextTaskUnblockTime>
    1834:	81 e0       	ldi	r24, 0x01	; 1
    1836:	80 93 06 05 	sts	0x0506, r24	; 0x800506 <xSchedulerRunning>
    183a:	10 92 09 05 	sts	0x0509, r1	; 0x800509 <xTickCount+0x1>
    183e:	10 92 08 05 	sts	0x0508, r1	; 0x800508 <xTickCount>
    1842:	0e 94 a2 06 	call	0xd44	; 0xd44 <xPortStartScheduler>
    1846:	0f 91       	pop	r16
    1848:	ff 90       	pop	r15
    184a:	ef 90       	pop	r14
    184c:	08 95       	ret

0000184e <vTaskSuspendAll>:
    184e:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxSchedulerSuspended>
    1858:	08 95       	ret

0000185a <xTaskIncrementTick>:
    185a:	df 92       	push	r13
    185c:	ef 92       	push	r14
    185e:	ff 92       	push	r15
    1860:	0f 93       	push	r16
    1862:	1f 93       	push	r17
    1864:	cf 93       	push	r28
    1866:	df 93       	push	r29
    1868:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    186c:	81 11       	cpse	r24, r1
    186e:	97 c0       	rjmp	.+302    	; 0x199e <xTaskIncrementTick+0x144>
    1870:	e0 90 08 05 	lds	r14, 0x0508	; 0x800508 <xTickCount>
    1874:	f0 90 09 05 	lds	r15, 0x0509	; 0x800509 <xTickCount+0x1>
    1878:	8f ef       	ldi	r24, 0xFF	; 255
    187a:	e8 1a       	sub	r14, r24
    187c:	f8 0a       	sbc	r15, r24
    187e:	f0 92 09 05 	sts	0x0509, r15	; 0x800509 <xTickCount+0x1>
    1882:	e0 92 08 05 	sts	0x0508, r14	; 0x800508 <xTickCount>
    1886:	e1 14       	cp	r14, r1
    1888:	f1 04       	cpc	r15, r1
    188a:	b9 f4       	brne	.+46     	; 0x18ba <xTaskIncrementTick+0x60>
    188c:	80 91 29 05 	lds	r24, 0x0529	; 0x800529 <pxDelayedTaskList>
    1890:	90 91 2a 05 	lds	r25, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    1894:	20 91 27 05 	lds	r18, 0x0527	; 0x800527 <pxOverflowDelayedTaskList>
    1898:	30 91 28 05 	lds	r19, 0x0528	; 0x800528 <pxOverflowDelayedTaskList+0x1>
    189c:	30 93 2a 05 	sts	0x052A, r19	; 0x80052a <pxDelayedTaskList+0x1>
    18a0:	20 93 29 05 	sts	0x0529, r18	; 0x800529 <pxDelayedTaskList>
    18a4:	90 93 28 05 	sts	0x0528, r25	; 0x800528 <pxOverflowDelayedTaskList+0x1>
    18a8:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <pxOverflowDelayedTaskList>
    18ac:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <xNumOfOverflows>
    18b0:	8f 5f       	subi	r24, 0xFF	; 255
    18b2:	80 93 03 05 	sts	0x0503, r24	; 0x800503 <xNumOfOverflows>
    18b6:	0e 94 27 0a 	call	0x144e	; 0x144e <prvResetNextTaskUnblockTime>
    18ba:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <xNextTaskUnblockTime>
    18be:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <xNextTaskUnblockTime+0x1>
    18c2:	e8 16       	cp	r14, r24
    18c4:	f9 06       	cpc	r15, r25
    18c6:	28 f4       	brcc	.+10     	; 0x18d2 <xTaskIncrementTick+0x78>
    18c8:	d1 2c       	mov	r13, r1
    18ca:	53 c0       	rjmp	.+166    	; 0x1972 <xTaskIncrementTick+0x118>
    18cc:	dd 24       	eor	r13, r13
    18ce:	d3 94       	inc	r13
    18d0:	01 c0       	rjmp	.+2      	; 0x18d4 <xTaskIncrementTick+0x7a>
    18d2:	d1 2c       	mov	r13, r1
    18d4:	e0 91 29 05 	lds	r30, 0x0529	; 0x800529 <pxDelayedTaskList>
    18d8:	f0 91 2a 05 	lds	r31, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    18dc:	80 81       	ld	r24, Z
    18de:	81 11       	cpse	r24, r1
    18e0:	07 c0       	rjmp	.+14     	; 0x18f0 <xTaskIncrementTick+0x96>
    18e2:	8f ef       	ldi	r24, 0xFF	; 255
    18e4:	9f ef       	ldi	r25, 0xFF	; 255
    18e6:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <xNextTaskUnblockTime+0x1>
    18ea:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <xNextTaskUnblockTime>
    18ee:	41 c0       	rjmp	.+130    	; 0x1972 <xTaskIncrementTick+0x118>
    18f0:	e0 91 29 05 	lds	r30, 0x0529	; 0x800529 <pxDelayedTaskList>
    18f4:	f0 91 2a 05 	lds	r31, 0x052A	; 0x80052a <pxDelayedTaskList+0x1>
    18f8:	05 80       	ldd	r0, Z+5	; 0x05
    18fa:	f6 81       	ldd	r31, Z+6	; 0x06
    18fc:	e0 2d       	mov	r30, r0
    18fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1900:	d7 81       	ldd	r29, Z+7	; 0x07
    1902:	8a 81       	ldd	r24, Y+2	; 0x02
    1904:	9b 81       	ldd	r25, Y+3	; 0x03
    1906:	e8 16       	cp	r14, r24
    1908:	f9 06       	cpc	r15, r25
    190a:	28 f4       	brcc	.+10     	; 0x1916 <xTaskIncrementTick+0xbc>
    190c:	90 93 01 05 	sts	0x0501, r25	; 0x800501 <xNextTaskUnblockTime+0x1>
    1910:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <xNextTaskUnblockTime>
    1914:	2e c0       	rjmp	.+92     	; 0x1972 <xTaskIncrementTick+0x118>
    1916:	8e 01       	movw	r16, r28
    1918:	0e 5f       	subi	r16, 0xFE	; 254
    191a:	1f 4f       	sbci	r17, 0xFF	; 255
    191c:	c8 01       	movw	r24, r16
    191e:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1922:	8c 89       	ldd	r24, Y+20	; 0x14
    1924:	9d 89       	ldd	r25, Y+21	; 0x15
    1926:	89 2b       	or	r24, r25
    1928:	21 f0       	breq	.+8      	; 0x1932 <xTaskIncrementTick+0xd8>
    192a:	ce 01       	movw	r24, r28
    192c:	0c 96       	adiw	r24, 0x0c	; 12
    192e:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1932:	8e 89       	ldd	r24, Y+22	; 0x16
    1934:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1938:	98 17       	cp	r25, r24
    193a:	10 f4       	brcc	.+4      	; 0x1940 <xTaskIncrementTick+0xe6>
    193c:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	9c 01       	movw	r18, r24
    1944:	22 0f       	add	r18, r18
    1946:	33 1f       	adc	r19, r19
    1948:	22 0f       	add	r18, r18
    194a:	33 1f       	adc	r19, r19
    194c:	22 0f       	add	r18, r18
    194e:	33 1f       	adc	r19, r19
    1950:	82 0f       	add	r24, r18
    1952:	93 1f       	adc	r25, r19
    1954:	b8 01       	movw	r22, r16
    1956:	83 5c       	subi	r24, 0xC3	; 195
    1958:	9a 4f       	sbci	r25, 0xFA	; 250
    195a:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    195e:	9e 89       	ldd	r25, Y+22	; 0x16
    1960:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1964:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1968:	86 89       	ldd	r24, Z+22	; 0x16
    196a:	98 17       	cp	r25, r24
    196c:	08 f0       	brcs	.+2      	; 0x1970 <xTaskIncrementTick+0x116>
    196e:	ae cf       	rjmp	.-164    	; 0x18cc <xTaskIncrementTick+0x72>
    1970:	b1 cf       	rjmp	.-158    	; 0x18d4 <xTaskIncrementTick+0x7a>
    1972:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1976:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    197a:	86 89       	ldd	r24, Z+22	; 0x16
    197c:	90 e0       	ldi	r25, 0x00	; 0
    197e:	fc 01       	movw	r30, r24
    1980:	ee 0f       	add	r30, r30
    1982:	ff 1f       	adc	r31, r31
    1984:	ee 0f       	add	r30, r30
    1986:	ff 1f       	adc	r31, r31
    1988:	ee 0f       	add	r30, r30
    198a:	ff 1f       	adc	r31, r31
    198c:	8e 0f       	add	r24, r30
    198e:	9f 1f       	adc	r25, r31
    1990:	fc 01       	movw	r30, r24
    1992:	e3 5c       	subi	r30, 0xC3	; 195
    1994:	fa 4f       	sbci	r31, 0xFA	; 250
    1996:	80 81       	ld	r24, Z
    1998:	82 30       	cpi	r24, 0x02	; 2
    199a:	40 f4       	brcc	.+16     	; 0x19ac <xTaskIncrementTick+0x152>
    199c:	09 c0       	rjmp	.+18     	; 0x19b0 <xTaskIncrementTick+0x156>
    199e:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxPendedTicks>
    19a2:	8f 5f       	subi	r24, 0xFF	; 255
    19a4:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <uxPendedTicks>
    19a8:	d1 2c       	mov	r13, r1
    19aa:	02 c0       	rjmp	.+4      	; 0x19b0 <xTaskIncrementTick+0x156>
    19ac:	dd 24       	eor	r13, r13
    19ae:	d3 94       	inc	r13
    19b0:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <xYieldPending>
    19b4:	88 23       	and	r24, r24
    19b6:	11 f0       	breq	.+4      	; 0x19bc <xTaskIncrementTick+0x162>
    19b8:	dd 24       	eor	r13, r13
    19ba:	d3 94       	inc	r13
    19bc:	8d 2d       	mov	r24, r13
    19be:	df 91       	pop	r29
    19c0:	cf 91       	pop	r28
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	ff 90       	pop	r15
    19c8:	ef 90       	pop	r14
    19ca:	df 90       	pop	r13
    19cc:	08 95       	ret

000019ce <xTaskResumeAll>:
    19ce:	0f 93       	push	r16
    19d0:	1f 93       	push	r17
    19d2:	cf 93       	push	r28
    19d4:	df 93       	push	r29
    19d6:	0f b6       	in	r0, 0x3f	; 63
    19d8:	f8 94       	cli
    19da:	0f 92       	push	r0
    19dc:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    19e0:	81 50       	subi	r24, 0x01	; 1
    19e2:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxSchedulerSuspended>
    19e6:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    19ea:	81 11       	cpse	r24, r1
    19ec:	58 c0       	rjmp	.+176    	; 0x1a9e <xTaskResumeAll+0xd0>
    19ee:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxCurrentNumberOfTasks>
    19f2:	81 11       	cpse	r24, r1
    19f4:	33 c0       	rjmp	.+102    	; 0x1a5c <xTaskResumeAll+0x8e>
    19f6:	56 c0       	rjmp	.+172    	; 0x1aa4 <xTaskResumeAll+0xd6>
    19f8:	e0 91 23 05 	lds	r30, 0x0523	; 0x800523 <xPendingReadyList+0x5>
    19fc:	f0 91 24 05 	lds	r31, 0x0524	; 0x800524 <xPendingReadyList+0x6>
    1a00:	c6 81       	ldd	r28, Z+6	; 0x06
    1a02:	d7 81       	ldd	r29, Z+7	; 0x07
    1a04:	ce 01       	movw	r24, r28
    1a06:	0c 96       	adiw	r24, 0x0c	; 12
    1a08:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1a0c:	8e 01       	movw	r16, r28
    1a0e:	0e 5f       	subi	r16, 0xFE	; 254
    1a10:	1f 4f       	sbci	r17, 0xFF	; 255
    1a12:	c8 01       	movw	r24, r16
    1a14:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1a18:	8e 89       	ldd	r24, Y+22	; 0x16
    1a1a:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1a1e:	98 17       	cp	r25, r24
    1a20:	10 f4       	brcc	.+4      	; 0x1a26 <xTaskResumeAll+0x58>
    1a22:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    1a26:	90 e0       	ldi	r25, 0x00	; 0
    1a28:	9c 01       	movw	r18, r24
    1a2a:	22 0f       	add	r18, r18
    1a2c:	33 1f       	adc	r19, r19
    1a2e:	22 0f       	add	r18, r18
    1a30:	33 1f       	adc	r19, r19
    1a32:	22 0f       	add	r18, r18
    1a34:	33 1f       	adc	r19, r19
    1a36:	82 0f       	add	r24, r18
    1a38:	93 1f       	adc	r25, r19
    1a3a:	b8 01       	movw	r22, r16
    1a3c:	83 5c       	subi	r24, 0xC3	; 195
    1a3e:	9a 4f       	sbci	r25, 0xFA	; 250
    1a40:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    1a44:	9e 89       	ldd	r25, Y+22	; 0x16
    1a46:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1a4a:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1a4e:	86 89       	ldd	r24, Z+22	; 0x16
    1a50:	98 17       	cp	r25, r24
    1a52:	30 f0       	brcs	.+12     	; 0x1a60 <xTaskResumeAll+0x92>
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <xYieldPending>
    1a5a:	02 c0       	rjmp	.+4      	; 0x1a60 <xTaskResumeAll+0x92>
    1a5c:	c0 e0       	ldi	r28, 0x00	; 0
    1a5e:	d0 e0       	ldi	r29, 0x00	; 0
    1a60:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <xPendingReadyList>
    1a64:	81 11       	cpse	r24, r1
    1a66:	c8 cf       	rjmp	.-112    	; 0x19f8 <xTaskResumeAll+0x2a>
    1a68:	cd 2b       	or	r28, r29
    1a6a:	11 f0       	breq	.+4      	; 0x1a70 <xTaskResumeAll+0xa2>
    1a6c:	0e 94 27 0a 	call	0x144e	; 0x144e <prvResetNextTaskUnblockTime>
    1a70:	c0 91 05 05 	lds	r28, 0x0505	; 0x800505 <uxPendedTicks>
    1a74:	cc 23       	and	r28, r28
    1a76:	59 f0       	breq	.+22     	; 0x1a8e <xTaskResumeAll+0xc0>
    1a78:	0e 94 2d 0c 	call	0x185a	; 0x185a <xTaskIncrementTick>
    1a7c:	88 23       	and	r24, r24
    1a7e:	19 f0       	breq	.+6      	; 0x1a86 <xTaskResumeAll+0xb8>
    1a80:	81 e0       	ldi	r24, 0x01	; 1
    1a82:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <xYieldPending>
    1a86:	c1 50       	subi	r28, 0x01	; 1
    1a88:	b9 f7       	brne	.-18     	; 0x1a78 <xTaskResumeAll+0xaa>
    1a8a:	10 92 05 05 	sts	0x0505, r1	; 0x800505 <uxPendedTicks>
    1a8e:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <xYieldPending>
    1a92:	88 23       	and	r24, r24
    1a94:	31 f0       	breq	.+12     	; 0x1aa2 <xTaskResumeAll+0xd4>
    1a96:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1a9a:	81 e0       	ldi	r24, 0x01	; 1
    1a9c:	03 c0       	rjmp	.+6      	; 0x1aa4 <xTaskResumeAll+0xd6>
    1a9e:	80 e0       	ldi	r24, 0x00	; 0
    1aa0:	01 c0       	rjmp	.+2      	; 0x1aa4 <xTaskResumeAll+0xd6>
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
    1aa4:	0f 90       	pop	r0
    1aa6:	0f be       	out	0x3f, r0	; 63
    1aa8:	df 91       	pop	r29
    1aaa:	cf 91       	pop	r28
    1aac:	1f 91       	pop	r17
    1aae:	0f 91       	pop	r16
    1ab0:	08 95       	ret

00001ab2 <vTaskDelay>:
    1ab2:	cf 93       	push	r28
    1ab4:	df 93       	push	r29
    1ab6:	ec 01       	movw	r28, r24
    1ab8:	89 2b       	or	r24, r25
    1aba:	49 f0       	breq	.+18     	; 0x1ace <vTaskDelay+0x1c>
    1abc:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
    1ac0:	60 e0       	ldi	r22, 0x00	; 0
    1ac2:	ce 01       	movw	r24, r28
    1ac4:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <prvAddCurrentTaskToDelayedList>
    1ac8:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    1acc:	01 c0       	rjmp	.+2      	; 0x1ad0 <vTaskDelay+0x1e>
    1ace:	80 e0       	ldi	r24, 0x00	; 0
    1ad0:	81 11       	cpse	r24, r1
    1ad2:	02 c0       	rjmp	.+4      	; 0x1ad8 <vTaskDelay+0x26>
    1ad4:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortYield>
    1ad8:	df 91       	pop	r29
    1ada:	cf 91       	pop	r28
    1adc:	08 95       	ret

00001ade <prvCheckTasksWaitingTermination>:
    1ade:	cf 93       	push	r28
    1ae0:	df 93       	push	r29
    1ae2:	24 c0       	rjmp	.+72     	; 0x1b2c <prvCheckTasksWaitingTermination+0x4e>
    1ae4:	0e 94 27 0c 	call	0x184e	; 0x184e <vTaskSuspendAll>
    1ae8:	c0 91 15 05 	lds	r28, 0x0515	; 0x800515 <xTasksWaitingTermination>
    1aec:	0e 94 e7 0c 	call	0x19ce	; 0x19ce <xTaskResumeAll>
    1af0:	cc 23       	and	r28, r28
    1af2:	e1 f0       	breq	.+56     	; 0x1b2c <prvCheckTasksWaitingTermination+0x4e>
    1af4:	0f b6       	in	r0, 0x3f	; 63
    1af6:	f8 94       	cli
    1af8:	0f 92       	push	r0
    1afa:	e0 91 1a 05 	lds	r30, 0x051A	; 0x80051a <xTasksWaitingTermination+0x5>
    1afe:	f0 91 1b 05 	lds	r31, 0x051B	; 0x80051b <xTasksWaitingTermination+0x6>
    1b02:	c6 81       	ldd	r28, Z+6	; 0x06
    1b04:	d7 81       	ldd	r29, Z+7	; 0x07
    1b06:	ce 01       	movw	r24, r28
    1b08:	02 96       	adiw	r24, 0x02	; 2
    1b0a:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1b0e:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <uxCurrentNumberOfTasks>
    1b12:	81 50       	subi	r24, 0x01	; 1
    1b14:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <uxCurrentNumberOfTasks>
    1b18:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <uxDeletedTasksWaitingCleanUp>
    1b1c:	81 50       	subi	r24, 0x01	; 1
    1b1e:	80 93 14 05 	sts	0x0514, r24	; 0x800514 <uxDeletedTasksWaitingCleanUp>
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	ce 01       	movw	r24, r28
    1b28:	0e 94 46 0a 	call	0x148c	; 0x148c <prvDeleteTCB>
    1b2c:	80 91 14 05 	lds	r24, 0x0514	; 0x800514 <uxDeletedTasksWaitingCleanUp>
    1b30:	81 11       	cpse	r24, r1
    1b32:	d8 cf       	rjmp	.-80     	; 0x1ae4 <prvCheckTasksWaitingTermination+0x6>
    1b34:	df 91       	pop	r29
    1b36:	cf 91       	pop	r28
    1b38:	08 95       	ret

00001b3a <prvIdleTask>:
    1b3a:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <prvCheckTasksWaitingTermination>
    1b3e:	fd cf       	rjmp	.-6      	; 0x1b3a <prvIdleTask>

00001b40 <vTaskSwitchContext>:
    1b40:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    1b44:	88 23       	and	r24, r24
    1b46:	21 f0       	breq	.+8      	; 0x1b50 <vTaskSwitchContext+0x10>
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <xYieldPending>
    1b4e:	08 95       	ret
    1b50:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <xYieldPending>
    1b54:	20 91 07 05 	lds	r18, 0x0507	; 0x800507 <uxTopReadyPriority>
    1b58:	01 c0       	rjmp	.+2      	; 0x1b5c <vTaskSwitchContext+0x1c>
    1b5a:	21 50       	subi	r18, 0x01	; 1
    1b5c:	82 2f       	mov	r24, r18
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	fc 01       	movw	r30, r24
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ee 0f       	add	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	ee 0f       	add	r30, r30
    1b6c:	ff 1f       	adc	r31, r31
    1b6e:	e8 0f       	add	r30, r24
    1b70:	f9 1f       	adc	r31, r25
    1b72:	e3 5c       	subi	r30, 0xC3	; 195
    1b74:	fa 4f       	sbci	r31, 0xFA	; 250
    1b76:	30 81       	ld	r19, Z
    1b78:	33 23       	and	r19, r19
    1b7a:	79 f3       	breq	.-34     	; 0x1b5a <vTaskSwitchContext+0x1a>
    1b7c:	ac 01       	movw	r20, r24
    1b7e:	44 0f       	add	r20, r20
    1b80:	55 1f       	adc	r21, r21
    1b82:	44 0f       	add	r20, r20
    1b84:	55 1f       	adc	r21, r21
    1b86:	44 0f       	add	r20, r20
    1b88:	55 1f       	adc	r21, r21
    1b8a:	48 0f       	add	r20, r24
    1b8c:	59 1f       	adc	r21, r25
    1b8e:	df 01       	movw	r26, r30
    1b90:	01 80       	ldd	r0, Z+1	; 0x01
    1b92:	f2 81       	ldd	r31, Z+2	; 0x02
    1b94:	e0 2d       	mov	r30, r0
    1b96:	02 80       	ldd	r0, Z+2	; 0x02
    1b98:	f3 81       	ldd	r31, Z+3	; 0x03
    1b9a:	e0 2d       	mov	r30, r0
    1b9c:	12 96       	adiw	r26, 0x02	; 2
    1b9e:	fc 93       	st	X, r31
    1ba0:	ee 93       	st	-X, r30
    1ba2:	11 97       	sbiw	r26, 0x01	; 1
    1ba4:	40 5c       	subi	r20, 0xC0	; 192
    1ba6:	5a 4f       	sbci	r21, 0xFA	; 250
    1ba8:	e4 17       	cp	r30, r20
    1baa:	f5 07       	cpc	r31, r21
    1bac:	29 f4       	brne	.+10     	; 0x1bb8 <vTaskSwitchContext+0x78>
    1bae:	42 81       	ldd	r20, Z+2	; 0x02
    1bb0:	53 81       	ldd	r21, Z+3	; 0x03
    1bb2:	fd 01       	movw	r30, r26
    1bb4:	52 83       	std	Z+2, r21	; 0x02
    1bb6:	41 83       	std	Z+1, r20	; 0x01
    1bb8:	fc 01       	movw	r30, r24
    1bba:	ee 0f       	add	r30, r30
    1bbc:	ff 1f       	adc	r31, r31
    1bbe:	ee 0f       	add	r30, r30
    1bc0:	ff 1f       	adc	r31, r31
    1bc2:	ee 0f       	add	r30, r30
    1bc4:	ff 1f       	adc	r31, r31
    1bc6:	8e 0f       	add	r24, r30
    1bc8:	9f 1f       	adc	r25, r31
    1bca:	fc 01       	movw	r30, r24
    1bcc:	e3 5c       	subi	r30, 0xC3	; 195
    1bce:	fa 4f       	sbci	r31, 0xFA	; 250
    1bd0:	01 80       	ldd	r0, Z+1	; 0x01
    1bd2:	f2 81       	ldd	r31, Z+2	; 0x02
    1bd4:	e0 2d       	mov	r30, r0
    1bd6:	86 81       	ldd	r24, Z+6	; 0x06
    1bd8:	97 81       	ldd	r25, Z+7	; 0x07
    1bda:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <pxCurrentTCB+0x1>
    1bde:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <pxCurrentTCB>
    1be2:	20 93 07 05 	sts	0x0507, r18	; 0x800507 <uxTopReadyPriority>
    1be6:	08 95       	ret

00001be8 <vTaskPlaceOnEventList>:
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	eb 01       	movw	r28, r22
    1bee:	60 91 58 05 	lds	r22, 0x0558	; 0x800558 <pxCurrentTCB>
    1bf2:	70 91 59 05 	lds	r23, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1bf6:	64 5f       	subi	r22, 0xF4	; 244
    1bf8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfa:	0e 94 d6 05 	call	0xbac	; 0xbac <vListInsert>
    1bfe:	61 e0       	ldi	r22, 0x01	; 1
    1c00:	ce 01       	movw	r24, r28
    1c02:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <prvAddCurrentTaskToDelayedList>
    1c06:	df 91       	pop	r29
    1c08:	cf 91       	pop	r28
    1c0a:	08 95       	ret

00001c0c <xTaskRemoveFromEventList>:
    1c0c:	0f 93       	push	r16
    1c0e:	1f 93       	push	r17
    1c10:	cf 93       	push	r28
    1c12:	df 93       	push	r29
    1c14:	dc 01       	movw	r26, r24
    1c16:	15 96       	adiw	r26, 0x05	; 5
    1c18:	ed 91       	ld	r30, X+
    1c1a:	fc 91       	ld	r31, X
    1c1c:	16 97       	sbiw	r26, 0x06	; 6
    1c1e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c20:	d7 81       	ldd	r29, Z+7	; 0x07
    1c22:	8e 01       	movw	r16, r28
    1c24:	04 5f       	subi	r16, 0xF4	; 244
    1c26:	1f 4f       	sbci	r17, 0xFF	; 255
    1c28:	c8 01       	movw	r24, r16
    1c2a:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1c2e:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxSchedulerSuspended>
    1c32:	81 11       	cpse	r24, r1
    1c34:	1c c0       	rjmp	.+56     	; 0x1c6e <xTaskRemoveFromEventList+0x62>
    1c36:	0a 50       	subi	r16, 0x0A	; 10
    1c38:	11 09       	sbc	r17, r1
    1c3a:	c8 01       	movw	r24, r16
    1c3c:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1c40:	8e 89       	ldd	r24, Y+22	; 0x16
    1c42:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1c46:	98 17       	cp	r25, r24
    1c48:	10 f4       	brcc	.+4      	; 0x1c4e <xTaskRemoveFromEventList+0x42>
    1c4a:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	9c 01       	movw	r18, r24
    1c52:	22 0f       	add	r18, r18
    1c54:	33 1f       	adc	r19, r19
    1c56:	22 0f       	add	r18, r18
    1c58:	33 1f       	adc	r19, r19
    1c5a:	22 0f       	add	r18, r18
    1c5c:	33 1f       	adc	r19, r19
    1c5e:	82 0f       	add	r24, r18
    1c60:	93 1f       	adc	r25, r19
    1c62:	b8 01       	movw	r22, r16
    1c64:	83 5c       	subi	r24, 0xC3	; 195
    1c66:	9a 4f       	sbci	r25, 0xFA	; 250
    1c68:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    1c6c:	05 c0       	rjmp	.+10     	; 0x1c78 <xTaskRemoveFromEventList+0x6c>
    1c6e:	b8 01       	movw	r22, r16
    1c70:	8e e1       	ldi	r24, 0x1E	; 30
    1c72:	95 e0       	ldi	r25, 0x05	; 5
    1c74:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    1c78:	9e 89       	ldd	r25, Y+22	; 0x16
    1c7a:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1c7e:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1c82:	86 89       	ldd	r24, Z+22	; 0x16
    1c84:	89 17       	cp	r24, r25
    1c86:	20 f4       	brcc	.+8      	; 0x1c90 <xTaskRemoveFromEventList+0x84>
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <xYieldPending>
    1c8e:	01 c0       	rjmp	.+2      	; 0x1c92 <xTaskRemoveFromEventList+0x86>
    1c90:	80 e0       	ldi	r24, 0x00	; 0
    1c92:	df 91       	pop	r29
    1c94:	cf 91       	pop	r28
    1c96:	1f 91       	pop	r17
    1c98:	0f 91       	pop	r16
    1c9a:	08 95       	ret

00001c9c <vTaskSetTimeOutState>:
    1c9c:	20 91 03 05 	lds	r18, 0x0503	; 0x800503 <xNumOfOverflows>
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	20 83       	st	Z, r18
    1ca4:	20 91 08 05 	lds	r18, 0x0508	; 0x800508 <xTickCount>
    1ca8:	30 91 09 05 	lds	r19, 0x0509	; 0x800509 <xTickCount+0x1>
    1cac:	32 83       	std	Z+2, r19	; 0x02
    1cae:	21 83       	std	Z+1, r18	; 0x01
    1cb0:	08 95       	ret

00001cb2 <xTaskCheckForTimeOut>:
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
    1cb8:	40 91 08 05 	lds	r20, 0x0508	; 0x800508 <xTickCount>
    1cbc:	50 91 09 05 	lds	r21, 0x0509	; 0x800509 <xTickCount+0x1>
    1cc0:	db 01       	movw	r26, r22
    1cc2:	2d 91       	ld	r18, X+
    1cc4:	3c 91       	ld	r19, X
    1cc6:	2f 3f       	cpi	r18, 0xFF	; 255
    1cc8:	bf ef       	ldi	r27, 0xFF	; 255
    1cca:	3b 07       	cpc	r19, r27
    1ccc:	19 f1       	breq	.+70     	; 0x1d14 <xTaskCheckForTimeOut+0x62>
    1cce:	dc 01       	movw	r26, r24
    1cd0:	fc 91       	ld	r31, X
    1cd2:	e0 91 03 05 	lds	r30, 0x0503	; 0x800503 <xNumOfOverflows>
    1cd6:	fe 17       	cp	r31, r30
    1cd8:	39 f0       	breq	.+14     	; 0x1ce8 <xTaskCheckForTimeOut+0x36>
    1cda:	11 96       	adiw	r26, 0x01	; 1
    1cdc:	ed 91       	ld	r30, X+
    1cde:	fc 91       	ld	r31, X
    1ce0:	12 97       	sbiw	r26, 0x02	; 2
    1ce2:	4e 17       	cp	r20, r30
    1ce4:	5f 07       	cpc	r21, r31
    1ce6:	c0 f4       	brcc	.+48     	; 0x1d18 <xTaskCheckForTimeOut+0x66>
    1ce8:	dc 01       	movw	r26, r24
    1cea:	11 96       	adiw	r26, 0x01	; 1
    1cec:	ed 91       	ld	r30, X+
    1cee:	fc 91       	ld	r31, X
    1cf0:	12 97       	sbiw	r26, 0x02	; 2
    1cf2:	da 01       	movw	r26, r20
    1cf4:	ae 1b       	sub	r26, r30
    1cf6:	bf 0b       	sbc	r27, r31
    1cf8:	a2 17       	cp	r26, r18
    1cfa:	b3 07       	cpc	r27, r19
    1cfc:	78 f4       	brcc	.+30     	; 0x1d1c <xTaskCheckForTimeOut+0x6a>
    1cfe:	db 01       	movw	r26, r22
    1d00:	e4 1b       	sub	r30, r20
    1d02:	f5 0b       	sbc	r31, r21
    1d04:	2e 0f       	add	r18, r30
    1d06:	3f 1f       	adc	r19, r31
    1d08:	2d 93       	st	X+, r18
    1d0a:	3c 93       	st	X, r19
    1d0c:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <vTaskSetTimeOutState>
    1d10:	80 e0       	ldi	r24, 0x00	; 0
    1d12:	05 c0       	rjmp	.+10     	; 0x1d1e <xTaskCheckForTimeOut+0x6c>
    1d14:	80 e0       	ldi	r24, 0x00	; 0
    1d16:	03 c0       	rjmp	.+6      	; 0x1d1e <xTaskCheckForTimeOut+0x6c>
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <xTaskCheckForTimeOut+0x6c>
    1d1c:	81 e0       	ldi	r24, 0x01	; 1
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63
    1d22:	08 95       	ret

00001d24 <vTaskMissedYield>:
    1d24:	81 e0       	ldi	r24, 0x01	; 1
    1d26:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <xYieldPending>
    1d2a:	08 95       	ret

00001d2c <vTaskPriorityInherit>:
    1d2c:	0f 93       	push	r16
    1d2e:	1f 93       	push	r17
    1d30:	cf 93       	push	r28
    1d32:	df 93       	push	r29
    1d34:	fc 01       	movw	r30, r24
    1d36:	89 2b       	or	r24, r25
    1d38:	09 f4       	brne	.+2      	; 0x1d3c <vTaskPriorityInherit+0x10>
    1d3a:	55 c0       	rjmp	.+170    	; 0x1de6 <vTaskPriorityInherit+0xba>
    1d3c:	26 89       	ldd	r18, Z+22	; 0x16
    1d3e:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
    1d42:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1d46:	56 96       	adiw	r26, 0x16	; 22
    1d48:	8c 91       	ld	r24, X
    1d4a:	28 17       	cp	r18, r24
    1d4c:	08 f0       	brcs	.+2      	; 0x1d50 <vTaskPriorityInherit+0x24>
    1d4e:	4b c0       	rjmp	.+150    	; 0x1de6 <vTaskPriorityInherit+0xba>
    1d50:	84 85       	ldd	r24, Z+12	; 0x0c
    1d52:	95 85       	ldd	r25, Z+13	; 0x0d
    1d54:	99 23       	and	r25, r25
    1d56:	64 f0       	brlt	.+24     	; 0x1d70 <vTaskPriorityInherit+0x44>
    1d58:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
    1d5c:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1d60:	56 96       	adiw	r26, 0x16	; 22
    1d62:	3c 91       	ld	r19, X
    1d64:	83 e0       	ldi	r24, 0x03	; 3
    1d66:	90 e0       	ldi	r25, 0x00	; 0
    1d68:	83 1b       	sub	r24, r19
    1d6a:	91 09       	sbc	r25, r1
    1d6c:	95 87       	std	Z+13, r25	; 0x0d
    1d6e:	84 87       	std	Z+12, r24	; 0x0c
    1d70:	82 85       	ldd	r24, Z+10	; 0x0a
    1d72:	93 85       	ldd	r25, Z+11	; 0x0b
    1d74:	30 e0       	ldi	r19, 0x00	; 0
    1d76:	a9 01       	movw	r20, r18
    1d78:	44 0f       	add	r20, r20
    1d7a:	55 1f       	adc	r21, r21
    1d7c:	44 0f       	add	r20, r20
    1d7e:	55 1f       	adc	r21, r21
    1d80:	44 0f       	add	r20, r20
    1d82:	55 1f       	adc	r21, r21
    1d84:	24 0f       	add	r18, r20
    1d86:	35 1f       	adc	r19, r21
    1d88:	23 5c       	subi	r18, 0xC3	; 195
    1d8a:	3a 4f       	sbci	r19, 0xFA	; 250
    1d8c:	82 17       	cp	r24, r18
    1d8e:	93 07       	cpc	r25, r19
    1d90:	19 f5       	brne	.+70     	; 0x1dd8 <vTaskPriorityInherit+0xac>
    1d92:	8f 01       	movw	r16, r30
    1d94:	ef 01       	movw	r28, r30
    1d96:	22 96       	adiw	r28, 0x02	; 2
    1d98:	ce 01       	movw	r24, r28
    1d9a:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1d9e:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1da2:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1da6:	86 89       	ldd	r24, Z+22	; 0x16
    1da8:	f8 01       	movw	r30, r16
    1daa:	86 8b       	std	Z+22, r24	; 0x16
    1dac:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1db0:	98 17       	cp	r25, r24
    1db2:	10 f4       	brcc	.+4      	; 0x1db8 <vTaskPriorityInherit+0x8c>
    1db4:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	9c 01       	movw	r18, r24
    1dbc:	22 0f       	add	r18, r18
    1dbe:	33 1f       	adc	r19, r19
    1dc0:	22 0f       	add	r18, r18
    1dc2:	33 1f       	adc	r19, r19
    1dc4:	22 0f       	add	r18, r18
    1dc6:	33 1f       	adc	r19, r19
    1dc8:	82 0f       	add	r24, r18
    1dca:	93 1f       	adc	r25, r19
    1dcc:	be 01       	movw	r22, r28
    1dce:	83 5c       	subi	r24, 0xC3	; 195
    1dd0:	9a 4f       	sbci	r25, 0xFA	; 250
    1dd2:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    1dd6:	07 c0       	rjmp	.+14     	; 0x1de6 <vTaskPriorityInherit+0xba>
    1dd8:	a0 91 58 05 	lds	r26, 0x0558	; 0x800558 <pxCurrentTCB>
    1ddc:	b0 91 59 05 	lds	r27, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1de0:	56 96       	adiw	r26, 0x16	; 22
    1de2:	8c 91       	ld	r24, X
    1de4:	86 8b       	std	Z+22, r24	; 0x16
    1de6:	df 91       	pop	r29
    1de8:	cf 91       	pop	r28
    1dea:	1f 91       	pop	r17
    1dec:	0f 91       	pop	r16
    1dee:	08 95       	ret

00001df0 <xTaskPriorityDisinherit>:
    1df0:	0f 93       	push	r16
    1df2:	1f 93       	push	r17
    1df4:	cf 93       	push	r28
    1df6:	df 93       	push	r29
    1df8:	fc 01       	movw	r30, r24
    1dfa:	89 2b       	or	r24, r25
    1dfc:	79 f1       	breq	.+94     	; 0x1e5c <xTaskPriorityDisinherit+0x6c>
    1dfe:	82 a1       	ldd	r24, Z+34	; 0x22
    1e00:	81 50       	subi	r24, 0x01	; 1
    1e02:	82 a3       	std	Z+34, r24	; 0x22
    1e04:	26 89       	ldd	r18, Z+22	; 0x16
    1e06:	91 a1       	ldd	r25, Z+33	; 0x21
    1e08:	29 17       	cp	r18, r25
    1e0a:	51 f1       	breq	.+84     	; 0x1e60 <xTaskPriorityDisinherit+0x70>
    1e0c:	81 11       	cpse	r24, r1
    1e0e:	2a c0       	rjmp	.+84     	; 0x1e64 <xTaskPriorityDisinherit+0x74>
    1e10:	ef 01       	movw	r28, r30
    1e12:	8f 01       	movw	r16, r30
    1e14:	0e 5f       	subi	r16, 0xFE	; 254
    1e16:	1f 4f       	sbci	r17, 0xFF	; 255
    1e18:	c8 01       	movw	r24, r16
    1e1a:	0e 94 07 06 	call	0xc0e	; 0xc0e <uxListRemove>
    1e1e:	89 a1       	ldd	r24, Y+33	; 0x21
    1e20:	8e 8b       	std	Y+22, r24	; 0x16
    1e22:	23 e0       	ldi	r18, 0x03	; 3
    1e24:	30 e0       	ldi	r19, 0x00	; 0
    1e26:	28 1b       	sub	r18, r24
    1e28:	31 09       	sbc	r19, r1
    1e2a:	3d 87       	std	Y+13, r19	; 0x0d
    1e2c:	2c 87       	std	Y+12, r18	; 0x0c
    1e2e:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <uxTopReadyPriority>
    1e32:	98 17       	cp	r25, r24
    1e34:	10 f4       	brcc	.+4      	; 0x1e3a <xTaskPriorityDisinherit+0x4a>
    1e36:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <uxTopReadyPriority>
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	9c 01       	movw	r18, r24
    1e3e:	22 0f       	add	r18, r18
    1e40:	33 1f       	adc	r19, r19
    1e42:	22 0f       	add	r18, r18
    1e44:	33 1f       	adc	r19, r19
    1e46:	22 0f       	add	r18, r18
    1e48:	33 1f       	adc	r19, r19
    1e4a:	82 0f       	add	r24, r18
    1e4c:	93 1f       	adc	r25, r19
    1e4e:	b8 01       	movw	r22, r16
    1e50:	83 5c       	subi	r24, 0xC3	; 195
    1e52:	9a 4f       	sbci	r25, 0xFA	; 250
    1e54:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInsertEnd>
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	05 c0       	rjmp	.+10     	; 0x1e66 <xTaskPriorityDisinherit+0x76>
    1e5c:	80 e0       	ldi	r24, 0x00	; 0
    1e5e:	03 c0       	rjmp	.+6      	; 0x1e66 <xTaskPriorityDisinherit+0x76>
    1e60:	80 e0       	ldi	r24, 0x00	; 0
    1e62:	01 c0       	rjmp	.+2      	; 0x1e66 <xTaskPriorityDisinherit+0x76>
    1e64:	80 e0       	ldi	r24, 0x00	; 0
    1e66:	df 91       	pop	r29
    1e68:	cf 91       	pop	r28
    1e6a:	1f 91       	pop	r17
    1e6c:	0f 91       	pop	r16
    1e6e:	08 95       	ret

00001e70 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1e70:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <pxCurrentTCB>
    1e74:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1e78:	89 2b       	or	r24, r25
    1e7a:	39 f0       	breq	.+14     	; 0x1e8a <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1e7c:	e0 91 58 05 	lds	r30, 0x0558	; 0x800558 <pxCurrentTCB>
    1e80:	f0 91 59 05 	lds	r31, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
    1e84:	82 a1       	ldd	r24, Z+34	; 0x22
    1e86:	8f 5f       	subi	r24, 0xFF	; 255
    1e88:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1e8a:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <pxCurrentTCB>
    1e8e:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <pxCurrentTCB+0x1>
	}
    1e92:	08 95       	ret

00001e94 <TIMER0_voidFastPWM>:
void TIMER0_voidSetCallBack(void(*ptr)(void), u8 copy_u8mode){
	
	switch(copy_u8mode){
		
		case OV_MODE : TIM0_PTR[0]=ptr ; break;
		case CTC_MODE : TIM0_PTR[1]=ptr; break; 
    1e94:	93 b7       	in	r25, 0x33	; 51
    1e96:	98 60       	ori	r25, 0x08	; 8
    1e98:	93 bf       	out	0x33, r25	; 51
    1e9a:	93 b7       	in	r25, 0x33	; 51
    1e9c:	90 64       	ori	r25, 0x40	; 64
    1e9e:	93 bf       	out	0x33, r25	; 51
    1ea0:	93 b7       	in	r25, 0x33	; 51
    1ea2:	90 62       	ori	r25, 0x20	; 32
    1ea4:	93 bf       	out	0x33, r25	; 51
    1ea6:	93 b7       	in	r25, 0x33	; 51
    1ea8:	9f 7e       	andi	r25, 0xEF	; 239
    1eaa:	93 bf       	out	0x33, r25	; 51
    1eac:	93 b7       	in	r25, 0x33	; 51
    1eae:	98 7f       	andi	r25, 0xF8	; 248
    1eb0:	93 bf       	out	0x33, r25	; 51
    1eb2:	93 b7       	in	r25, 0x33	; 51
    1eb4:	93 60       	ori	r25, 0x03	; 3
    1eb6:	93 bf       	out	0x33, r25	; 51
    1eb8:	68 2f       	mov	r22, r24
    1eba:	70 e0       	ldi	r23, 0x00	; 0
    1ebc:	80 e0       	ldi	r24, 0x00	; 0
    1ebe:	90 e0       	ldi	r25, 0x00	; 0
    1ec0:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <__floatsisf>
    1ec4:	2a e0       	ldi	r18, 0x0A	; 10
    1ec6:	37 ed       	ldi	r19, 0xD7	; 215
    1ec8:	43 e2       	ldi	r20, 0x23	; 35
    1eca:	50 e4       	ldi	r21, 0x40	; 64
    1ecc:	0e 94 8c 10 	call	0x2118	; 0x2118 <__mulsf3>
    1ed0:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <__fixunssfsi>
    1ed4:	6c bf       	out	0x3c, r22	; 60
    1ed6:	08 95       	ret

00001ed8 <__vector_11>:
			}
	
}

void __vector_11(void)__attribute__((signal)) ;
void __vector_11(void){
    1ed8:	1f 92       	push	r1
    1eda:	0f 92       	push	r0
    1edc:	0f b6       	in	r0, 0x3f	; 63
    1ede:	0f 92       	push	r0
    1ee0:	11 24       	eor	r1, r1
    1ee2:	2f 93       	push	r18
    1ee4:	3f 93       	push	r19
    1ee6:	4f 93       	push	r20
    1ee8:	5f 93       	push	r21
    1eea:	6f 93       	push	r22
    1eec:	7f 93       	push	r23
    1eee:	8f 93       	push	r24
    1ef0:	9f 93       	push	r25
    1ef2:	af 93       	push	r26
    1ef4:	bf 93       	push	r27
    1ef6:	ef 93       	push	r30
    1ef8:	ff 93       	push	r31
	

TIM0_PTR[0]() ; 
    1efa:	e0 91 5a 05 	lds	r30, 0x055A	; 0x80055a <TIM0_PTR>
    1efe:	f0 91 5b 05 	lds	r31, 0x055B	; 0x80055b <TIM0_PTR+0x1>
    1f02:	09 95       	icall


}
    1f04:	ff 91       	pop	r31
    1f06:	ef 91       	pop	r30
    1f08:	bf 91       	pop	r27
    1f0a:	af 91       	pop	r26
    1f0c:	9f 91       	pop	r25
    1f0e:	8f 91       	pop	r24
    1f10:	7f 91       	pop	r23
    1f12:	6f 91       	pop	r22
    1f14:	5f 91       	pop	r21
    1f16:	4f 91       	pop	r20
    1f18:	3f 91       	pop	r19
    1f1a:	2f 91       	pop	r18
    1f1c:	0f 90       	pop	r0
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	0f 90       	pop	r0
    1f22:	1f 90       	pop	r1
    1f24:	18 95       	reti

00001f26 <__vector_10>:


*/

void __vector_10(void)__attribute__((signal)) ;
void __vector_10(void){
    1f26:	1f 92       	push	r1
    1f28:	0f 92       	push	r0
    1f2a:	0f b6       	in	r0, 0x3f	; 63
    1f2c:	0f 92       	push	r0
    1f2e:	11 24       	eor	r1, r1
    1f30:	2f 93       	push	r18
    1f32:	3f 93       	push	r19
    1f34:	4f 93       	push	r20
    1f36:	5f 93       	push	r21
    1f38:	6f 93       	push	r22
    1f3a:	7f 93       	push	r23
    1f3c:	8f 93       	push	r24
    1f3e:	9f 93       	push	r25
    1f40:	af 93       	push	r26
    1f42:	bf 93       	push	r27
    1f44:	ef 93       	push	r30
    1f46:	ff 93       	push	r31
	

TIM0_PTR[1]() ;
    1f48:	e0 91 5c 05 	lds	r30, 0x055C	; 0x80055c <TIM0_PTR+0x2>
    1f4c:	f0 91 5d 05 	lds	r31, 0x055D	; 0x80055d <TIM0_PTR+0x3>
    1f50:	09 95       	icall

    1f52:	ff 91       	pop	r31
    1f54:	ef 91       	pop	r30
    1f56:	bf 91       	pop	r27
    1f58:	af 91       	pop	r26
    1f5a:	9f 91       	pop	r25
    1f5c:	8f 91       	pop	r24
    1f5e:	7f 91       	pop	r23
    1f60:	6f 91       	pop	r22
    1f62:	5f 91       	pop	r21
    1f64:	4f 91       	pop	r20
    1f66:	3f 91       	pop	r19
    1f68:	2f 91       	pop	r18
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63
    1f6e:	0f 90       	pop	r0
    1f70:	1f 90       	pop	r1
    1f72:	18 95       	reti

00001f74 <UART_voidInit>:
	/* SET DATA */
	UDR_REG=copy_u8data ; 
	while(GET_BIT(UCSRA_REG,5)==0) ; 
	
	
}
    1f74:	86 e8       	ldi	r24, 0x86	; 134
    1f76:	80 bd       	out	0x20, r24	; 32
    1f78:	87 e6       	ldi	r24, 0x67	; 103
    1f7a:	89 b9       	out	0x09, r24	; 9
    1f7c:	8a b1       	in	r24, 0x0a	; 10
    1f7e:	88 60       	ori	r24, 0x08	; 8
    1f80:	8a b9       	out	0x0a, r24	; 10
    1f82:	8a b1       	in	r24, 0x0a	; 10
    1f84:	80 61       	ori	r24, 0x10	; 16
    1f86:	8a b9       	out	0x0a, r24	; 10
    1f88:	08 95       	ret

00001f8a <UART_u8RX>:
u8 UART_u8RX(void) {
	
	while(GET_BIT(UCSRA_REG,7)==0) ; 
    1f8a:	5f 9b       	sbis	0x0b, 7	; 11
    1f8c:	fe cf       	rjmp	.-4      	; 0x1f8a <UART_u8RX>
	
	return UDR_REG ;  // RETURN VALUE 
    1f8e:	8c b1       	in	r24, 0x0c	; 12
    1f90:	08 95       	ret

00001f92 <__cmpsf2>:
    1f92:	0e 94 3a 10 	call	0x2074	; 0x2074 <__fp_cmp>
    1f96:	08 f4       	brcc	.+2      	; 0x1f9a <__cmpsf2+0x8>
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	08 95       	ret

00001f9c <__fixunssfsi>:
    1f9c:	0e 94 66 10 	call	0x20cc	; 0x20cc <__fp_splitA>
    1fa0:	88 f0       	brcs	.+34     	; 0x1fc4 <__fixunssfsi+0x28>
    1fa2:	9f 57       	subi	r25, 0x7F	; 127
    1fa4:	98 f0       	brcs	.+38     	; 0x1fcc <__fixunssfsi+0x30>
    1fa6:	b9 2f       	mov	r27, r25
    1fa8:	99 27       	eor	r25, r25
    1faa:	b7 51       	subi	r27, 0x17	; 23
    1fac:	b0 f0       	brcs	.+44     	; 0x1fda <__fixunssfsi+0x3e>
    1fae:	e1 f0       	breq	.+56     	; 0x1fe8 <__fixunssfsi+0x4c>
    1fb0:	66 0f       	add	r22, r22
    1fb2:	77 1f       	adc	r23, r23
    1fb4:	88 1f       	adc	r24, r24
    1fb6:	99 1f       	adc	r25, r25
    1fb8:	1a f0       	brmi	.+6      	; 0x1fc0 <__fixunssfsi+0x24>
    1fba:	ba 95       	dec	r27
    1fbc:	c9 f7       	brne	.-14     	; 0x1fb0 <__fixunssfsi+0x14>
    1fbe:	14 c0       	rjmp	.+40     	; 0x1fe8 <__fixunssfsi+0x4c>
    1fc0:	b1 30       	cpi	r27, 0x01	; 1
    1fc2:	91 f0       	breq	.+36     	; 0x1fe8 <__fixunssfsi+0x4c>
    1fc4:	0e 94 80 10 	call	0x2100	; 0x2100 <__fp_zero>
    1fc8:	b1 e0       	ldi	r27, 0x01	; 1
    1fca:	08 95       	ret
    1fcc:	0c 94 80 10 	jmp	0x2100	; 0x2100 <__fp_zero>
    1fd0:	67 2f       	mov	r22, r23
    1fd2:	78 2f       	mov	r23, r24
    1fd4:	88 27       	eor	r24, r24
    1fd6:	b8 5f       	subi	r27, 0xF8	; 248
    1fd8:	39 f0       	breq	.+14     	; 0x1fe8 <__fixunssfsi+0x4c>
    1fda:	b9 3f       	cpi	r27, 0xF9	; 249
    1fdc:	cc f3       	brlt	.-14     	; 0x1fd0 <__fixunssfsi+0x34>
    1fde:	86 95       	lsr	r24
    1fe0:	77 95       	ror	r23
    1fe2:	67 95       	ror	r22
    1fe4:	b3 95       	inc	r27
    1fe6:	d9 f7       	brne	.-10     	; 0x1fde <__fixunssfsi+0x42>
    1fe8:	3e f4       	brtc	.+14     	; 0x1ff8 <__fixunssfsi+0x5c>
    1fea:	90 95       	com	r25
    1fec:	80 95       	com	r24
    1fee:	70 95       	com	r23
    1ff0:	61 95       	neg	r22
    1ff2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff4:	8f 4f       	sbci	r24, 0xFF	; 255
    1ff6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ff8:	08 95       	ret

00001ffa <__floatunsisf>:
    1ffa:	e8 94       	clt
    1ffc:	09 c0       	rjmp	.+18     	; 0x2010 <__floatsisf+0x12>

00001ffe <__floatsisf>:
    1ffe:	97 fb       	bst	r25, 7
    2000:	3e f4       	brtc	.+14     	; 0x2010 <__floatsisf+0x12>
    2002:	90 95       	com	r25
    2004:	80 95       	com	r24
    2006:	70 95       	com	r23
    2008:	61 95       	neg	r22
    200a:	7f 4f       	sbci	r23, 0xFF	; 255
    200c:	8f 4f       	sbci	r24, 0xFF	; 255
    200e:	9f 4f       	sbci	r25, 0xFF	; 255
    2010:	99 23       	and	r25, r25
    2012:	a9 f0       	breq	.+42     	; 0x203e <__floatsisf+0x40>
    2014:	f9 2f       	mov	r31, r25
    2016:	96 e9       	ldi	r25, 0x96	; 150
    2018:	bb 27       	eor	r27, r27
    201a:	93 95       	inc	r25
    201c:	f6 95       	lsr	r31
    201e:	87 95       	ror	r24
    2020:	77 95       	ror	r23
    2022:	67 95       	ror	r22
    2024:	b7 95       	ror	r27
    2026:	f1 11       	cpse	r31, r1
    2028:	f8 cf       	rjmp	.-16     	; 0x201a <__floatsisf+0x1c>
    202a:	fa f4       	brpl	.+62     	; 0x206a <__floatsisf+0x6c>
    202c:	bb 0f       	add	r27, r27
    202e:	11 f4       	brne	.+4      	; 0x2034 <__floatsisf+0x36>
    2030:	60 ff       	sbrs	r22, 0
    2032:	1b c0       	rjmp	.+54     	; 0x206a <__floatsisf+0x6c>
    2034:	6f 5f       	subi	r22, 0xFF	; 255
    2036:	7f 4f       	sbci	r23, 0xFF	; 255
    2038:	8f 4f       	sbci	r24, 0xFF	; 255
    203a:	9f 4f       	sbci	r25, 0xFF	; 255
    203c:	16 c0       	rjmp	.+44     	; 0x206a <__floatsisf+0x6c>
    203e:	88 23       	and	r24, r24
    2040:	11 f0       	breq	.+4      	; 0x2046 <__floatsisf+0x48>
    2042:	96 e9       	ldi	r25, 0x96	; 150
    2044:	11 c0       	rjmp	.+34     	; 0x2068 <__floatsisf+0x6a>
    2046:	77 23       	and	r23, r23
    2048:	21 f0       	breq	.+8      	; 0x2052 <__floatsisf+0x54>
    204a:	9e e8       	ldi	r25, 0x8E	; 142
    204c:	87 2f       	mov	r24, r23
    204e:	76 2f       	mov	r23, r22
    2050:	05 c0       	rjmp	.+10     	; 0x205c <__floatsisf+0x5e>
    2052:	66 23       	and	r22, r22
    2054:	71 f0       	breq	.+28     	; 0x2072 <__floatsisf+0x74>
    2056:	96 e8       	ldi	r25, 0x86	; 134
    2058:	86 2f       	mov	r24, r22
    205a:	70 e0       	ldi	r23, 0x00	; 0
    205c:	60 e0       	ldi	r22, 0x00	; 0
    205e:	2a f0       	brmi	.+10     	; 0x206a <__floatsisf+0x6c>
    2060:	9a 95       	dec	r25
    2062:	66 0f       	add	r22, r22
    2064:	77 1f       	adc	r23, r23
    2066:	88 1f       	adc	r24, r24
    2068:	da f7       	brpl	.-10     	; 0x2060 <__floatsisf+0x62>
    206a:	88 0f       	add	r24, r24
    206c:	96 95       	lsr	r25
    206e:	87 95       	ror	r24
    2070:	97 f9       	bld	r25, 7
    2072:	08 95       	ret

00002074 <__fp_cmp>:
    2074:	99 0f       	add	r25, r25
    2076:	00 08       	sbc	r0, r0
    2078:	55 0f       	add	r21, r21
    207a:	aa 0b       	sbc	r26, r26
    207c:	e0 e8       	ldi	r30, 0x80	; 128
    207e:	fe ef       	ldi	r31, 0xFE	; 254
    2080:	16 16       	cp	r1, r22
    2082:	17 06       	cpc	r1, r23
    2084:	e8 07       	cpc	r30, r24
    2086:	f9 07       	cpc	r31, r25
    2088:	c0 f0       	brcs	.+48     	; 0x20ba <__fp_cmp+0x46>
    208a:	12 16       	cp	r1, r18
    208c:	13 06       	cpc	r1, r19
    208e:	e4 07       	cpc	r30, r20
    2090:	f5 07       	cpc	r31, r21
    2092:	98 f0       	brcs	.+38     	; 0x20ba <__fp_cmp+0x46>
    2094:	62 1b       	sub	r22, r18
    2096:	73 0b       	sbc	r23, r19
    2098:	84 0b       	sbc	r24, r20
    209a:	95 0b       	sbc	r25, r21
    209c:	39 f4       	brne	.+14     	; 0x20ac <__fp_cmp+0x38>
    209e:	0a 26       	eor	r0, r26
    20a0:	61 f0       	breq	.+24     	; 0x20ba <__fp_cmp+0x46>
    20a2:	23 2b       	or	r18, r19
    20a4:	24 2b       	or	r18, r20
    20a6:	25 2b       	or	r18, r21
    20a8:	21 f4       	brne	.+8      	; 0x20b2 <__fp_cmp+0x3e>
    20aa:	08 95       	ret
    20ac:	0a 26       	eor	r0, r26
    20ae:	09 f4       	brne	.+2      	; 0x20b2 <__fp_cmp+0x3e>
    20b0:	a1 40       	sbci	r26, 0x01	; 1
    20b2:	a6 95       	lsr	r26
    20b4:	8f ef       	ldi	r24, 0xFF	; 255
    20b6:	81 1d       	adc	r24, r1
    20b8:	81 1d       	adc	r24, r1
    20ba:	08 95       	ret

000020bc <__fp_split3>:
    20bc:	57 fd       	sbrc	r21, 7
    20be:	90 58       	subi	r25, 0x80	; 128
    20c0:	44 0f       	add	r20, r20
    20c2:	55 1f       	adc	r21, r21
    20c4:	59 f0       	breq	.+22     	; 0x20dc <__fp_splitA+0x10>
    20c6:	5f 3f       	cpi	r21, 0xFF	; 255
    20c8:	71 f0       	breq	.+28     	; 0x20e6 <__fp_splitA+0x1a>
    20ca:	47 95       	ror	r20

000020cc <__fp_splitA>:
    20cc:	88 0f       	add	r24, r24
    20ce:	97 fb       	bst	r25, 7
    20d0:	99 1f       	adc	r25, r25
    20d2:	61 f0       	breq	.+24     	; 0x20ec <__fp_splitA+0x20>
    20d4:	9f 3f       	cpi	r25, 0xFF	; 255
    20d6:	79 f0       	breq	.+30     	; 0x20f6 <__fp_splitA+0x2a>
    20d8:	87 95       	ror	r24
    20da:	08 95       	ret
    20dc:	12 16       	cp	r1, r18
    20de:	13 06       	cpc	r1, r19
    20e0:	14 06       	cpc	r1, r20
    20e2:	55 1f       	adc	r21, r21
    20e4:	f2 cf       	rjmp	.-28     	; 0x20ca <__fp_split3+0xe>
    20e6:	46 95       	lsr	r20
    20e8:	f1 df       	rcall	.-30     	; 0x20cc <__fp_splitA>
    20ea:	08 c0       	rjmp	.+16     	; 0x20fc <__fp_splitA+0x30>
    20ec:	16 16       	cp	r1, r22
    20ee:	17 06       	cpc	r1, r23
    20f0:	18 06       	cpc	r1, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	f1 cf       	rjmp	.-30     	; 0x20d8 <__fp_splitA+0xc>
    20f6:	86 95       	lsr	r24
    20f8:	71 05       	cpc	r23, r1
    20fa:	61 05       	cpc	r22, r1
    20fc:	08 94       	sec
    20fe:	08 95       	ret

00002100 <__fp_zero>:
    2100:	e8 94       	clt

00002102 <__fp_szero>:
    2102:	bb 27       	eor	r27, r27
    2104:	66 27       	eor	r22, r22
    2106:	77 27       	eor	r23, r23
    2108:	cb 01       	movw	r24, r22
    210a:	97 f9       	bld	r25, 7
    210c:	08 95       	ret

0000210e <__gesf2>:
    210e:	0e 94 3a 10 	call	0x2074	; 0x2074 <__fp_cmp>
    2112:	08 f4       	brcc	.+2      	; 0x2116 <__gesf2+0x8>
    2114:	8f ef       	ldi	r24, 0xFF	; 255
    2116:	08 95       	ret

00002118 <__mulsf3>:
    2118:	0e 94 9f 10 	call	0x213e	; 0x213e <__mulsf3x>
    211c:	0c 94 10 11 	jmp	0x2220	; 0x2220 <__fp_round>
    2120:	0e 94 02 11 	call	0x2204	; 0x2204 <__fp_pscA>
    2124:	38 f0       	brcs	.+14     	; 0x2134 <__mulsf3+0x1c>
    2126:	0e 94 09 11 	call	0x2212	; 0x2212 <__fp_pscB>
    212a:	20 f0       	brcs	.+8      	; 0x2134 <__mulsf3+0x1c>
    212c:	95 23       	and	r25, r21
    212e:	11 f0       	breq	.+4      	; 0x2134 <__mulsf3+0x1c>
    2130:	0c 94 f9 10 	jmp	0x21f2	; 0x21f2 <__fp_inf>
    2134:	0c 94 ff 10 	jmp	0x21fe	; 0x21fe <__fp_nan>
    2138:	11 24       	eor	r1, r1
    213a:	0c 94 81 10 	jmp	0x2102	; 0x2102 <__fp_szero>

0000213e <__mulsf3x>:
    213e:	0e 94 5e 10 	call	0x20bc	; 0x20bc <__fp_split3>
    2142:	70 f3       	brcs	.-36     	; 0x2120 <__mulsf3+0x8>

00002144 <__mulsf3_pse>:
    2144:	95 9f       	mul	r25, r21
    2146:	c1 f3       	breq	.-16     	; 0x2138 <__mulsf3+0x20>
    2148:	95 0f       	add	r25, r21
    214a:	50 e0       	ldi	r21, 0x00	; 0
    214c:	55 1f       	adc	r21, r21
    214e:	62 9f       	mul	r22, r18
    2150:	f0 01       	movw	r30, r0
    2152:	72 9f       	mul	r23, r18
    2154:	bb 27       	eor	r27, r27
    2156:	f0 0d       	add	r31, r0
    2158:	b1 1d       	adc	r27, r1
    215a:	63 9f       	mul	r22, r19
    215c:	aa 27       	eor	r26, r26
    215e:	f0 0d       	add	r31, r0
    2160:	b1 1d       	adc	r27, r1
    2162:	aa 1f       	adc	r26, r26
    2164:	64 9f       	mul	r22, r20
    2166:	66 27       	eor	r22, r22
    2168:	b0 0d       	add	r27, r0
    216a:	a1 1d       	adc	r26, r1
    216c:	66 1f       	adc	r22, r22
    216e:	82 9f       	mul	r24, r18
    2170:	22 27       	eor	r18, r18
    2172:	b0 0d       	add	r27, r0
    2174:	a1 1d       	adc	r26, r1
    2176:	62 1f       	adc	r22, r18
    2178:	73 9f       	mul	r23, r19
    217a:	b0 0d       	add	r27, r0
    217c:	a1 1d       	adc	r26, r1
    217e:	62 1f       	adc	r22, r18
    2180:	83 9f       	mul	r24, r19
    2182:	a0 0d       	add	r26, r0
    2184:	61 1d       	adc	r22, r1
    2186:	22 1f       	adc	r18, r18
    2188:	74 9f       	mul	r23, r20
    218a:	33 27       	eor	r19, r19
    218c:	a0 0d       	add	r26, r0
    218e:	61 1d       	adc	r22, r1
    2190:	23 1f       	adc	r18, r19
    2192:	84 9f       	mul	r24, r20
    2194:	60 0d       	add	r22, r0
    2196:	21 1d       	adc	r18, r1
    2198:	82 2f       	mov	r24, r18
    219a:	76 2f       	mov	r23, r22
    219c:	6a 2f       	mov	r22, r26
    219e:	11 24       	eor	r1, r1
    21a0:	9f 57       	subi	r25, 0x7F	; 127
    21a2:	50 40       	sbci	r21, 0x00	; 0
    21a4:	9a f0       	brmi	.+38     	; 0x21cc <__mulsf3_pse+0x88>
    21a6:	f1 f0       	breq	.+60     	; 0x21e4 <__mulsf3_pse+0xa0>
    21a8:	88 23       	and	r24, r24
    21aa:	4a f0       	brmi	.+18     	; 0x21be <__mulsf3_pse+0x7a>
    21ac:	ee 0f       	add	r30, r30
    21ae:	ff 1f       	adc	r31, r31
    21b0:	bb 1f       	adc	r27, r27
    21b2:	66 1f       	adc	r22, r22
    21b4:	77 1f       	adc	r23, r23
    21b6:	88 1f       	adc	r24, r24
    21b8:	91 50       	subi	r25, 0x01	; 1
    21ba:	50 40       	sbci	r21, 0x00	; 0
    21bc:	a9 f7       	brne	.-22     	; 0x21a8 <__mulsf3_pse+0x64>
    21be:	9e 3f       	cpi	r25, 0xFE	; 254
    21c0:	51 05       	cpc	r21, r1
    21c2:	80 f0       	brcs	.+32     	; 0x21e4 <__mulsf3_pse+0xa0>
    21c4:	0c 94 f9 10 	jmp	0x21f2	; 0x21f2 <__fp_inf>
    21c8:	0c 94 81 10 	jmp	0x2102	; 0x2102 <__fp_szero>
    21cc:	5f 3f       	cpi	r21, 0xFF	; 255
    21ce:	e4 f3       	brlt	.-8      	; 0x21c8 <__mulsf3_pse+0x84>
    21d0:	98 3e       	cpi	r25, 0xE8	; 232
    21d2:	d4 f3       	brlt	.-12     	; 0x21c8 <__mulsf3_pse+0x84>
    21d4:	86 95       	lsr	r24
    21d6:	77 95       	ror	r23
    21d8:	67 95       	ror	r22
    21da:	b7 95       	ror	r27
    21dc:	f7 95       	ror	r31
    21de:	e7 95       	ror	r30
    21e0:	9f 5f       	subi	r25, 0xFF	; 255
    21e2:	c1 f7       	brne	.-16     	; 0x21d4 <__mulsf3_pse+0x90>
    21e4:	fe 2b       	or	r31, r30
    21e6:	88 0f       	add	r24, r24
    21e8:	91 1d       	adc	r25, r1
    21ea:	96 95       	lsr	r25
    21ec:	87 95       	ror	r24
    21ee:	97 f9       	bld	r25, 7
    21f0:	08 95       	ret

000021f2 <__fp_inf>:
    21f2:	97 f9       	bld	r25, 7
    21f4:	9f 67       	ori	r25, 0x7F	; 127
    21f6:	80 e8       	ldi	r24, 0x80	; 128
    21f8:	70 e0       	ldi	r23, 0x00	; 0
    21fa:	60 e0       	ldi	r22, 0x00	; 0
    21fc:	08 95       	ret

000021fe <__fp_nan>:
    21fe:	9f ef       	ldi	r25, 0xFF	; 255
    2200:	80 ec       	ldi	r24, 0xC0	; 192
    2202:	08 95       	ret

00002204 <__fp_pscA>:
    2204:	00 24       	eor	r0, r0
    2206:	0a 94       	dec	r0
    2208:	16 16       	cp	r1, r22
    220a:	17 06       	cpc	r1, r23
    220c:	18 06       	cpc	r1, r24
    220e:	09 06       	cpc	r0, r25
    2210:	08 95       	ret

00002212 <__fp_pscB>:
    2212:	00 24       	eor	r0, r0
    2214:	0a 94       	dec	r0
    2216:	12 16       	cp	r1, r18
    2218:	13 06       	cpc	r1, r19
    221a:	14 06       	cpc	r1, r20
    221c:	05 06       	cpc	r0, r21
    221e:	08 95       	ret

00002220 <__fp_round>:
    2220:	09 2e       	mov	r0, r25
    2222:	03 94       	inc	r0
    2224:	00 0c       	add	r0, r0
    2226:	11 f4       	brne	.+4      	; 0x222c <__fp_round+0xc>
    2228:	88 23       	and	r24, r24
    222a:	52 f0       	brmi	.+20     	; 0x2240 <__fp_round+0x20>
    222c:	bb 0f       	add	r27, r27
    222e:	40 f4       	brcc	.+16     	; 0x2240 <__fp_round+0x20>
    2230:	bf 2b       	or	r27, r31
    2232:	11 f4       	brne	.+4      	; 0x2238 <__fp_round+0x18>
    2234:	60 ff       	sbrs	r22, 0
    2236:	04 c0       	rjmp	.+8      	; 0x2240 <__fp_round+0x20>
    2238:	6f 5f       	subi	r22, 0xFF	; 255
    223a:	7f 4f       	sbci	r23, 0xFF	; 255
    223c:	8f 4f       	sbci	r24, 0xFF	; 255
    223e:	9f 4f       	sbci	r25, 0xFF	; 255
    2240:	08 95       	ret

00002242 <__udivmodsi4>:
    2242:	a1 e2       	ldi	r26, 0x21	; 33
    2244:	1a 2e       	mov	r1, r26
    2246:	aa 1b       	sub	r26, r26
    2248:	bb 1b       	sub	r27, r27
    224a:	fd 01       	movw	r30, r26
    224c:	0d c0       	rjmp	.+26     	; 0x2268 <__udivmodsi4_ep>

0000224e <__udivmodsi4_loop>:
    224e:	aa 1f       	adc	r26, r26
    2250:	bb 1f       	adc	r27, r27
    2252:	ee 1f       	adc	r30, r30
    2254:	ff 1f       	adc	r31, r31
    2256:	a2 17       	cp	r26, r18
    2258:	b3 07       	cpc	r27, r19
    225a:	e4 07       	cpc	r30, r20
    225c:	f5 07       	cpc	r31, r21
    225e:	20 f0       	brcs	.+8      	; 0x2268 <__udivmodsi4_ep>
    2260:	a2 1b       	sub	r26, r18
    2262:	b3 0b       	sbc	r27, r19
    2264:	e4 0b       	sbc	r30, r20
    2266:	f5 0b       	sbc	r31, r21

00002268 <__udivmodsi4_ep>:
    2268:	66 1f       	adc	r22, r22
    226a:	77 1f       	adc	r23, r23
    226c:	88 1f       	adc	r24, r24
    226e:	99 1f       	adc	r25, r25
    2270:	1a 94       	dec	r1
    2272:	69 f7       	brne	.-38     	; 0x224e <__udivmodsi4_loop>
    2274:	60 95       	com	r22
    2276:	70 95       	com	r23
    2278:	80 95       	com	r24
    227a:	90 95       	com	r25
    227c:	9b 01       	movw	r18, r22
    227e:	ac 01       	movw	r20, r24
    2280:	bd 01       	movw	r22, r26
    2282:	cf 01       	movw	r24, r30
    2284:	08 95       	ret

00002286 <memcpy>:
    2286:	fb 01       	movw	r30, r22
    2288:	dc 01       	movw	r26, r24
    228a:	02 c0       	rjmp	.+4      	; 0x2290 <memcpy+0xa>
    228c:	01 90       	ld	r0, Z+
    228e:	0d 92       	st	X+, r0
    2290:	41 50       	subi	r20, 0x01	; 1
    2292:	50 40       	sbci	r21, 0x00	; 0
    2294:	d8 f7       	brcc	.-10     	; 0x228c <memcpy+0x6>
    2296:	08 95       	ret

00002298 <_exit>:
    2298:	f8 94       	cli

0000229a <__stop_program>:
    229a:	ff cf       	rjmp	.-2      	; 0x229a <__stop_program>
