
Password.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000dc2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d0  00800060  00000dc2  00000e56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00800130  00800130  00000f26  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000f26  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000f58  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000160  00000000  00000000  00000f94  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001980  00000000  00000000  000010f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a6e  00000000  00000000  00002a74  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e76  00000000  00000000  000034e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003a8  00000000  00000000  00004358  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000696  00000000  00000000  00004700  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000117e  00000000  00000000  00004d96  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00005f14  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 3e 05 	jmp	0xa7c	; 0xa7c <__vector_10>
  2c:	0c 94 17 05 	jmp	0xa2e	; 0xa2e <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 ec       	ldi	r30, 0xC2	; 194
  68:	fd e0       	ldi	r31, 0x0D	; 13
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a0 33       	cpi	r26, 0x30	; 48
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	a0 e3       	ldi	r26, 0x30	; 48
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 33       	cpi	r26, 0x34	; 52
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 49 00 	call	0x92	; 0x92 <main>
  8a:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
#define F_CPU 16000000UL
#include <util/delay.h>
/***** Includes Section End *****/

int main(void)
{
  92:	af 92       	push	r10
  94:	bf 92       	push	r11
  96:	cf 92       	push	r12
  98:	df 92       	push	r13
  9a:	ef 92       	push	r14
  9c:	ff 92       	push	r15
  9e:	0f 93       	push	r16
  a0:	1f 93       	push	r17
  a2:	cf 93       	push	r28
  a4:	df 93       	push	r29
	u16 val = 0;														// To read value of pin of ADC
	f32 temp = 0;														// Temperature of LM35
	u32 password = 0;													// password from the user
	u8 dc = 0;															// Duty Cycle
	
	DIO_voidSetPortDir(DIO_PORTA , 0xf0);								// set direction of PORTA as output
  a6:	60 ef       	ldi	r22, 0xF0	; 240
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	0e 94 e5 04 	call	0x9ca	; 0x9ca <DIO_voidSetPortDir>
	DIO_voidSetPortDir(DIO_PORTB , 0xff);								// set direction of PORTC as output
  ae:	6f ef       	ldi	r22, 0xFF	; 255
  b0:	81 e0       	ldi	r24, 0x01	; 1
  b2:	0e 94 e5 04 	call	0x9ca	; 0x9ca <DIO_voidSetPortDir>
	LCD_voidInit();														// activate LCD
  b6:	0e 94 2c 03 	call	0x658	; 0x658 <LCD_voidInit>
	KEYPAD_voidInit();													// activate KEYPAD
  ba:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <KEYPAD_voidInit>
	ADC_voidInit();														// activate ADC
  be:	0e 94 b0 03 	call	0x760	; 0x760 <ADC_voidInit>
int main(void)
{
	
	u8 op1 , op2 , op3 , op4;											// operators of password
	u8 counter1 = 0 , counter2 = 0;										// counter1 for loops and counter2 for the wrong password
	u8 flag = 0 , key = 0 , No_Of_Digits = 0;												// flag to check the password and active ADC for temperature
  c2:	d1 2c       	mov	r13, r1

int main(void)
{
	
	u8 op1 , op2 , op3 , op4;											// operators of password
	u8 counter1 = 0 , counter2 = 0;										// counter1 for loops and counter2 for the wrong password
  c4:	10 e0       	ldi	r17, 0x00	; 0
  c6:	d2 c0       	rjmp	.+420    	; 0x26c <main+0x1da>
	ADC_voidInit();														// activate ADC
	while(1)
	{
		while (counter2 < 3)											// Three chances for the user to enter the correct password
		{
			LCD_voidSendString("Enter password : ");					// Asking the user to enter the password
  c8:	80 e7       	ldi	r24, 0x70	; 112
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
			
			key = ReturnKey_void();										// Reading keypad if any button is pressed
  d0:	0e 94 b0 02 	call	0x560	; 0x560 <ReturnKey_void>
  d4:	d8 2f       	mov	r29, r24
			
			/* This loop below is implemented for security as if who enters the password isn't the user so he don't know the
			real numbers of password so every number he will press in keypad , it will be printed on lcd as number of numbers of password */
			
			while (key != '=')											// Loop to get the password in its operators
  d6:	c0 e0       	ldi	r28, 0x00	; 0
  d8:	2d c0       	rjmp	.+90     	; 0x134 <main+0xa2>
			{
				
				LCD_voidGotoxy(counter1,1);								// location of each number in keypad in serial
  da:	61 e0       	ldi	r22, 0x01	; 1
  dc:	8c 2f       	mov	r24, r28
  de:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
				LCD_voidSendNumber(key);								// printing the number which is pressed in the keypad
  e2:	6d 2f       	mov	r22, r29
  e4:	70 e0       	ldi	r23, 0x00	; 0
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	0e 94 66 03 	call	0x6cc	; 0x6cc <LCD_voidSendNumber>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  ee:	2f ef       	ldi	r18, 0xFF	; 255
  f0:	83 ec       	ldi	r24, 0xC3	; 195
  f2:	99 e0       	ldi	r25, 0x09	; 9
  f4:	21 50       	subi	r18, 0x01	; 1
  f6:	80 40       	sbci	r24, 0x00	; 0
  f8:	90 40       	sbci	r25, 0x00	; 0
  fa:	e1 f7       	brne	.-8      	; 0xf4 <main+0x62>
  fc:	00 c0       	rjmp	.+0      	; 0xfe <main+0x6c>
  fe:	00 00       	nop
				_delay_ms(200);											// delay to print * instead of the number for security
				LCD_voidGotoxy(counter1,1);								// same location of the number
 100:	61 e0       	ldi	r22, 0x01	; 1
 102:	8c 2f       	mov	r24, r28
 104:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
				LCD_voidSendData('*');									// printing * in lcd
 108:	8a e2       	ldi	r24, 0x2A	; 42
 10a:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <LCD_voidSendData>
				switch (counter1)										// check counter1 to put the password in its operators
 10e:	c1 30       	cpi	r28, 0x01	; 1
 110:	31 f0       	breq	.+12     	; 0x11e <main+0x8c>
 112:	58 f0       	brcs	.+22     	; 0x12a <main+0x98>
 114:	c2 30       	cpi	r28, 0x02	; 2
 116:	29 f0       	breq	.+10     	; 0x122 <main+0x90>
 118:	c3 30       	cpi	r28, 0x03	; 3
 11a:	29 f0       	breq	.+10     	; 0x126 <main+0x94>
 11c:	07 c0       	rjmp	.+14     	; 0x12c <main+0x9a>
				{
					case 0 :      op1 = key;			break;			// 1st number of password
					case 1 :      op2 = key;			break;			// 2nd number of password
 11e:	0d 2f       	mov	r16, r29
 120:	05 c0       	rjmp	.+10     	; 0x12c <main+0x9a>
					case 2 :      op3 = key;			break;			// 3rd number of password
 122:	bd 2e       	mov	r11, r29
 124:	03 c0       	rjmp	.+6      	; 0x12c <main+0x9a>
					case 3 :      op4 = key;			break;			// 4th number of password
 126:	ad 2e       	mov	r10, r29
 128:	01 c0       	rjmp	.+2      	; 0x12c <main+0x9a>
				_delay_ms(200);											// delay to print * instead of the number for security
				LCD_voidGotoxy(counter1,1);								// same location of the number
				LCD_voidSendData('*');									// printing * in lcd
				switch (counter1)										// check counter1 to put the password in its operators
				{
					case 0 :      op1 = key;			break;			// 1st number of password
 12a:	cd 2e       	mov	r12, r29
					case 1 :      op2 = key;			break;			// 2nd number of password
					case 2 :      op3 = key;			break;			// 3rd number of password
					case 3 :      op4 = key;			break;			// 4th number of password
				}
				counter1++;												// increasing the counter to continue the loop
 12c:	cf 5f       	subi	r28, 0xFF	; 255
				key = ReturnKey_void();									// reading another value from keypad
 12e:	0e 94 b0 02 	call	0x560	; 0x560 <ReturnKey_void>
 132:	d8 2f       	mov	r29, r24
			key = ReturnKey_void();										// Reading keypad if any button is pressed
			
			/* This loop below is implemented for security as if who enters the password isn't the user so he don't know the
			real numbers of password so every number he will press in keypad , it will be printed on lcd as number of numbers of password */
			
			while (key != '=')											// Loop to get the password in its operators
 134:	dd 33       	cpi	r29, 0x3D	; 61
 136:	89 f6       	brne	.-94     	; 0xda <main+0x48>
				counter1++;												// increasing the counter to continue the loop
				key = ReturnKey_void();									// reading another value from keypad
				
			}
			
			password = op1 * 1000 + op2 * 100 + op3 * 10 + op4;			// create digits of password
 138:	88 ee       	ldi	r24, 0xE8	; 232
 13a:	93 e0       	ldi	r25, 0x03	; 3
 13c:	c8 9e       	mul	r12, r24
 13e:	70 01       	movw	r14, r0
 140:	c9 9e       	mul	r12, r25
 142:	f0 0c       	add	r15, r0
 144:	11 24       	eor	r1, r1
 146:	24 e6       	ldi	r18, 0x64	; 100
 148:	02 9f       	mul	r16, r18
 14a:	e0 0c       	add	r14, r0
 14c:	f1 1c       	adc	r15, r1
 14e:	11 24       	eor	r1, r1
 150:	8b 2d       	mov	r24, r11
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	9c 01       	movw	r18, r24
 156:	22 0f       	add	r18, r18
 158:	33 1f       	adc	r19, r19
 15a:	88 0f       	add	r24, r24
 15c:	99 1f       	adc	r25, r25
 15e:	88 0f       	add	r24, r24
 160:	99 1f       	adc	r25, r25
 162:	88 0f       	add	r24, r24
 164:	99 1f       	adc	r25, r25
 166:	82 0f       	add	r24, r18
 168:	93 1f       	adc	r25, r19
 16a:	e8 0e       	add	r14, r24
 16c:	f9 1e       	adc	r15, r25
 16e:	ea 0c       	add	r14, r10
 170:	f1 1c       	adc	r15, r1
			
			
			if (key = '=')												// condition if the user ends from entering the password
			{
				
				LCD_voidSendCommand(1);									// clear lcd
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
				LCD_voidSendString("Please wait");						// waiting to check the password (It's your choice to make it or not)
 178:	82 e8       	ldi	r24, 0x82	; 130
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
				
				/* loop to print (.) in serial for waiting */
				for (counter1 = 0 ; counter1 < 10 ; counter1++)			
 180:	d0 e0       	ldi	r29, 0x00	; 0
 182:	11 c0       	rjmp	.+34     	; 0x1a6 <main+0x114>
				{
					LCD_voidGotoxy(counter1,1);
 184:	61 e0       	ldi	r22, 0x01	; 1
 186:	8d 2f       	mov	r24, r29
 188:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
					LCD_voidSendData('.');
 18c:	8e e2       	ldi	r24, 0x2E	; 46
 18e:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <LCD_voidSendData>
 192:	8f ef       	ldi	r24, 0xFF	; 255
 194:	91 ee       	ldi	r25, 0xE1	; 225
 196:	24 e0       	ldi	r18, 0x04	; 4
 198:	81 50       	subi	r24, 0x01	; 1
 19a:	90 40       	sbci	r25, 0x00	; 0
 19c:	20 40       	sbci	r18, 0x00	; 0
 19e:	e1 f7       	brne	.-8      	; 0x198 <main+0x106>
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <main+0x110>
 1a2:	00 00       	nop
				
				LCD_voidSendCommand(1);									// clear lcd
				LCD_voidSendString("Please wait");						// waiting to check the password (It's your choice to make it or not)
				
				/* loop to print (.) in serial for waiting */
				for (counter1 = 0 ; counter1 < 10 ; counter1++)			
 1a4:	df 5f       	subi	r29, 0xFF	; 255
 1a6:	da 30       	cpi	r29, 0x0A	; 10
 1a8:	68 f3       	brcs	.-38     	; 0x184 <main+0xf2>
					_delay_ms(100);
				}
			}
			counter1 = 0;												// reset the counter to place the password in lcd in location 0					

			LCD_voidSendCommand(1);										// clear lcd
 1aa:	81 e0       	ldi	r24, 0x01	; 1
 1ac:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
			if ((password == 1234) && (No_Of_Digits < 5))				// condition of checking the password
 1b0:	82 ed       	ldi	r24, 0xD2	; 210
 1b2:	e8 16       	cp	r14, r24
 1b4:	84 e0       	ldi	r24, 0x04	; 4
 1b6:	f8 06       	cpc	r15, r24
 1b8:	41 f5       	brne	.+80     	; 0x20a <main+0x178>
 1ba:	c5 30       	cpi	r28, 0x05	; 5
 1bc:	30 f5       	brcc	.+76     	; 0x20a <main+0x178>
			{					
				LCD_voidSendString("Correct Password.");				// print correct password on lcd
 1be:	8e e8       	ldi	r24, 0x8E	; 142
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
				DIO_voidSetPinVal(DIO_PORTB , DIO_PIN7 , HIGH);			// emitting the green led
 1c6:	41 e0       	ldi	r20, 0x01	; 1
 1c8:	67 e0       	ldi	r22, 0x07	; 7
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 1d0:	9f ef       	ldi	r25, 0xFF	; 255
 1d2:	23 ed       	ldi	r18, 0xD3	; 211
 1d4:	80 e3       	ldi	r24, 0x30	; 48
 1d6:	91 50       	subi	r25, 0x01	; 1
 1d8:	20 40       	sbci	r18, 0x00	; 0
 1da:	80 40       	sbci	r24, 0x00	; 0
 1dc:	e1 f7       	brne	.-8      	; 0x1d6 <main+0x144>
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <main+0x14e>
 1e0:	00 00       	nop
				_delay_ms(1000);										// delay
				LCD_voidSendCommand(1);									// clear lcd
 1e2:	81 e0       	ldi	r24, 0x01	; 1
 1e4:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
				LCD_voidSendString("Welcome User");						// print welcome user on lcd
 1e8:	80 ea       	ldi	r24, 0xA0	; 160
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 1f0:	9f ef       	ldi	r25, 0xFF	; 255
 1f2:	27 ea       	ldi	r18, 0xA7	; 167
 1f4:	81 e6       	ldi	r24, 0x61	; 97
 1f6:	91 50       	subi	r25, 0x01	; 1
 1f8:	20 40       	sbci	r18, 0x00	; 0
 1fa:	80 40       	sbci	r24, 0x00	; 0
 1fc:	e1 f7       	brne	.-8      	; 0x1f6 <main+0x164>
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <main+0x16e>
 200:	00 00       	nop
				_delay_ms(2000);										// delay
				LCD_voidSendCommand(1);									// clear lcd
 202:	81 e0       	ldi	r24, 0x01	; 1
 204:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
				break;
 208:	34 c0       	rjmp	.+104    	; 0x272 <main+0x1e0>
			}
			else
			{
				flag = 1;												// set the flag as the user enters wrong password
				counter2++;												// increase counter of chances for entering password
 20a:	1f 5f       	subi	r17, 0xFF	; 255
				LCD_voidSendString("Wrong Password!!");					// print wrong password on lcd
 20c:	8d ea       	ldi	r24, 0xAD	; 173
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
				DIO_voidSetPinVal(DIO_PORTB , DIO_PIN6 , HIGH);			// turn on the red led
 214:	41 e0       	ldi	r20, 0x01	; 1
 216:	66 e0       	ldi	r22, 0x06	; 6
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 21e:	9f ef       	ldi	r25, 0xFF	; 255
 220:	27 ea       	ldi	r18, 0xA7	; 167
 222:	81 e6       	ldi	r24, 0x61	; 97
 224:	91 50       	subi	r25, 0x01	; 1
 226:	20 40       	sbci	r18, 0x00	; 0
 228:	80 40       	sbci	r24, 0x00	; 0
 22a:	e1 f7       	brne	.-8      	; 0x224 <main+0x192>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <main+0x19c>
 22e:	00 00       	nop
				_delay_ms(2000);										// delay
				LCD_voidSendCommand(1);									// clear lcd
 230:	81 e0       	ldi	r24, 0x01	; 1
 232:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
				if (counter2 < 3)										// loop to check chances of entering the password
 236:	13 30       	cpi	r17, 0x03	; 3
 238:	b8 f4       	brcc	.+46     	; 0x268 <main+0x1d6>
				{
					flag = 0;											// reset the flag to enter the password again if counter2 < 3
					DIO_voidSetPinVal(DIO_PORTB , DIO_PIN6 , LOW);		// turn off the red led
 23a:	40 e0       	ldi	r20, 0x00	; 0
 23c:	66 e0       	ldi	r22, 0x06	; 6
 23e:	81 e0       	ldi	r24, 0x01	; 1
 240:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
					LCD_voidSendString("Please Try again !!");			// message to enter password again
 244:	8e eb       	ldi	r24, 0xBE	; 190
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 24c:	9f ef       	ldi	r25, 0xFF	; 255
 24e:	23 ed       	ldi	r18, 0xD3	; 211
 250:	80 e3       	ldi	r24, 0x30	; 48
 252:	91 50       	subi	r25, 0x01	; 1
 254:	20 40       	sbci	r18, 0x00	; 0
 256:	80 40       	sbci	r24, 0x00	; 0
 258:	e1 f7       	brne	.-8      	; 0x252 <main+0x1c0>
 25a:	00 c0       	rjmp	.+0      	; 0x25c <main+0x1ca>
 25c:	00 00       	nop
					_delay_ms(1000);									// delay
					LCD_voidSendCommand(1);								// clear lcd
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
				DIO_voidSetPinVal(DIO_PORTB , DIO_PIN6 , HIGH);			// turn on the red led
				_delay_ms(2000);										// delay
				LCD_voidSendCommand(1);									// clear lcd
				if (counter2 < 3)										// loop to check chances of entering the password
				{
					flag = 0;											// reset the flag to enter the password again if counter2 < 3
 264:	d1 2c       	mov	r13, r1
 266:	02 c0       	rjmp	.+4      	; 0x26c <main+0x1da>
				LCD_voidSendCommand(1);									// clear lcd
				break;
			}
			else
			{
				flag = 1;												// set the flag as the user enters wrong password
 268:	dd 24       	eor	r13, r13
 26a:	d3 94       	inc	r13
	LCD_voidInit();														// activate LCD
	KEYPAD_voidInit();													// activate KEYPAD
	ADC_voidInit();														// activate ADC
	while(1)
	{
		while (counter2 < 3)											// Three chances for the user to enter the correct password
 26c:	13 30       	cpi	r17, 0x03	; 3
 26e:	08 f4       	brcc	.+2      	; 0x272 <main+0x1e0>
 270:	2b cf       	rjmp	.-426    	; 0xc8 <main+0x36>
				}
				
			}
		}
		
		if (counter2 == 3)												// if the user enters password wrong 3 times
 272:	13 30       	cpi	r17, 0x03	; 3
 274:	09 f4       	brne	.+2      	; 0x278 <main+0x1e6>
 276:	93 c0       	rjmp	.+294    	; 0x39e <main+0x30c>
			DIO_voidSetPinVal(DIO_PORTB , DIO_PIN4 , HIGH);
			break;														// break to get out of the loop to continue the alarm
		}
		
		
		if (flag == 0)													// if user enters correct password
 278:	d1 10       	cpse	r13, r1
 27a:	f8 cf       	rjmp	.-16     	; 0x26c <main+0x1da>
		{
			while(1)
			{
				val = ADC_u16ReadChannel(ADC_0);						// reading LM35 temperature				
 27c:	80 e0       	ldi	r24, 0x00	; 0
 27e:	0e 94 c0 03 	call	0x780	; 0x780 <ADC_u16ReadChannel>
				temp = (f32)val * 500 / 1024;							// calculate temperature		
 282:	bc 01       	movw	r22, r24
 284:	80 e0       	ldi	r24, 0x00	; 0
 286:	90 e0       	ldi	r25, 0x00	; 0
 288:	0e 94 99 05 	call	0xb32	; 0xb32 <__floatunsisf>
 28c:	20 e0       	ldi	r18, 0x00	; 0
 28e:	30 e0       	ldi	r19, 0x00	; 0
 290:	4a ef       	ldi	r20, 0xFA	; 250
 292:	53 e4       	ldi	r21, 0x43	; 67
 294:	0e 94 28 06 	call	0xc50	; 0xc50 <__mulsf3>
 298:	20 e0       	ldi	r18, 0x00	; 0
 29a:	30 e0       	ldi	r19, 0x00	; 0
 29c:	40 e8       	ldi	r20, 0x80	; 128
 29e:	5a e3       	ldi	r21, 0x3A	; 58
 2a0:	0e 94 28 06 	call	0xc50	; 0xc50 <__mulsf3>
 2a4:	6b 01       	movw	r12, r22
 2a6:	7c 01       	movw	r14, r24
				LCD_voidGotoxy(0,0);									// go to location 0 , 0 in lcd
 2a8:	60 e0       	ldi	r22, 0x00	; 0
 2aa:	80 e0       	ldi	r24, 0x00	; 0
 2ac:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
				LCD_voidSendString("Temperature = ");					// print the temperature
 2b0:	81 ee       	ldi	r24, 0xE1	; 225
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
				LCD_voidSendNumber(temp);
 2b8:	c7 01       	movw	r24, r14
 2ba:	b6 01       	movw	r22, r12
 2bc:	0e 94 6a 05 	call	0xad4	; 0xad4 <__fixunssfsi>
 2c0:	0e 94 66 03 	call	0x6cc	; 0x6cc <LCD_voidSendNumber>
				
				/* conditions of turning on the fan and controlling the speed */
				if (temp < 30)											// if temp < 30											
 2c4:	20 e0       	ldi	r18, 0x00	; 0
 2c6:	30 e0       	ldi	r19, 0x00	; 0
 2c8:	40 ef       	ldi	r20, 0xF0	; 240
 2ca:	51 e4       	ldi	r21, 0x41	; 65
 2cc:	c7 01       	movw	r24, r14
 2ce:	b6 01       	movw	r22, r12
 2d0:	0e 94 65 05 	call	0xaca	; 0xaca <__cmpsf2>
 2d4:	88 23       	and	r24, r24
 2d6:	64 f4       	brge	.+24     	; 0x2f0 <main+0x25e>
				{
					dc = 0;												// set the speed = 0
					TIMER0_voidFastPWM(dc);								// turn on the fan with the entered speed
 2d8:	80 e0       	ldi	r24, 0x00	; 0
 2da:	0e 94 f5 04 	call	0x9ea	; 0x9ea <TIMER0_voidFastPWM>
					LCD_voidGotoxy(0,1);								// go to location 0 , 1 in lcd
 2de:	61 e0       	ldi	r22, 0x01	; 1
 2e0:	80 e0       	ldi	r24, 0x00	; 0
 2e2:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
					LCD_voidSendString("Fan Speed = 0%");				// print the speed of the fan on lcd
 2e6:	80 ef       	ldi	r24, 0xF0	; 240
 2e8:	90 e0       	ldi	r25, 0x00	; 0
 2ea:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 2ee:	c6 cf       	rjmp	.-116    	; 0x27c <main+0x1ea>
				}
				else if ((temp >= 30) && (temp < 40))					// if temp is between 30 and 40
 2f0:	20 e0       	ldi	r18, 0x00	; 0
 2f2:	30 e0       	ldi	r19, 0x00	; 0
 2f4:	40 ef       	ldi	r20, 0xF0	; 240
 2f6:	51 e4       	ldi	r21, 0x41	; 65
 2f8:	c7 01       	movw	r24, r14
 2fa:	b6 01       	movw	r22, r12
 2fc:	0e 94 23 06 	call	0xc46	; 0xc46 <__gesf2>
 300:	88 23       	and	r24, r24
 302:	b4 f0       	brlt	.+44     	; 0x330 <main+0x29e>
 304:	20 e0       	ldi	r18, 0x00	; 0
 306:	30 e0       	ldi	r19, 0x00	; 0
 308:	40 e2       	ldi	r20, 0x20	; 32
 30a:	52 e4       	ldi	r21, 0x42	; 66
 30c:	c7 01       	movw	r24, r14
 30e:	b6 01       	movw	r22, r12
 310:	0e 94 65 05 	call	0xaca	; 0xaca <__cmpsf2>
 314:	88 23       	and	r24, r24
 316:	64 f4       	brge	.+24     	; 0x330 <main+0x29e>
				{
					dc = 30;											// set the speed by 30%
					TIMER0_voidFastPWM(dc);								// turn on the fan with the entered speed
 318:	8e e1       	ldi	r24, 0x1E	; 30
 31a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <TIMER0_voidFastPWM>
					LCD_voidGotoxy(0,1);								// go to location 0 , 1 in lcd
 31e:	61 e0       	ldi	r22, 0x01	; 1
 320:	80 e0       	ldi	r24, 0x00	; 0
 322:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
					LCD_voidSendString("Fan Speed = 30%");				// print the speed of the fan on lcd
 326:	8f ef       	ldi	r24, 0xFF	; 255
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 32e:	a6 cf       	rjmp	.-180    	; 0x27c <main+0x1ea>
				}
				else if ((temp >= 40) && (temp < 50))					// if temp is between 40 and 50
 330:	20 e0       	ldi	r18, 0x00	; 0
 332:	30 e0       	ldi	r19, 0x00	; 0
 334:	40 e2       	ldi	r20, 0x20	; 32
 336:	52 e4       	ldi	r21, 0x42	; 66
 338:	c7 01       	movw	r24, r14
 33a:	b6 01       	movw	r22, r12
 33c:	0e 94 23 06 	call	0xc46	; 0xc46 <__gesf2>
 340:	88 23       	and	r24, r24
 342:	b4 f0       	brlt	.+44     	; 0x370 <main+0x2de>
 344:	20 e0       	ldi	r18, 0x00	; 0
 346:	30 e0       	ldi	r19, 0x00	; 0
 348:	48 e4       	ldi	r20, 0x48	; 72
 34a:	52 e4       	ldi	r21, 0x42	; 66
 34c:	c7 01       	movw	r24, r14
 34e:	b6 01       	movw	r22, r12
 350:	0e 94 65 05 	call	0xaca	; 0xaca <__cmpsf2>
 354:	88 23       	and	r24, r24
 356:	64 f4       	brge	.+24     	; 0x370 <main+0x2de>
				{
					dc = 50;											// set the speed by 50%
					TIMER0_voidFastPWM(dc);								// turn on the fan with the entered speed
 358:	82 e3       	ldi	r24, 0x32	; 50
 35a:	0e 94 f5 04 	call	0x9ea	; 0x9ea <TIMER0_voidFastPWM>
					LCD_voidGotoxy(0,1);								// go to location 0 , 1 in lcd
 35e:	61 e0       	ldi	r22, 0x01	; 1
 360:	80 e0       	ldi	r24, 0x00	; 0
 362:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
					LCD_voidSendString("Fan Speed = 50%");				// print the speed of the fan on lcd
 366:	8f e0       	ldi	r24, 0x0F	; 15
 368:	91 e0       	ldi	r25, 0x01	; 1
 36a:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 36e:	86 cf       	rjmp	.-244    	; 0x27c <main+0x1ea>
				}
				else if (temp >= 50)									// if temp is greater than 50
 370:	20 e0       	ldi	r18, 0x00	; 0
 372:	30 e0       	ldi	r19, 0x00	; 0
 374:	48 e4       	ldi	r20, 0x48	; 72
 376:	52 e4       	ldi	r21, 0x42	; 66
 378:	c7 01       	movw	r24, r14
 37a:	b6 01       	movw	r22, r12
 37c:	0e 94 23 06 	call	0xc46	; 0xc46 <__gesf2>
 380:	88 23       	and	r24, r24
 382:	0c f4       	brge	.+2      	; 0x386 <main+0x2f4>
 384:	7b cf       	rjmp	.-266    	; 0x27c <main+0x1ea>
				{
					dc = 99;											// set the speed by 100%
					TIMER0_voidFastPWM(dc);								// turn on the fan with the entered speed
 386:	83 e6       	ldi	r24, 0x63	; 99
 388:	0e 94 f5 04 	call	0x9ea	; 0x9ea <TIMER0_voidFastPWM>
					LCD_voidGotoxy(0,1);								// go to location 0 , 1 in lcd
 38c:	61 e0       	ldi	r22, 0x01	; 1
 38e:	80 e0       	ldi	r24, 0x00	; 0
 390:	0e 94 5e 03 	call	0x6bc	; 0x6bc <LCD_voidGotoxy>
					LCD_voidSendString("Fan Speed = 100%");				// print the speed of the fan on lcd
 394:	8f e1       	ldi	r24, 0x1F	; 31
 396:	91 e0       	ldi	r25, 0x01	; 1
 398:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
 39c:	6f cf       	rjmp	.-290    	; 0x27c <main+0x1ea>
		}
		
		if (counter2 == 3)												// if the user enters password wrong 3 times
		{
			flag = 1;													// set the flag
			LCD_voidSendString("Alarm is On !!");						// set the alarm
 39e:	82 ed       	ldi	r24, 0xD2	; 210
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	0e 94 4b 03 	call	0x696	; 0x696 <LCD_voidSendString>
			DIO_voidSetPinVal(DIO_PORTB , DIO_PIN6 , HIGH);				// turn on the red led
 3a6:	41 e0       	ldi	r20, 0x01	; 1
 3a8:	66 e0       	ldi	r22, 0x06	; 6
 3aa:	81 e0       	ldi	r24, 0x01	; 1
 3ac:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
			DIO_voidSetPinVal(DIO_PORTB , DIO_PIN4 , HIGH);
 3b0:	41 e0       	ldi	r20, 0x01	; 1
 3b2:	64 e0       	ldi	r22, 0x04	; 4
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
		}
		
		
	}
	
}
 3ba:	80 e0       	ldi	r24, 0x00	; 0
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	df 91       	pop	r29
 3c0:	cf 91       	pop	r28
 3c2:	1f 91       	pop	r17
 3c4:	0f 91       	pop	r16
 3c6:	ff 90       	pop	r15
 3c8:	ef 90       	pop	r14
 3ca:	df 90       	pop	r13
 3cc:	cf 90       	pop	r12
 3ce:	bf 90       	pop	r11
 3d0:	af 90       	pop	r10
 3d2:	08 95       	ret

000003d4 <KEYPAD_voidInit>:
					  	  	   
	                  



void KEYPAD_voidInit(void){
 3d4:	ff 92       	push	r15
 3d6:	0f 93       	push	r16
 3d8:	1f 93       	push	r17
 3da:	cf 93       	push	r28
 3dc:	df 93       	push	r29
 3de:	cd b7       	in	r28, 0x3d	; 61
 3e0:	de b7       	in	r29, 0x3e	; 62
 3e2:	28 97       	sbiw	r28, 0x08	; 8
 3e4:	0f b6       	in	r0, 0x3f	; 63
 3e6:	f8 94       	cli
 3e8:	de bf       	out	0x3e, r29	; 62
 3ea:	0f be       	out	0x3f, r0	; 63
 3ec:	cd bf       	out	0x3d, r28	; 61
	
	 u8 COL_arr[4]={KEYPAD_COL0_PIN,KEYPAD_COL1_PIN,KEYPAD_COL2_PIN,KEYPAD_COL3_PIN} ; 
 3ee:	19 82       	std	Y+1, r1	; 0x01
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	8a 83       	std	Y+2, r24	; 0x02
 3f4:	82 e0       	ldi	r24, 0x02	; 2
 3f6:	8b 83       	std	Y+3, r24	; 0x03
 3f8:	83 e0       	ldi	r24, 0x03	; 3
 3fa:	8c 83       	std	Y+4, r24	; 0x04
	u8  ROW_arr[4]={KEYPAD_ROW0_PIN,KEYPAD_ROW1_PIN,KEYPAD_ROW2_PIN,KEYPAD_ROW3_PIN} ; 	 
 3fc:	84 e0       	ldi	r24, 0x04	; 4
 3fe:	8d 83       	std	Y+5, r24	; 0x05
 400:	85 e0       	ldi	r24, 0x05	; 5
 402:	8e 83       	std	Y+6, r24	; 0x06
 404:	86 e0       	ldi	r24, 0x06	; 6
 406:	8f 83       	std	Y+7, r24	; 0x07
 408:	87 e0       	ldi	r24, 0x07	; 7
 40a:	88 87       	std	Y+8, r24	; 0x08
	
	u8 LOC_row=0 ; 
	u8 LOC_col=0 ; 
	
	for (LOC_row=0 ,LOC_col=0 ; LOC_row<4 && LOC_col<4 ;LOC_row++,LOC_col++)
 40c:	00 e0       	ldi	r16, 0x00	; 0
 40e:	10 e0       	ldi	r17, 0x00	; 0
 410:	24 c0       	rjmp	.+72     	; 0x45a <__EEPROM_REGION_LENGTH__+0x5a>
	{
		 /* make all rows as input */
		DIO_voidSetPinDir(KEYPAD_ROWPORT,ROW_arr[LOC_row],INPUT) ; 
 412:	e5 e0       	ldi	r30, 0x05	; 5
 414:	f0 e0       	ldi	r31, 0x00	; 0
 416:	ec 0f       	add	r30, r28
 418:	fd 1f       	adc	r31, r29
 41a:	e1 0f       	add	r30, r17
 41c:	f1 1d       	adc	r31, r1
 41e:	f0 80       	ld	r15, Z
 420:	40 e0       	ldi	r20, 0x00	; 0
 422:	6f 2d       	mov	r22, r15
 424:	82 e0       	ldi	r24, 0x02	; 2
 426:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <DIO_voidSetPinDir>
		/* enable internal pull up */
		DIO_voidSetPinVal(KEYPAD_ROWPORT,ROW_arr[LOC_row],HIGH) ; 
 42a:	41 e0       	ldi	r20, 0x01	; 1
 42c:	6f 2d       	mov	r22, r15
 42e:	82 e0       	ldi	r24, 0x02	; 2
 430:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
		
    	 /* make all col as  output */
    	 DIO_voidSetPinDir(KEYPAD_COLPORT,COL_arr[LOC_col],OUTPUT) ;
 434:	e1 e0       	ldi	r30, 0x01	; 1
 436:	f0 e0       	ldi	r31, 0x00	; 0
 438:	ec 0f       	add	r30, r28
 43a:	fd 1f       	adc	r31, r29
 43c:	e0 0f       	add	r30, r16
 43e:	f1 1d       	adc	r31, r1
 440:	f0 80       	ld	r15, Z
 442:	41 e0       	ldi	r20, 0x01	; 1
 444:	6f 2d       	mov	r22, r15
 446:	82 e0       	ldi	r24, 0x02	; 2
 448:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <DIO_voidSetPinDir>
    	 /*  set all col as HIGH  */
    	 DIO_voidSetPinVal(KEYPAD_COLPORT,COL_arr[LOC_col],HIGH) ;
 44c:	41 e0       	ldi	r20, 0x01	; 1
 44e:	6f 2d       	mov	r22, r15
 450:	82 e0       	ldi	r24, 0x02	; 2
 452:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
	u8  ROW_arr[4]={KEYPAD_ROW0_PIN,KEYPAD_ROW1_PIN,KEYPAD_ROW2_PIN,KEYPAD_ROW3_PIN} ; 	 
	
	u8 LOC_row=0 ; 
	u8 LOC_col=0 ; 
	
	for (LOC_row=0 ,LOC_col=0 ; LOC_row<4 && LOC_col<4 ;LOC_row++,LOC_col++)
 456:	1f 5f       	subi	r17, 0xFF	; 255
 458:	0f 5f       	subi	r16, 0xFF	; 255
 45a:	14 30       	cpi	r17, 0x04	; 4
 45c:	10 f4       	brcc	.+4      	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
 45e:	04 30       	cpi	r16, 0x04	; 4
 460:	c0 f2       	brcs	.-80     	; 0x412 <__EEPROM_REGION_LENGTH__+0x12>
	}

	

	
}
 462:	28 96       	adiw	r28, 0x08	; 8
 464:	0f b6       	in	r0, 0x3f	; 63
 466:	f8 94       	cli
 468:	de bf       	out	0x3e, r29	; 62
 46a:	0f be       	out	0x3f, r0	; 63
 46c:	cd bf       	out	0x3d, r28	; 61
 46e:	df 91       	pop	r29
 470:	cf 91       	pop	r28
 472:	1f 91       	pop	r17
 474:	0f 91       	pop	r16
 476:	ff 90       	pop	r15
 478:	08 95       	ret

0000047a <KEYPAD_u8GetKey>:

u8 KEYPAD_u8GetKey(void){
 47a:	af 92       	push	r10
 47c:	bf 92       	push	r11
 47e:	cf 92       	push	r12
 480:	df 92       	push	r13
 482:	ef 92       	push	r14
 484:	ff 92       	push	r15
 486:	0f 93       	push	r16
 488:	1f 93       	push	r17
 48a:	cf 93       	push	r28
 48c:	df 93       	push	r29
 48e:	cd b7       	in	r28, 0x3d	; 61
 490:	de b7       	in	r29, 0x3e	; 62
 492:	28 97       	sbiw	r28, 0x08	; 8
 494:	0f b6       	in	r0, 0x3f	; 63
 496:	f8 94       	cli
 498:	de bf       	out	0x3e, r29	; 62
 49a:	0f be       	out	0x3f, r0	; 63
 49c:	cd bf       	out	0x3d, r28	; 61
		 u8 COL_arr[4]={KEYPAD_COL0_PIN,KEYPAD_COL1_PIN,KEYPAD_COL2_PIN,KEYPAD_COL3_PIN} ;
 49e:	19 82       	std	Y+1, r1	; 0x01
 4a0:	81 e0       	ldi	r24, 0x01	; 1
 4a2:	8a 83       	std	Y+2, r24	; 0x02
 4a4:	82 e0       	ldi	r24, 0x02	; 2
 4a6:	8b 83       	std	Y+3, r24	; 0x03
 4a8:	83 e0       	ldi	r24, 0x03	; 3
 4aa:	8c 83       	std	Y+4, r24	; 0x04
		 u8  ROW_arr[4]={KEYPAD_ROW0_PIN,KEYPAD_ROW1_PIN,KEYPAD_ROW2_PIN,KEYPAD_ROW3_PIN} ;
 4ac:	84 e0       	ldi	r24, 0x04	; 4
 4ae:	8d 83       	std	Y+5, r24	; 0x05
 4b0:	85 e0       	ldi	r24, 0x05	; 5
 4b2:	8e 83       	std	Y+6, r24	; 0x06
 4b4:	86 e0       	ldi	r24, 0x06	; 6
 4b6:	8f 83       	std	Y+7, r24	; 0x07
 4b8:	87 e0       	ldi	r24, 0x07	; 7
 4ba:	88 87       	std	Y+8, r24	; 0x08
		 
		 u8 LOC_row=0 ;
		 u8 LOC_col=0 ;
		 u8 loc_val=0xff ; 
		 
		 for (LOC_col=0 ; LOC_col<4 ;LOC_col++)
 4bc:	b1 2c       	mov	r11, r1
 4be:	3b c0       	rjmp	.+118    	; 0x536 <KEYPAD_u8GetKey+0xbc>
		 {
			 /* set col(num) as low */
          DIO_voidSetPinVal(KEYPAD_COLPORT,COL_arr[LOC_col],LOW) ;
 4c0:	cb 2c       	mov	r12, r11
 4c2:	d1 2c       	mov	r13, r1
 4c4:	e1 e0       	ldi	r30, 0x01	; 1
 4c6:	f0 e0       	ldi	r31, 0x00	; 0
 4c8:	ec 0f       	add	r30, r28
 4ca:	fd 1f       	adc	r31, r29
 4cc:	ec 0d       	add	r30, r12
 4ce:	fd 1d       	adc	r31, r13
 4d0:	a0 80       	ld	r10, Z
 4d2:	40 e0       	ldi	r20, 0x00	; 0
 4d4:	6a 2d       	mov	r22, r10
 4d6:	82 e0       	ldi	r24, 0x02	; 2
 4d8:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
		  
		  for (LOC_row=0 ; LOC_row<4 ;LOC_row++)
 4dc:	10 e0       	ldi	r17, 0x00	; 0
 4de:	23 c0       	rjmp	.+70     	; 0x526 <KEYPAD_u8GetKey+0xac>
		  {
			   /* check if any button is pressed */
			  if (DIO_u8ReadpinVal(KEYPAD_ROWPORT, ROW_arr[LOC_row])==0)
 4e0:	e1 2e       	mov	r14, r17
 4e2:	f1 2c       	mov	r15, r1
 4e4:	e5 e0       	ldi	r30, 0x05	; 5
 4e6:	f0 e0       	ldi	r31, 0x00	; 0
 4e8:	ec 0f       	add	r30, r28
 4ea:	fd 1f       	adc	r31, r29
 4ec:	ee 0d       	add	r30, r14
 4ee:	ff 1d       	adc	r31, r15
 4f0:	00 81       	ld	r16, Z
 4f2:	60 2f       	mov	r22, r16
 4f4:	82 e0       	ldi	r24, 0x02	; 2
 4f6:	0e 94 b7 04 	call	0x96e	; 0x96e <DIO_u8ReadpinVal>
 4fa:	81 11       	cpse	r24, r1
 4fc:	13 c0       	rjmp	.+38     	; 0x524 <KEYPAD_u8GetKey+0xaa>
			  {
				  loc_val=keypad_arr[LOC_row][LOC_col] ; 
 4fe:	c7 01       	movw	r24, r14
 500:	88 0f       	add	r24, r24
 502:	99 1f       	adc	r25, r25
 504:	88 0f       	add	r24, r24
 506:	99 1f       	adc	r25, r25
 508:	80 5a       	subi	r24, 0xA0	; 160
 50a:	9f 4f       	sbci	r25, 0xFF	; 255
 50c:	fc 01       	movw	r30, r24
 50e:	ec 0d       	add	r30, r12
 510:	fd 1d       	adc	r31, r13
 512:	10 81       	ld	r17, Z
				  while(DIO_u8ReadpinVal(KEYPAD_ROWPORT, ROW_arr[LOC_row])==0) ; 
 514:	60 2f       	mov	r22, r16
 516:	82 e0       	ldi	r24, 0x02	; 2
 518:	0e 94 b7 04 	call	0x96e	; 0x96e <DIO_u8ReadpinVal>
 51c:	88 23       	and	r24, r24
 51e:	d1 f3       	breq	.-12     	; 0x514 <KEYPAD_u8GetKey+0x9a>
				  
				  return loc_val  ; 
 520:	81 2f       	mov	r24, r17
 522:	0d c0       	rjmp	.+26     	; 0x53e <KEYPAD_u8GetKey+0xc4>
		 for (LOC_col=0 ; LOC_col<4 ;LOC_col++)
		 {
			 /* set col(num) as low */
          DIO_voidSetPinVal(KEYPAD_COLPORT,COL_arr[LOC_col],LOW) ;
		  
		  for (LOC_row=0 ; LOC_row<4 ;LOC_row++)
 524:	1f 5f       	subi	r17, 0xFF	; 255
 526:	14 30       	cpi	r17, 0x04	; 4
 528:	d8 f2       	brcs	.-74     	; 0x4e0 <KEYPAD_u8GetKey+0x66>
			  }
			  
			  
		  }
			  /* set col(num) as high */
			  DIO_voidSetPinVal(KEYPAD_COLPORT,COL_arr[LOC_col],HIGH) ;
 52a:	41 e0       	ldi	r20, 0x01	; 1
 52c:	6a 2d       	mov	r22, r10
 52e:	82 e0       	ldi	r24, 0x02	; 2
 530:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
		 
		 u8 LOC_row=0 ;
		 u8 LOC_col=0 ;
		 u8 loc_val=0xff ; 
		 
		 for (LOC_col=0 ; LOC_col<4 ;LOC_col++)
 534:	b3 94       	inc	r11
 536:	83 e0       	ldi	r24, 0x03	; 3
 538:	8b 15       	cp	r24, r11
 53a:	10 f6       	brcc	.-124    	; 0x4c0 <KEYPAD_u8GetKey+0x46>
	
	
	
	
	
	return loc_val ; 
 53c:	8f ef       	ldi	r24, 0xFF	; 255
}
 53e:	28 96       	adiw	r28, 0x08	; 8
 540:	0f b6       	in	r0, 0x3f	; 63
 542:	f8 94       	cli
 544:	de bf       	out	0x3e, r29	; 62
 546:	0f be       	out	0x3f, r0	; 63
 548:	cd bf       	out	0x3d, r28	; 61
 54a:	df 91       	pop	r29
 54c:	cf 91       	pop	r28
 54e:	1f 91       	pop	r17
 550:	0f 91       	pop	r16
 552:	ff 90       	pop	r15
 554:	ef 90       	pop	r14
 556:	df 90       	pop	r13
 558:	cf 90       	pop	r12
 55a:	bf 90       	pop	r11
 55c:	af 90       	pop	r10
 55e:	08 95       	ret

00000560 <ReturnKey_void>:
u8 ReturnKey_void(void)
{
	u8 key = 0xff;
	do
	{
		key=KEYPAD_u8GetKey() ;
 560:	0e 94 3d 02 	call	0x47a	; 0x47a <KEYPAD_u8GetKey>
		
	} while (key==0xff);
 564:	8f 3f       	cpi	r24, 0xFF	; 255
 566:	e1 f3       	breq	.-8      	; 0x560 <ReturnKey_void>
	
	return key;
 568:	08 95       	ret

0000056a <LCD_voidSHD>:
	  LCD_voidSendData(pattern) ; 
	  
	  
	
	
}
 56a:	0f 93       	push	r16
 56c:	1f 93       	push	r17
 56e:	cf 93       	push	r28
 570:	df 93       	push	r29
 572:	00 d0       	rcall	.+0      	; 0x574 <LCD_voidSHD+0xa>
 574:	00 d0       	rcall	.+0      	; 0x576 <LCD_voidSHD+0xc>
 576:	cd b7       	in	r28, 0x3d	; 61
 578:	de b7       	in	r29, 0x3e	; 62
 57a:	08 2f       	mov	r16, r24
 57c:	84 e0       	ldi	r24, 0x04	; 4
 57e:	89 83       	std	Y+1, r24	; 0x01
 580:	85 e0       	ldi	r24, 0x05	; 5
 582:	8a 83       	std	Y+2, r24	; 0x02
 584:	86 e0       	ldi	r24, 0x06	; 6
 586:	8b 83       	std	Y+3, r24	; 0x03
 588:	87 e0       	ldi	r24, 0x07	; 7
 58a:	8c 83       	std	Y+4, r24	; 0x04
 58c:	10 e0       	ldi	r17, 0x00	; 0
 58e:	14 c0       	rjmp	.+40     	; 0x5b8 <LCD_voidSHD+0x4e>
 590:	40 2f       	mov	r20, r16
 592:	50 e0       	ldi	r21, 0x00	; 0
 594:	01 2e       	mov	r0, r17
 596:	02 c0       	rjmp	.+4      	; 0x59c <LCD_voidSHD+0x32>
 598:	55 95       	asr	r21
 59a:	47 95       	ror	r20
 59c:	0a 94       	dec	r0
 59e:	e2 f7       	brpl	.-8      	; 0x598 <LCD_voidSHD+0x2e>
 5a0:	41 70       	andi	r20, 0x01	; 1
 5a2:	e1 e0       	ldi	r30, 0x01	; 1
 5a4:	f0 e0       	ldi	r31, 0x00	; 0
 5a6:	ec 0f       	add	r30, r28
 5a8:	fd 1f       	adc	r31, r29
 5aa:	e1 0f       	add	r30, r17
 5ac:	f1 1d       	adc	r31, r1
 5ae:	60 81       	ld	r22, Z
 5b0:	80 e0       	ldi	r24, 0x00	; 0
 5b2:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 5b6:	1f 5f       	subi	r17, 0xFF	; 255
 5b8:	14 30       	cpi	r17, 0x04	; 4
 5ba:	50 f3       	brcs	.-44     	; 0x590 <LCD_voidSHD+0x26>
 5bc:	0f 90       	pop	r0
 5be:	0f 90       	pop	r0
 5c0:	0f 90       	pop	r0
 5c2:	0f 90       	pop	r0
 5c4:	df 91       	pop	r29
 5c6:	cf 91       	pop	r28
 5c8:	1f 91       	pop	r17
 5ca:	0f 91       	pop	r16
 5cc:	08 95       	ret

000005ce <LCD_voidSendEnable>:
 5ce:	41 e0       	ldi	r20, 0x01	; 1
 5d0:	62 e0       	ldi	r22, 0x02	; 2
 5d2:	81 e0       	ldi	r24, 0x01	; 1
 5d4:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 5d8:	8f e3       	ldi	r24, 0x3F	; 63
 5da:	9f e1       	ldi	r25, 0x1F	; 31
 5dc:	01 97       	sbiw	r24, 0x01	; 1
 5de:	f1 f7       	brne	.-4      	; 0x5dc <LCD_voidSendEnable+0xe>
 5e0:	00 c0       	rjmp	.+0      	; 0x5e2 <LCD_voidSendEnable+0x14>
 5e2:	00 00       	nop
 5e4:	40 e0       	ldi	r20, 0x00	; 0
 5e6:	62 e0       	ldi	r22, 0x02	; 2
 5e8:	81 e0       	ldi	r24, 0x01	; 1
 5ea:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 5ee:	08 95       	ret

000005f0 <LCD_voidSendData>:
 5f0:	cf 93       	push	r28
 5f2:	c8 2f       	mov	r28, r24
 5f4:	41 e0       	ldi	r20, 0x01	; 1
 5f6:	60 e0       	ldi	r22, 0x00	; 0
 5f8:	81 e0       	ldi	r24, 0x01	; 1
 5fa:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 5fe:	40 e0       	ldi	r20, 0x00	; 0
 600:	61 e0       	ldi	r22, 0x01	; 1
 602:	81 e0       	ldi	r24, 0x01	; 1
 604:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 608:	8c 2f       	mov	r24, r28
 60a:	82 95       	swap	r24
 60c:	8f 70       	andi	r24, 0x0F	; 15
 60e:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 612:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 616:	8c 2f       	mov	r24, r28
 618:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 61c:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 620:	cf 91       	pop	r28
 622:	08 95       	ret

00000624 <LCD_voidSendCommand>:
 624:	cf 93       	push	r28
 626:	c8 2f       	mov	r28, r24
 628:	40 e0       	ldi	r20, 0x00	; 0
 62a:	60 e0       	ldi	r22, 0x00	; 0
 62c:	81 e0       	ldi	r24, 0x01	; 1
 62e:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 632:	40 e0       	ldi	r20, 0x00	; 0
 634:	61 e0       	ldi	r22, 0x01	; 1
 636:	81 e0       	ldi	r24, 0x01	; 1
 638:	0e 94 44 04 	call	0x888	; 0x888 <DIO_voidSetPinVal>
 63c:	8c 2f       	mov	r24, r28
 63e:	82 95       	swap	r24
 640:	8f 70       	andi	r24, 0x0F	; 15
 642:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 646:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 64a:	8c 2f       	mov	r24, r28
 64c:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 650:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 654:	cf 91       	pop	r28
 656:	08 95       	ret

00000658 <LCD_voidInit>:
 658:	2f ef       	ldi	r18, 0xFF	; 255
 65a:	83 ef       	ldi	r24, 0xF3	; 243
 65c:	91 e0       	ldi	r25, 0x01	; 1
 65e:	21 50       	subi	r18, 0x01	; 1
 660:	80 40       	sbci	r24, 0x00	; 0
 662:	90 40       	sbci	r25, 0x00	; 0
 664:	e1 f7       	brne	.-8      	; 0x65e <LCD_voidInit+0x6>
 666:	00 c0       	rjmp	.+0      	; 0x668 <LCD_voidInit+0x10>
 668:	00 00       	nop
 66a:	82 e0       	ldi	r24, 0x02	; 2
 66c:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 670:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 674:	82 e0       	ldi	r24, 0x02	; 2
 676:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 67a:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 67e:	88 e0       	ldi	r24, 0x08	; 8
 680:	0e 94 b5 02 	call	0x56a	; 0x56a <LCD_voidSHD>
 684:	0e 94 e7 02 	call	0x5ce	; 0x5ce <LCD_voidSendEnable>
 688:	8c e0       	ldi	r24, 0x0C	; 12
 68a:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
 68e:	81 e0       	ldi	r24, 0x01	; 1
 690:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
 694:	08 95       	ret

00000696 <LCD_voidSendString>:
 696:	0f 93       	push	r16
 698:	1f 93       	push	r17
 69a:	cf 93       	push	r28
 69c:	8c 01       	movw	r16, r24
 69e:	c0 e0       	ldi	r28, 0x00	; 0
 6a0:	03 c0       	rjmp	.+6      	; 0x6a8 <LCD_voidSendString+0x12>
 6a2:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <LCD_voidSendData>
 6a6:	cf 5f       	subi	r28, 0xFF	; 255
 6a8:	f8 01       	movw	r30, r16
 6aa:	ec 0f       	add	r30, r28
 6ac:	f1 1d       	adc	r31, r1
 6ae:	80 81       	ld	r24, Z
 6b0:	81 11       	cpse	r24, r1
 6b2:	f7 cf       	rjmp	.-18     	; 0x6a2 <LCD_voidSendString+0xc>
 6b4:	cf 91       	pop	r28
 6b6:	1f 91       	pop	r17
 6b8:	0f 91       	pop	r16
 6ba:	08 95       	ret

000006bc <LCD_voidGotoxy>:
 6bc:	90 e4       	ldi	r25, 0x40	; 64
 6be:	69 9f       	mul	r22, r25
 6c0:	80 0d       	add	r24, r0
 6c2:	11 24       	eor	r1, r1
 6c4:	80 68       	ori	r24, 0x80	; 128
 6c6:	0e 94 12 03 	call	0x624	; 0x624 <LCD_voidSendCommand>
 6ca:	08 95       	ret

000006cc <LCD_voidSendNumber>:
void LCD_voidSendNumber(u32 number){
 6cc:	1f 93       	push	r17
 6ce:	cf 93       	push	r28
 6d0:	df 93       	push	r29
 6d2:	cd b7       	in	r28, 0x3d	; 61
 6d4:	de b7       	in	r29, 0x3e	; 62
 6d6:	2a 97       	sbiw	r28, 0x0a	; 10
 6d8:	0f b6       	in	r0, 0x3f	; 63
 6da:	f8 94       	cli
 6dc:	de bf       	out	0x3e, r29	; 62
 6de:	0f be       	out	0x3f, r0	; 63
 6e0:	cd bf       	out	0x3d, r28	; 61
	
	s8 i=0;
	u8 array[10] ;
	
	if(number==0){
 6e2:	61 15       	cp	r22, r1
 6e4:	71 05       	cpc	r23, r1
 6e6:	81 05       	cpc	r24, r1
 6e8:	91 05       	cpc	r25, r1
 6ea:	d1 f4       	brne	.+52     	; 0x720 <LCD_voidSendNumber+0x54>
		
		LCD_voidSendData('0') ;
 6ec:	80 e3       	ldi	r24, 0x30	; 48
 6ee:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <LCD_voidSendData>
 6f2:	2c c0       	rjmp	.+88     	; 0x74c <LCD_voidSendNumber+0x80>
		return ;
	}
	for(i=0; number!=0 ;i++){
		
		array[i]= number % 10 + 48 ;
 6f4:	2a e0       	ldi	r18, 0x0A	; 10
 6f6:	30 e0       	ldi	r19, 0x00	; 0
 6f8:	40 e0       	ldi	r20, 0x00	; 0
 6fa:	50 e0       	ldi	r21, 0x00	; 0
 6fc:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__udivmodsi4>
 700:	e1 e0       	ldi	r30, 0x01	; 1
 702:	f0 e0       	ldi	r31, 0x00	; 0
 704:	ec 0f       	add	r30, r28
 706:	fd 1f       	adc	r31, r29
 708:	e1 0f       	add	r30, r17
 70a:	f1 1d       	adc	r31, r1
 70c:	17 fd       	sbrc	r17, 7
 70e:	fa 95       	dec	r31
 710:	60 5d       	subi	r22, 0xD0	; 208
 712:	60 83       	st	Z, r22
		number /= 10 ;
 714:	62 2f       	mov	r22, r18
 716:	73 2f       	mov	r23, r19
 718:	84 2f       	mov	r24, r20
 71a:	95 2f       	mov	r25, r21
	if(number==0){
		
		LCD_voidSendData('0') ;
		return ;
	}
	for(i=0; number!=0 ;i++){
 71c:	1f 5f       	subi	r17, 0xFF	; 255
 71e:	01 c0       	rjmp	.+2      	; 0x722 <LCD_voidSendNumber+0x56>
 720:	10 e0       	ldi	r17, 0x00	; 0
 722:	61 15       	cp	r22, r1
 724:	71 05       	cpc	r23, r1
 726:	81 05       	cpc	r24, r1
 728:	91 05       	cpc	r25, r1
 72a:	21 f7       	brne	.-56     	; 0x6f4 <LCD_voidSendNumber+0x28>
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
 72c:	11 50       	subi	r17, 0x01	; 1
	while(i >= 0){
 72e:	0c c0       	rjmp	.+24     	; 0x748 <LCD_voidSendNumber+0x7c>
		
		LCD_voidSendData(array[i]) ;
 730:	e1 e0       	ldi	r30, 0x01	; 1
 732:	f0 e0       	ldi	r31, 0x00	; 0
 734:	ec 0f       	add	r30, r28
 736:	fd 1f       	adc	r31, r29
 738:	e1 0f       	add	r30, r17
 73a:	f1 1d       	adc	r31, r1
 73c:	17 fd       	sbrc	r17, 7
 73e:	fa 95       	dec	r31
 740:	80 81       	ld	r24, Z
 742:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <LCD_voidSendData>
		i-- ;
 746:	11 50       	subi	r17, 0x01	; 1
		
		array[i]= number % 10 + 48 ;
		number /= 10 ;
	}
	i-- ;
	while(i >= 0){
 748:	11 23       	and	r17, r17
 74a:	94 f7       	brge	.-28     	; 0x730 <LCD_voidSendNumber+0x64>
		
		LCD_voidSendData(array[i]) ;
		i-- ;
	}
 74c:	2a 96       	adiw	r28, 0x0a	; 10
 74e:	0f b6       	in	r0, 0x3f	; 63
 750:	f8 94       	cli
 752:	de bf       	out	0x3e, r29	; 62
 754:	0f be       	out	0x3f, r0	; 63
 756:	cd bf       	out	0x3d, r28	; 61
 758:	df 91       	pop	r29
 75a:	cf 91       	pop	r28
 75c:	1f 91       	pop	r17
 75e:	08 95       	ret

00000760 <ADC_voidInit>:


void ADC_voidInit(){
	
	/*Reference Selections for ADC : AVCC with external capacitor at AREF pin*/
	 CLR_BIT(ADMUX_REG,7) ; 
 760:	87 b1       	in	r24, 0x07	; 7
 762:	8f 77       	andi	r24, 0x7F	; 127
 764:	87 b9       	out	0x07, r24	; 7
	 SET_BIT(ADMUX_REG,6) ; 
 766:	87 b1       	in	r24, 0x07	; 7
 768:	80 64       	ori	r24, 0x40	; 64
 76a:	87 b9       	out	0x07, r24	; 7
	 
	/*select prescaler */
	 
	 ADCSRA_REG&=0b11111000 ; 
 76c:	86 b1       	in	r24, 0x06	; 6
 76e:	88 7f       	andi	r24, 0xF8	; 248
 770:	86 b9       	out	0x06, r24	; 6
	 ADCSRA_REG|=ADC_PRESCALER ; 
 772:	86 b1       	in	r24, 0x06	; 6
 774:	87 60       	ori	r24, 0x07	; 7
 776:	86 b9       	out	0x06, r24	; 6
	
	
	/* ENABLE ADC */
	
	SET_BIT(ADCSRA_REG,7) ; 
 778:	86 b1       	in	r24, 0x06	; 6
 77a:	80 68       	ori	r24, 0x80	; 128
 77c:	86 b9       	out	0x06, r24	; 6
 77e:	08 95       	ret

00000780 <ADC_u16ReadChannel>:
}

u16 ADC_u16ReadChannel(u8 copy_u8channel){
	
	  /* select channel */
	  ADMUX_REG &=0b11100000 ; 
 780:	97 b1       	in	r25, 0x07	; 7
 782:	90 7e       	andi	r25, 0xE0	; 224
 784:	97 b9       	out	0x07, r25	; 7
	  ADMUX_REG |=copy_u8channel ; 
 786:	97 b1       	in	r25, 0x07	; 7
 788:	89 2b       	or	r24, r25
 78a:	87 b9       	out	0x07, r24	; 7
	  /* start conversion */
	  SET_BIT(ADCSRA_REG,6) ; 
 78c:	86 b1       	in	r24, 0x06	; 6
 78e:	80 64       	ori	r24, 0x40	; 64
 790:	86 b9       	out	0x06, r24	; 6
	  
	  while(GET_BIT(ADCSRA_REG,4)==0) ; 
 792:	34 9b       	sbis	0x06, 4	; 6
 794:	fe cf       	rjmp	.-4      	; 0x792 <ADC_u16ReadChannel+0x12>
	  
	  SET_BIT(ADCSRA_REG,4) ; // CLR FLAG 
 796:	86 b1       	in	r24, 0x06	; 6
 798:	80 61       	ori	r24, 0x10	; 16
 79a:	86 b9       	out	0x06, r24	; 6
	  
	  return  ADC_REG ; 
 79c:	84 b1       	in	r24, 0x04	; 4
 79e:	95 b1       	in	r25, 0x05	; 5

 7a0:	08 95       	ret

000007a2 <DIO_voidSetPinDir>:
	     switch(copy_u8port){
			 
			  case DIO_PORTA: TOGGLE_BIT(PORTA_REG,copy_u8pin) ; break;
			  case DIO_PORTB: TOGGLE_BIT(PORTB_REG,copy_u8pin) ; break;
			  case DIO_PORTC: TOGGLE_BIT(PORTC_REG,copy_u8pin) ; break;
			  case DIO_PORTD: TOGGLE_BIT(PORTD_REG,copy_u8pin) ; break ;
 7a2:	42 30       	cpi	r20, 0x02	; 2
 7a4:	08 f0       	brcs	.+2      	; 0x7a8 <DIO_voidSetPinDir+0x6>
 7a6:	6f c0       	rjmp	.+222    	; 0x886 <__stack+0x27>
 7a8:	41 30       	cpi	r20, 0x01	; 1
 7aa:	a1 f5       	brne	.+104    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
 7ac:	81 30       	cpi	r24, 0x01	; 1
 7ae:	89 f0       	breq	.+34     	; 0x7d2 <DIO_voidSetPinDir+0x30>
 7b0:	28 f0       	brcs	.+10     	; 0x7bc <DIO_voidSetPinDir+0x1a>
 7b2:	82 30       	cpi	r24, 0x02	; 2
 7b4:	c9 f0       	breq	.+50     	; 0x7e8 <DIO_voidSetPinDir+0x46>
 7b6:	83 30       	cpi	r24, 0x03	; 3
 7b8:	11 f1       	breq	.+68     	; 0x7fe <DIO_voidSetPinDir+0x5c>
 7ba:	08 95       	ret
 7bc:	2a b3       	in	r18, 0x1a	; 26
 7be:	81 e0       	ldi	r24, 0x01	; 1
 7c0:	90 e0       	ldi	r25, 0x00	; 0
 7c2:	02 c0       	rjmp	.+4      	; 0x7c8 <DIO_voidSetPinDir+0x26>
 7c4:	88 0f       	add	r24, r24
 7c6:	99 1f       	adc	r25, r25
 7c8:	6a 95       	dec	r22
 7ca:	e2 f7       	brpl	.-8      	; 0x7c4 <DIO_voidSetPinDir+0x22>
 7cc:	82 2b       	or	r24, r18
 7ce:	8a bb       	out	0x1a, r24	; 26
 7d0:	08 95       	ret
 7d2:	27 b3       	in	r18, 0x17	; 23
 7d4:	81 e0       	ldi	r24, 0x01	; 1
 7d6:	90 e0       	ldi	r25, 0x00	; 0
 7d8:	02 c0       	rjmp	.+4      	; 0x7de <DIO_voidSetPinDir+0x3c>
 7da:	88 0f       	add	r24, r24
 7dc:	99 1f       	adc	r25, r25
 7de:	6a 95       	dec	r22
 7e0:	e2 f7       	brpl	.-8      	; 0x7da <DIO_voidSetPinDir+0x38>
 7e2:	82 2b       	or	r24, r18
 7e4:	87 bb       	out	0x17, r24	; 23
 7e6:	08 95       	ret
 7e8:	24 b3       	in	r18, 0x14	; 20
 7ea:	81 e0       	ldi	r24, 0x01	; 1
 7ec:	90 e0       	ldi	r25, 0x00	; 0
 7ee:	02 c0       	rjmp	.+4      	; 0x7f4 <DIO_voidSetPinDir+0x52>
 7f0:	88 0f       	add	r24, r24
 7f2:	99 1f       	adc	r25, r25
 7f4:	6a 95       	dec	r22
 7f6:	e2 f7       	brpl	.-8      	; 0x7f0 <DIO_voidSetPinDir+0x4e>
 7f8:	82 2b       	or	r24, r18
 7fa:	84 bb       	out	0x14, r24	; 20
 7fc:	08 95       	ret
 7fe:	21 b3       	in	r18, 0x11	; 17
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	90 e0       	ldi	r25, 0x00	; 0
 804:	02 c0       	rjmp	.+4      	; 0x80a <__DATA_REGION_LENGTH__+0xa>
 806:	88 0f       	add	r24, r24
 808:	99 1f       	adc	r25, r25
 80a:	6a 95       	dec	r22
 80c:	e2 f7       	brpl	.-8      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
 80e:	82 2b       	or	r24, r18
 810:	81 bb       	out	0x11, r24	; 17
 812:	08 95       	ret
 814:	41 11       	cpse	r20, r1
 816:	37 c0       	rjmp	.+110    	; 0x886 <__stack+0x27>
 818:	81 30       	cpi	r24, 0x01	; 1
 81a:	91 f0       	breq	.+36     	; 0x840 <__DATA_REGION_LENGTH__+0x40>
 81c:	28 f0       	brcs	.+10     	; 0x828 <__DATA_REGION_LENGTH__+0x28>
 81e:	82 30       	cpi	r24, 0x02	; 2
 820:	d9 f0       	breq	.+54     	; 0x858 <__DATA_REGION_LENGTH__+0x58>
 822:	83 30       	cpi	r24, 0x03	; 3
 824:	29 f1       	breq	.+74     	; 0x870 <__stack+0x11>
 826:	08 95       	ret
 828:	2a b3       	in	r18, 0x1a	; 26
 82a:	81 e0       	ldi	r24, 0x01	; 1
 82c:	90 e0       	ldi	r25, 0x00	; 0
 82e:	02 c0       	rjmp	.+4      	; 0x834 <__DATA_REGION_LENGTH__+0x34>
 830:	88 0f       	add	r24, r24
 832:	99 1f       	adc	r25, r25
 834:	6a 95       	dec	r22
 836:	e2 f7       	brpl	.-8      	; 0x830 <__DATA_REGION_LENGTH__+0x30>
 838:	80 95       	com	r24
 83a:	82 23       	and	r24, r18
 83c:	8a bb       	out	0x1a, r24	; 26
 83e:	08 95       	ret
 840:	27 b3       	in	r18, 0x17	; 23
 842:	81 e0       	ldi	r24, 0x01	; 1
 844:	90 e0       	ldi	r25, 0x00	; 0
 846:	02 c0       	rjmp	.+4      	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
 848:	88 0f       	add	r24, r24
 84a:	99 1f       	adc	r25, r25
 84c:	6a 95       	dec	r22
 84e:	e2 f7       	brpl	.-8      	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 850:	80 95       	com	r24
 852:	82 23       	and	r24, r18
 854:	87 bb       	out	0x17, r24	; 23
 856:	08 95       	ret
 858:	24 b3       	in	r18, 0x14	; 20
 85a:	81 e0       	ldi	r24, 0x01	; 1
 85c:	90 e0       	ldi	r25, 0x00	; 0
 85e:	02 c0       	rjmp	.+4      	; 0x864 <__stack+0x5>
 860:	88 0f       	add	r24, r24
 862:	99 1f       	adc	r25, r25
 864:	6a 95       	dec	r22
 866:	e2 f7       	brpl	.-8      	; 0x860 <__stack+0x1>
 868:	80 95       	com	r24
 86a:	82 23       	and	r24, r18
 86c:	84 bb       	out	0x14, r24	; 20
 86e:	08 95       	ret
 870:	21 b3       	in	r18, 0x11	; 17
 872:	81 e0       	ldi	r24, 0x01	; 1
 874:	90 e0       	ldi	r25, 0x00	; 0
 876:	02 c0       	rjmp	.+4      	; 0x87c <__stack+0x1d>
 878:	88 0f       	add	r24, r24
 87a:	99 1f       	adc	r25, r25
 87c:	6a 95       	dec	r22
 87e:	e2 f7       	brpl	.-8      	; 0x878 <__stack+0x19>
 880:	80 95       	com	r24
 882:	82 23       	and	r24, r18
 884:	81 bb       	out	0x11, r24	; 17
 886:	08 95       	ret

00000888 <DIO_voidSetPinVal>:
 888:	42 30       	cpi	r20, 0x02	; 2
 88a:	08 f0       	brcs	.+2      	; 0x88e <DIO_voidSetPinVal+0x6>
 88c:	6f c0       	rjmp	.+222    	; 0x96c <DIO_voidSetPinVal+0xe4>
 88e:	41 30       	cpi	r20, 0x01	; 1
 890:	a1 f5       	brne	.+104    	; 0x8fa <DIO_voidSetPinVal+0x72>
 892:	81 30       	cpi	r24, 0x01	; 1
 894:	89 f0       	breq	.+34     	; 0x8b8 <DIO_voidSetPinVal+0x30>
 896:	28 f0       	brcs	.+10     	; 0x8a2 <DIO_voidSetPinVal+0x1a>
 898:	82 30       	cpi	r24, 0x02	; 2
 89a:	c9 f0       	breq	.+50     	; 0x8ce <DIO_voidSetPinVal+0x46>
 89c:	83 30       	cpi	r24, 0x03	; 3
 89e:	11 f1       	breq	.+68     	; 0x8e4 <DIO_voidSetPinVal+0x5c>
 8a0:	08 95       	ret
 8a2:	2b b3       	in	r18, 0x1b	; 27
 8a4:	81 e0       	ldi	r24, 0x01	; 1
 8a6:	90 e0       	ldi	r25, 0x00	; 0
 8a8:	02 c0       	rjmp	.+4      	; 0x8ae <DIO_voidSetPinVal+0x26>
 8aa:	88 0f       	add	r24, r24
 8ac:	99 1f       	adc	r25, r25
 8ae:	6a 95       	dec	r22
 8b0:	e2 f7       	brpl	.-8      	; 0x8aa <DIO_voidSetPinVal+0x22>
 8b2:	82 2b       	or	r24, r18
 8b4:	8b bb       	out	0x1b, r24	; 27
 8b6:	08 95       	ret
 8b8:	28 b3       	in	r18, 0x18	; 24
 8ba:	81 e0       	ldi	r24, 0x01	; 1
 8bc:	90 e0       	ldi	r25, 0x00	; 0
 8be:	02 c0       	rjmp	.+4      	; 0x8c4 <DIO_voidSetPinVal+0x3c>
 8c0:	88 0f       	add	r24, r24
 8c2:	99 1f       	adc	r25, r25
 8c4:	6a 95       	dec	r22
 8c6:	e2 f7       	brpl	.-8      	; 0x8c0 <DIO_voidSetPinVal+0x38>
 8c8:	82 2b       	or	r24, r18
 8ca:	88 bb       	out	0x18, r24	; 24
 8cc:	08 95       	ret
 8ce:	25 b3       	in	r18, 0x15	; 21
 8d0:	81 e0       	ldi	r24, 0x01	; 1
 8d2:	90 e0       	ldi	r25, 0x00	; 0
 8d4:	02 c0       	rjmp	.+4      	; 0x8da <DIO_voidSetPinVal+0x52>
 8d6:	88 0f       	add	r24, r24
 8d8:	99 1f       	adc	r25, r25
 8da:	6a 95       	dec	r22
 8dc:	e2 f7       	brpl	.-8      	; 0x8d6 <DIO_voidSetPinVal+0x4e>
 8de:	82 2b       	or	r24, r18
 8e0:	85 bb       	out	0x15, r24	; 21
 8e2:	08 95       	ret
 8e4:	22 b3       	in	r18, 0x12	; 18
 8e6:	81 e0       	ldi	r24, 0x01	; 1
 8e8:	90 e0       	ldi	r25, 0x00	; 0
 8ea:	02 c0       	rjmp	.+4      	; 0x8f0 <DIO_voidSetPinVal+0x68>
 8ec:	88 0f       	add	r24, r24
 8ee:	99 1f       	adc	r25, r25
 8f0:	6a 95       	dec	r22
 8f2:	e2 f7       	brpl	.-8      	; 0x8ec <DIO_voidSetPinVal+0x64>
 8f4:	82 2b       	or	r24, r18
 8f6:	82 bb       	out	0x12, r24	; 18
 8f8:	08 95       	ret
 8fa:	41 11       	cpse	r20, r1
 8fc:	37 c0       	rjmp	.+110    	; 0x96c <DIO_voidSetPinVal+0xe4>
 8fe:	81 30       	cpi	r24, 0x01	; 1
 900:	91 f0       	breq	.+36     	; 0x926 <DIO_voidSetPinVal+0x9e>
 902:	28 f0       	brcs	.+10     	; 0x90e <DIO_voidSetPinVal+0x86>
 904:	82 30       	cpi	r24, 0x02	; 2
 906:	d9 f0       	breq	.+54     	; 0x93e <DIO_voidSetPinVal+0xb6>
 908:	83 30       	cpi	r24, 0x03	; 3
 90a:	29 f1       	breq	.+74     	; 0x956 <DIO_voidSetPinVal+0xce>
 90c:	08 95       	ret
 90e:	2b b3       	in	r18, 0x1b	; 27
 910:	81 e0       	ldi	r24, 0x01	; 1
 912:	90 e0       	ldi	r25, 0x00	; 0
 914:	02 c0       	rjmp	.+4      	; 0x91a <DIO_voidSetPinVal+0x92>
 916:	88 0f       	add	r24, r24
 918:	99 1f       	adc	r25, r25
 91a:	6a 95       	dec	r22
 91c:	e2 f7       	brpl	.-8      	; 0x916 <DIO_voidSetPinVal+0x8e>
 91e:	80 95       	com	r24
 920:	82 23       	and	r24, r18
 922:	8b bb       	out	0x1b, r24	; 27
 924:	08 95       	ret
 926:	28 b3       	in	r18, 0x18	; 24
 928:	81 e0       	ldi	r24, 0x01	; 1
 92a:	90 e0       	ldi	r25, 0x00	; 0
 92c:	02 c0       	rjmp	.+4      	; 0x932 <DIO_voidSetPinVal+0xaa>
 92e:	88 0f       	add	r24, r24
 930:	99 1f       	adc	r25, r25
 932:	6a 95       	dec	r22
 934:	e2 f7       	brpl	.-8      	; 0x92e <DIO_voidSetPinVal+0xa6>
 936:	80 95       	com	r24
 938:	82 23       	and	r24, r18
 93a:	88 bb       	out	0x18, r24	; 24
 93c:	08 95       	ret
 93e:	25 b3       	in	r18, 0x15	; 21
 940:	81 e0       	ldi	r24, 0x01	; 1
 942:	90 e0       	ldi	r25, 0x00	; 0
 944:	02 c0       	rjmp	.+4      	; 0x94a <DIO_voidSetPinVal+0xc2>
 946:	88 0f       	add	r24, r24
 948:	99 1f       	adc	r25, r25
 94a:	6a 95       	dec	r22
 94c:	e2 f7       	brpl	.-8      	; 0x946 <DIO_voidSetPinVal+0xbe>
 94e:	80 95       	com	r24
 950:	82 23       	and	r24, r18
 952:	85 bb       	out	0x15, r24	; 21
 954:	08 95       	ret
 956:	22 b3       	in	r18, 0x12	; 18
 958:	81 e0       	ldi	r24, 0x01	; 1
 95a:	90 e0       	ldi	r25, 0x00	; 0
 95c:	02 c0       	rjmp	.+4      	; 0x962 <DIO_voidSetPinVal+0xda>
 95e:	88 0f       	add	r24, r24
 960:	99 1f       	adc	r25, r25
 962:	6a 95       	dec	r22
 964:	e2 f7       	brpl	.-8      	; 0x95e <DIO_voidSetPinVal+0xd6>
 966:	80 95       	com	r24
 968:	82 23       	and	r24, r18
 96a:	82 bb       	out	0x12, r24	; 18
 96c:	08 95       	ret

0000096e <DIO_u8ReadpinVal>:

u8 DIO_u8ReadpinVal(u8 copy_u8port, u8 copy_u8pin){
	
	 u8 Loc_u8Val=0 ; 
	 
	  switch(copy_u8port){
 96e:	81 30       	cpi	r24, 0x01	; 1
 970:	79 f0       	breq	.+30     	; 0x990 <DIO_u8ReadpinVal+0x22>
 972:	28 f0       	brcs	.+10     	; 0x97e <DIO_u8ReadpinVal+0x10>
 974:	82 30       	cpi	r24, 0x02	; 2
 976:	a9 f0       	breq	.+42     	; 0x9a2 <DIO_u8ReadpinVal+0x34>
 978:	83 30       	cpi	r24, 0x03	; 3
 97a:	e1 f0       	breq	.+56     	; 0x9b4 <DIO_u8ReadpinVal+0x46>
 97c:	24 c0       	rjmp	.+72     	; 0x9c6 <DIO_u8ReadpinVal+0x58>
		  
		  case DIO_PORTA:Loc_u8Val = GET_BIT(PINA_REG,copy_u8pin) ; break;
 97e:	89 b3       	in	r24, 0x19	; 25
 980:	90 e0       	ldi	r25, 0x00	; 0
 982:	02 c0       	rjmp	.+4      	; 0x988 <DIO_u8ReadpinVal+0x1a>
 984:	95 95       	asr	r25
 986:	87 95       	ror	r24
 988:	6a 95       	dec	r22
 98a:	e2 f7       	brpl	.-8      	; 0x984 <DIO_u8ReadpinVal+0x16>
 98c:	81 70       	andi	r24, 0x01	; 1
 98e:	08 95       	ret
		  case DIO_PORTB:Loc_u8Val = GET_BIT(PINB_REG,copy_u8pin) ; break;
 990:	86 b3       	in	r24, 0x16	; 22
 992:	90 e0       	ldi	r25, 0x00	; 0
 994:	02 c0       	rjmp	.+4      	; 0x99a <DIO_u8ReadpinVal+0x2c>
 996:	95 95       	asr	r25
 998:	87 95       	ror	r24
 99a:	6a 95       	dec	r22
 99c:	e2 f7       	brpl	.-8      	; 0x996 <DIO_u8ReadpinVal+0x28>
 99e:	81 70       	andi	r24, 0x01	; 1
 9a0:	08 95       	ret
		  case DIO_PORTC:Loc_u8Val = GET_BIT(PINC_REG,copy_u8pin) ; break;
 9a2:	83 b3       	in	r24, 0x13	; 19
 9a4:	90 e0       	ldi	r25, 0x00	; 0
 9a6:	02 c0       	rjmp	.+4      	; 0x9ac <DIO_u8ReadpinVal+0x3e>
 9a8:	95 95       	asr	r25
 9aa:	87 95       	ror	r24
 9ac:	6a 95       	dec	r22
 9ae:	e2 f7       	brpl	.-8      	; 0x9a8 <DIO_u8ReadpinVal+0x3a>
 9b0:	81 70       	andi	r24, 0x01	; 1
 9b2:	08 95       	ret
		  case DIO_PORTD:Loc_u8Val = GET_BIT(PIND_REG,copy_u8pin) ; break ;
 9b4:	80 b3       	in	r24, 0x10	; 16
 9b6:	90 e0       	ldi	r25, 0x00	; 0
 9b8:	02 c0       	rjmp	.+4      	; 0x9be <DIO_u8ReadpinVal+0x50>
 9ba:	95 95       	asr	r25
 9bc:	87 95       	ror	r24
 9be:	6a 95       	dec	r22
 9c0:	e2 f7       	brpl	.-8      	; 0x9ba <DIO_u8ReadpinVal+0x4c>
 9c2:	81 70       	andi	r24, 0x01	; 1
 9c4:	08 95       	ret
	
}

u8 DIO_u8ReadpinVal(u8 copy_u8port, u8 copy_u8pin){
	
	 u8 Loc_u8Val=0 ; 
 9c6:	80 e0       	ldi	r24, 0x00	; 0
	
	
	return Loc_u8Val ; 
	
	
}
 9c8:	08 95       	ret

000009ca <DIO_voidSetPortDir>:


void DIO_voidSetPortDir(u8 copy_u8port, u8 copy_u8dir){
	
	switch(copy_u8port){
 9ca:	81 30       	cpi	r24, 0x01	; 1
 9cc:	41 f0       	breq	.+16     	; 0x9de <DIO_voidSetPortDir+0x14>
 9ce:	28 f0       	brcs	.+10     	; 0x9da <DIO_voidSetPortDir+0x10>
 9d0:	82 30       	cpi	r24, 0x02	; 2
 9d2:	39 f0       	breq	.+14     	; 0x9e2 <DIO_voidSetPortDir+0x18>
 9d4:	83 30       	cpi	r24, 0x03	; 3
 9d6:	39 f0       	breq	.+14     	; 0x9e6 <DIO_voidSetPortDir+0x1c>
 9d8:	08 95       	ret
		
		case DIO_PORTA: DDRA_REG=copy_u8dir ;break ; 
 9da:	6a bb       	out	0x1a, r22	; 26
 9dc:	08 95       	ret
		case DIO_PORTB: DDRB_REG=copy_u8dir ;break ;
 9de:	67 bb       	out	0x17, r22	; 23
 9e0:	08 95       	ret
		case DIO_PORTC: DDRC_REG=copy_u8dir ;break ;
 9e2:	64 bb       	out	0x14, r22	; 20
 9e4:	08 95       	ret
		case DIO_PORTD: DDRD_REG=copy_u8dir ;break ;
 9e6:	61 bb       	out	0x11, r22	; 17
 9e8:	08 95       	ret

000009ea <TIMER0_voidFastPWM>:
void TIMER0_voidSetCallBack(void(*ptr)(void), u8 copy_u8mode){
	
	switch(copy_u8mode){
		
		case OV_MODE : TIM0_PTR[0]=ptr ; break;
		case CTC_MODE : TIM0_PTR[1]=ptr; break; 
 9ea:	93 b7       	in	r25, 0x33	; 51
 9ec:	98 60       	ori	r25, 0x08	; 8
 9ee:	93 bf       	out	0x33, r25	; 51
 9f0:	93 b7       	in	r25, 0x33	; 51
 9f2:	90 64       	ori	r25, 0x40	; 64
 9f4:	93 bf       	out	0x33, r25	; 51
 9f6:	93 b7       	in	r25, 0x33	; 51
 9f8:	90 62       	ori	r25, 0x20	; 32
 9fa:	93 bf       	out	0x33, r25	; 51
 9fc:	93 b7       	in	r25, 0x33	; 51
 9fe:	9f 7e       	andi	r25, 0xEF	; 239
 a00:	93 bf       	out	0x33, r25	; 51
 a02:	93 b7       	in	r25, 0x33	; 51
 a04:	98 7f       	andi	r25, 0xF8	; 248
 a06:	93 bf       	out	0x33, r25	; 51
 a08:	93 b7       	in	r25, 0x33	; 51
 a0a:	93 60       	ori	r25, 0x03	; 3
 a0c:	93 bf       	out	0x33, r25	; 51
 a0e:	68 2f       	mov	r22, r24
 a10:	70 e0       	ldi	r23, 0x00	; 0
 a12:	80 e0       	ldi	r24, 0x00	; 0
 a14:	90 e0       	ldi	r25, 0x00	; 0
 a16:	0e 94 9b 05 	call	0xb36	; 0xb36 <__floatsisf>
 a1a:	2a e0       	ldi	r18, 0x0A	; 10
 a1c:	37 ed       	ldi	r19, 0xD7	; 215
 a1e:	43 e2       	ldi	r20, 0x23	; 35
 a20:	50 e4       	ldi	r21, 0x40	; 64
 a22:	0e 94 28 06 	call	0xc50	; 0xc50 <__mulsf3>
 a26:	0e 94 6a 05 	call	0xad4	; 0xad4 <__fixunssfsi>
 a2a:	6c bf       	out	0x3c, r22	; 60
 a2c:	08 95       	ret

00000a2e <__vector_11>:
			}
	
}

void __vector_11(void)__attribute__((signal)) ;
void __vector_11(void){
 a2e:	1f 92       	push	r1
 a30:	0f 92       	push	r0
 a32:	0f b6       	in	r0, 0x3f	; 63
 a34:	0f 92       	push	r0
 a36:	11 24       	eor	r1, r1
 a38:	2f 93       	push	r18
 a3a:	3f 93       	push	r19
 a3c:	4f 93       	push	r20
 a3e:	5f 93       	push	r21
 a40:	6f 93       	push	r22
 a42:	7f 93       	push	r23
 a44:	8f 93       	push	r24
 a46:	9f 93       	push	r25
 a48:	af 93       	push	r26
 a4a:	bf 93       	push	r27
 a4c:	ef 93       	push	r30
 a4e:	ff 93       	push	r31
	

TIM0_PTR[0]() ; 
 a50:	e0 91 30 01 	lds	r30, 0x0130	; 0x800130 <__data_end>
 a54:	f0 91 31 01 	lds	r31, 0x0131	; 0x800131 <__data_end+0x1>
 a58:	09 95       	icall


}
 a5a:	ff 91       	pop	r31
 a5c:	ef 91       	pop	r30
 a5e:	bf 91       	pop	r27
 a60:	af 91       	pop	r26
 a62:	9f 91       	pop	r25
 a64:	8f 91       	pop	r24
 a66:	7f 91       	pop	r23
 a68:	6f 91       	pop	r22
 a6a:	5f 91       	pop	r21
 a6c:	4f 91       	pop	r20
 a6e:	3f 91       	pop	r19
 a70:	2f 91       	pop	r18
 a72:	0f 90       	pop	r0
 a74:	0f be       	out	0x3f, r0	; 63
 a76:	0f 90       	pop	r0
 a78:	1f 90       	pop	r1
 a7a:	18 95       	reti

00000a7c <__vector_10>:


*/

void __vector_10(void)__attribute__((signal)) ;
void __vector_10(void){
 a7c:	1f 92       	push	r1
 a7e:	0f 92       	push	r0
 a80:	0f b6       	in	r0, 0x3f	; 63
 a82:	0f 92       	push	r0
 a84:	11 24       	eor	r1, r1
 a86:	2f 93       	push	r18
 a88:	3f 93       	push	r19
 a8a:	4f 93       	push	r20
 a8c:	5f 93       	push	r21
 a8e:	6f 93       	push	r22
 a90:	7f 93       	push	r23
 a92:	8f 93       	push	r24
 a94:	9f 93       	push	r25
 a96:	af 93       	push	r26
 a98:	bf 93       	push	r27
 a9a:	ef 93       	push	r30
 a9c:	ff 93       	push	r31
	

TIM0_PTR[1]() ;
 a9e:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <__data_end+0x2>
 aa2:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <__data_end+0x3>
 aa6:	09 95       	icall

 aa8:	ff 91       	pop	r31
 aaa:	ef 91       	pop	r30
 aac:	bf 91       	pop	r27
 aae:	af 91       	pop	r26
 ab0:	9f 91       	pop	r25
 ab2:	8f 91       	pop	r24
 ab4:	7f 91       	pop	r23
 ab6:	6f 91       	pop	r22
 ab8:	5f 91       	pop	r21
 aba:	4f 91       	pop	r20
 abc:	3f 91       	pop	r19
 abe:	2f 91       	pop	r18
 ac0:	0f 90       	pop	r0
 ac2:	0f be       	out	0x3f, r0	; 63
 ac4:	0f 90       	pop	r0
 ac6:	1f 90       	pop	r1
 ac8:	18 95       	reti

00000aca <__cmpsf2>:
 aca:	0e 94 d6 05 	call	0xbac	; 0xbac <__fp_cmp>
 ace:	08 f4       	brcc	.+2      	; 0xad2 <__cmpsf2+0x8>
 ad0:	81 e0       	ldi	r24, 0x01	; 1
 ad2:	08 95       	ret

00000ad4 <__fixunssfsi>:
 ad4:	0e 94 02 06 	call	0xc04	; 0xc04 <__fp_splitA>
 ad8:	88 f0       	brcs	.+34     	; 0xafc <__fixunssfsi+0x28>
 ada:	9f 57       	subi	r25, 0x7F	; 127
 adc:	98 f0       	brcs	.+38     	; 0xb04 <__fixunssfsi+0x30>
 ade:	b9 2f       	mov	r27, r25
 ae0:	99 27       	eor	r25, r25
 ae2:	b7 51       	subi	r27, 0x17	; 23
 ae4:	b0 f0       	brcs	.+44     	; 0xb12 <__fixunssfsi+0x3e>
 ae6:	e1 f0       	breq	.+56     	; 0xb20 <__fixunssfsi+0x4c>
 ae8:	66 0f       	add	r22, r22
 aea:	77 1f       	adc	r23, r23
 aec:	88 1f       	adc	r24, r24
 aee:	99 1f       	adc	r25, r25
 af0:	1a f0       	brmi	.+6      	; 0xaf8 <__fixunssfsi+0x24>
 af2:	ba 95       	dec	r27
 af4:	c9 f7       	brne	.-14     	; 0xae8 <__fixunssfsi+0x14>
 af6:	14 c0       	rjmp	.+40     	; 0xb20 <__fixunssfsi+0x4c>
 af8:	b1 30       	cpi	r27, 0x01	; 1
 afa:	91 f0       	breq	.+36     	; 0xb20 <__fixunssfsi+0x4c>
 afc:	0e 94 1c 06 	call	0xc38	; 0xc38 <__fp_zero>
 b00:	b1 e0       	ldi	r27, 0x01	; 1
 b02:	08 95       	ret
 b04:	0c 94 1c 06 	jmp	0xc38	; 0xc38 <__fp_zero>
 b08:	67 2f       	mov	r22, r23
 b0a:	78 2f       	mov	r23, r24
 b0c:	88 27       	eor	r24, r24
 b0e:	b8 5f       	subi	r27, 0xF8	; 248
 b10:	39 f0       	breq	.+14     	; 0xb20 <__fixunssfsi+0x4c>
 b12:	b9 3f       	cpi	r27, 0xF9	; 249
 b14:	cc f3       	brlt	.-14     	; 0xb08 <__fixunssfsi+0x34>
 b16:	86 95       	lsr	r24
 b18:	77 95       	ror	r23
 b1a:	67 95       	ror	r22
 b1c:	b3 95       	inc	r27
 b1e:	d9 f7       	brne	.-10     	; 0xb16 <__fixunssfsi+0x42>
 b20:	3e f4       	brtc	.+14     	; 0xb30 <__fixunssfsi+0x5c>
 b22:	90 95       	com	r25
 b24:	80 95       	com	r24
 b26:	70 95       	com	r23
 b28:	61 95       	neg	r22
 b2a:	7f 4f       	sbci	r23, 0xFF	; 255
 b2c:	8f 4f       	sbci	r24, 0xFF	; 255
 b2e:	9f 4f       	sbci	r25, 0xFF	; 255
 b30:	08 95       	ret

00000b32 <__floatunsisf>:
 b32:	e8 94       	clt
 b34:	09 c0       	rjmp	.+18     	; 0xb48 <__floatsisf+0x12>

00000b36 <__floatsisf>:
 b36:	97 fb       	bst	r25, 7
 b38:	3e f4       	brtc	.+14     	; 0xb48 <__floatsisf+0x12>
 b3a:	90 95       	com	r25
 b3c:	80 95       	com	r24
 b3e:	70 95       	com	r23
 b40:	61 95       	neg	r22
 b42:	7f 4f       	sbci	r23, 0xFF	; 255
 b44:	8f 4f       	sbci	r24, 0xFF	; 255
 b46:	9f 4f       	sbci	r25, 0xFF	; 255
 b48:	99 23       	and	r25, r25
 b4a:	a9 f0       	breq	.+42     	; 0xb76 <__floatsisf+0x40>
 b4c:	f9 2f       	mov	r31, r25
 b4e:	96 e9       	ldi	r25, 0x96	; 150
 b50:	bb 27       	eor	r27, r27
 b52:	93 95       	inc	r25
 b54:	f6 95       	lsr	r31
 b56:	87 95       	ror	r24
 b58:	77 95       	ror	r23
 b5a:	67 95       	ror	r22
 b5c:	b7 95       	ror	r27
 b5e:	f1 11       	cpse	r31, r1
 b60:	f8 cf       	rjmp	.-16     	; 0xb52 <__floatsisf+0x1c>
 b62:	fa f4       	brpl	.+62     	; 0xba2 <__floatsisf+0x6c>
 b64:	bb 0f       	add	r27, r27
 b66:	11 f4       	brne	.+4      	; 0xb6c <__floatsisf+0x36>
 b68:	60 ff       	sbrs	r22, 0
 b6a:	1b c0       	rjmp	.+54     	; 0xba2 <__floatsisf+0x6c>
 b6c:	6f 5f       	subi	r22, 0xFF	; 255
 b6e:	7f 4f       	sbci	r23, 0xFF	; 255
 b70:	8f 4f       	sbci	r24, 0xFF	; 255
 b72:	9f 4f       	sbci	r25, 0xFF	; 255
 b74:	16 c0       	rjmp	.+44     	; 0xba2 <__floatsisf+0x6c>
 b76:	88 23       	and	r24, r24
 b78:	11 f0       	breq	.+4      	; 0xb7e <__floatsisf+0x48>
 b7a:	96 e9       	ldi	r25, 0x96	; 150
 b7c:	11 c0       	rjmp	.+34     	; 0xba0 <__floatsisf+0x6a>
 b7e:	77 23       	and	r23, r23
 b80:	21 f0       	breq	.+8      	; 0xb8a <__floatsisf+0x54>
 b82:	9e e8       	ldi	r25, 0x8E	; 142
 b84:	87 2f       	mov	r24, r23
 b86:	76 2f       	mov	r23, r22
 b88:	05 c0       	rjmp	.+10     	; 0xb94 <__floatsisf+0x5e>
 b8a:	66 23       	and	r22, r22
 b8c:	71 f0       	breq	.+28     	; 0xbaa <__floatsisf+0x74>
 b8e:	96 e8       	ldi	r25, 0x86	; 134
 b90:	86 2f       	mov	r24, r22
 b92:	70 e0       	ldi	r23, 0x00	; 0
 b94:	60 e0       	ldi	r22, 0x00	; 0
 b96:	2a f0       	brmi	.+10     	; 0xba2 <__floatsisf+0x6c>
 b98:	9a 95       	dec	r25
 b9a:	66 0f       	add	r22, r22
 b9c:	77 1f       	adc	r23, r23
 b9e:	88 1f       	adc	r24, r24
 ba0:	da f7       	brpl	.-10     	; 0xb98 <__floatsisf+0x62>
 ba2:	88 0f       	add	r24, r24
 ba4:	96 95       	lsr	r25
 ba6:	87 95       	ror	r24
 ba8:	97 f9       	bld	r25, 7
 baa:	08 95       	ret

00000bac <__fp_cmp>:
 bac:	99 0f       	add	r25, r25
 bae:	00 08       	sbc	r0, r0
 bb0:	55 0f       	add	r21, r21
 bb2:	aa 0b       	sbc	r26, r26
 bb4:	e0 e8       	ldi	r30, 0x80	; 128
 bb6:	fe ef       	ldi	r31, 0xFE	; 254
 bb8:	16 16       	cp	r1, r22
 bba:	17 06       	cpc	r1, r23
 bbc:	e8 07       	cpc	r30, r24
 bbe:	f9 07       	cpc	r31, r25
 bc0:	c0 f0       	brcs	.+48     	; 0xbf2 <__fp_cmp+0x46>
 bc2:	12 16       	cp	r1, r18
 bc4:	13 06       	cpc	r1, r19
 bc6:	e4 07       	cpc	r30, r20
 bc8:	f5 07       	cpc	r31, r21
 bca:	98 f0       	brcs	.+38     	; 0xbf2 <__fp_cmp+0x46>
 bcc:	62 1b       	sub	r22, r18
 bce:	73 0b       	sbc	r23, r19
 bd0:	84 0b       	sbc	r24, r20
 bd2:	95 0b       	sbc	r25, r21
 bd4:	39 f4       	brne	.+14     	; 0xbe4 <__fp_cmp+0x38>
 bd6:	0a 26       	eor	r0, r26
 bd8:	61 f0       	breq	.+24     	; 0xbf2 <__fp_cmp+0x46>
 bda:	23 2b       	or	r18, r19
 bdc:	24 2b       	or	r18, r20
 bde:	25 2b       	or	r18, r21
 be0:	21 f4       	brne	.+8      	; 0xbea <__fp_cmp+0x3e>
 be2:	08 95       	ret
 be4:	0a 26       	eor	r0, r26
 be6:	09 f4       	brne	.+2      	; 0xbea <__fp_cmp+0x3e>
 be8:	a1 40       	sbci	r26, 0x01	; 1
 bea:	a6 95       	lsr	r26
 bec:	8f ef       	ldi	r24, 0xFF	; 255
 bee:	81 1d       	adc	r24, r1
 bf0:	81 1d       	adc	r24, r1
 bf2:	08 95       	ret

00000bf4 <__fp_split3>:
 bf4:	57 fd       	sbrc	r21, 7
 bf6:	90 58       	subi	r25, 0x80	; 128
 bf8:	44 0f       	add	r20, r20
 bfa:	55 1f       	adc	r21, r21
 bfc:	59 f0       	breq	.+22     	; 0xc14 <__fp_splitA+0x10>
 bfe:	5f 3f       	cpi	r21, 0xFF	; 255
 c00:	71 f0       	breq	.+28     	; 0xc1e <__fp_splitA+0x1a>
 c02:	47 95       	ror	r20

00000c04 <__fp_splitA>:
 c04:	88 0f       	add	r24, r24
 c06:	97 fb       	bst	r25, 7
 c08:	99 1f       	adc	r25, r25
 c0a:	61 f0       	breq	.+24     	; 0xc24 <__fp_splitA+0x20>
 c0c:	9f 3f       	cpi	r25, 0xFF	; 255
 c0e:	79 f0       	breq	.+30     	; 0xc2e <__fp_splitA+0x2a>
 c10:	87 95       	ror	r24
 c12:	08 95       	ret
 c14:	12 16       	cp	r1, r18
 c16:	13 06       	cpc	r1, r19
 c18:	14 06       	cpc	r1, r20
 c1a:	55 1f       	adc	r21, r21
 c1c:	f2 cf       	rjmp	.-28     	; 0xc02 <__fp_split3+0xe>
 c1e:	46 95       	lsr	r20
 c20:	f1 df       	rcall	.-30     	; 0xc04 <__fp_splitA>
 c22:	08 c0       	rjmp	.+16     	; 0xc34 <__fp_splitA+0x30>
 c24:	16 16       	cp	r1, r22
 c26:	17 06       	cpc	r1, r23
 c28:	18 06       	cpc	r1, r24
 c2a:	99 1f       	adc	r25, r25
 c2c:	f1 cf       	rjmp	.-30     	; 0xc10 <__fp_splitA+0xc>
 c2e:	86 95       	lsr	r24
 c30:	71 05       	cpc	r23, r1
 c32:	61 05       	cpc	r22, r1
 c34:	08 94       	sec
 c36:	08 95       	ret

00000c38 <__fp_zero>:
 c38:	e8 94       	clt

00000c3a <__fp_szero>:
 c3a:	bb 27       	eor	r27, r27
 c3c:	66 27       	eor	r22, r22
 c3e:	77 27       	eor	r23, r23
 c40:	cb 01       	movw	r24, r22
 c42:	97 f9       	bld	r25, 7
 c44:	08 95       	ret

00000c46 <__gesf2>:
 c46:	0e 94 d6 05 	call	0xbac	; 0xbac <__fp_cmp>
 c4a:	08 f4       	brcc	.+2      	; 0xc4e <__gesf2+0x8>
 c4c:	8f ef       	ldi	r24, 0xFF	; 255
 c4e:	08 95       	ret

00000c50 <__mulsf3>:
 c50:	0e 94 3b 06 	call	0xc76	; 0xc76 <__mulsf3x>
 c54:	0c 94 ac 06 	jmp	0xd58	; 0xd58 <__fp_round>
 c58:	0e 94 9e 06 	call	0xd3c	; 0xd3c <__fp_pscA>
 c5c:	38 f0       	brcs	.+14     	; 0xc6c <__mulsf3+0x1c>
 c5e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <__fp_pscB>
 c62:	20 f0       	brcs	.+8      	; 0xc6c <__mulsf3+0x1c>
 c64:	95 23       	and	r25, r21
 c66:	11 f0       	breq	.+4      	; 0xc6c <__mulsf3+0x1c>
 c68:	0c 94 95 06 	jmp	0xd2a	; 0xd2a <__fp_inf>
 c6c:	0c 94 9b 06 	jmp	0xd36	; 0xd36 <__fp_nan>
 c70:	11 24       	eor	r1, r1
 c72:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_szero>

00000c76 <__mulsf3x>:
 c76:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <__fp_split3>
 c7a:	70 f3       	brcs	.-36     	; 0xc58 <__mulsf3+0x8>

00000c7c <__mulsf3_pse>:
 c7c:	95 9f       	mul	r25, r21
 c7e:	c1 f3       	breq	.-16     	; 0xc70 <__mulsf3+0x20>
 c80:	95 0f       	add	r25, r21
 c82:	50 e0       	ldi	r21, 0x00	; 0
 c84:	55 1f       	adc	r21, r21
 c86:	62 9f       	mul	r22, r18
 c88:	f0 01       	movw	r30, r0
 c8a:	72 9f       	mul	r23, r18
 c8c:	bb 27       	eor	r27, r27
 c8e:	f0 0d       	add	r31, r0
 c90:	b1 1d       	adc	r27, r1
 c92:	63 9f       	mul	r22, r19
 c94:	aa 27       	eor	r26, r26
 c96:	f0 0d       	add	r31, r0
 c98:	b1 1d       	adc	r27, r1
 c9a:	aa 1f       	adc	r26, r26
 c9c:	64 9f       	mul	r22, r20
 c9e:	66 27       	eor	r22, r22
 ca0:	b0 0d       	add	r27, r0
 ca2:	a1 1d       	adc	r26, r1
 ca4:	66 1f       	adc	r22, r22
 ca6:	82 9f       	mul	r24, r18
 ca8:	22 27       	eor	r18, r18
 caa:	b0 0d       	add	r27, r0
 cac:	a1 1d       	adc	r26, r1
 cae:	62 1f       	adc	r22, r18
 cb0:	73 9f       	mul	r23, r19
 cb2:	b0 0d       	add	r27, r0
 cb4:	a1 1d       	adc	r26, r1
 cb6:	62 1f       	adc	r22, r18
 cb8:	83 9f       	mul	r24, r19
 cba:	a0 0d       	add	r26, r0
 cbc:	61 1d       	adc	r22, r1
 cbe:	22 1f       	adc	r18, r18
 cc0:	74 9f       	mul	r23, r20
 cc2:	33 27       	eor	r19, r19
 cc4:	a0 0d       	add	r26, r0
 cc6:	61 1d       	adc	r22, r1
 cc8:	23 1f       	adc	r18, r19
 cca:	84 9f       	mul	r24, r20
 ccc:	60 0d       	add	r22, r0
 cce:	21 1d       	adc	r18, r1
 cd0:	82 2f       	mov	r24, r18
 cd2:	76 2f       	mov	r23, r22
 cd4:	6a 2f       	mov	r22, r26
 cd6:	11 24       	eor	r1, r1
 cd8:	9f 57       	subi	r25, 0x7F	; 127
 cda:	50 40       	sbci	r21, 0x00	; 0
 cdc:	9a f0       	brmi	.+38     	; 0xd04 <__mulsf3_pse+0x88>
 cde:	f1 f0       	breq	.+60     	; 0xd1c <__mulsf3_pse+0xa0>
 ce0:	88 23       	and	r24, r24
 ce2:	4a f0       	brmi	.+18     	; 0xcf6 <__mulsf3_pse+0x7a>
 ce4:	ee 0f       	add	r30, r30
 ce6:	ff 1f       	adc	r31, r31
 ce8:	bb 1f       	adc	r27, r27
 cea:	66 1f       	adc	r22, r22
 cec:	77 1f       	adc	r23, r23
 cee:	88 1f       	adc	r24, r24
 cf0:	91 50       	subi	r25, 0x01	; 1
 cf2:	50 40       	sbci	r21, 0x00	; 0
 cf4:	a9 f7       	brne	.-22     	; 0xce0 <__mulsf3_pse+0x64>
 cf6:	9e 3f       	cpi	r25, 0xFE	; 254
 cf8:	51 05       	cpc	r21, r1
 cfa:	80 f0       	brcs	.+32     	; 0xd1c <__mulsf3_pse+0xa0>
 cfc:	0c 94 95 06 	jmp	0xd2a	; 0xd2a <__fp_inf>
 d00:	0c 94 1d 06 	jmp	0xc3a	; 0xc3a <__fp_szero>
 d04:	5f 3f       	cpi	r21, 0xFF	; 255
 d06:	e4 f3       	brlt	.-8      	; 0xd00 <__mulsf3_pse+0x84>
 d08:	98 3e       	cpi	r25, 0xE8	; 232
 d0a:	d4 f3       	brlt	.-12     	; 0xd00 <__mulsf3_pse+0x84>
 d0c:	86 95       	lsr	r24
 d0e:	77 95       	ror	r23
 d10:	67 95       	ror	r22
 d12:	b7 95       	ror	r27
 d14:	f7 95       	ror	r31
 d16:	e7 95       	ror	r30
 d18:	9f 5f       	subi	r25, 0xFF	; 255
 d1a:	c1 f7       	brne	.-16     	; 0xd0c <__mulsf3_pse+0x90>
 d1c:	fe 2b       	or	r31, r30
 d1e:	88 0f       	add	r24, r24
 d20:	91 1d       	adc	r25, r1
 d22:	96 95       	lsr	r25
 d24:	87 95       	ror	r24
 d26:	97 f9       	bld	r25, 7
 d28:	08 95       	ret

00000d2a <__fp_inf>:
 d2a:	97 f9       	bld	r25, 7
 d2c:	9f 67       	ori	r25, 0x7F	; 127
 d2e:	80 e8       	ldi	r24, 0x80	; 128
 d30:	70 e0       	ldi	r23, 0x00	; 0
 d32:	60 e0       	ldi	r22, 0x00	; 0
 d34:	08 95       	ret

00000d36 <__fp_nan>:
 d36:	9f ef       	ldi	r25, 0xFF	; 255
 d38:	80 ec       	ldi	r24, 0xC0	; 192
 d3a:	08 95       	ret

00000d3c <__fp_pscA>:
 d3c:	00 24       	eor	r0, r0
 d3e:	0a 94       	dec	r0
 d40:	16 16       	cp	r1, r22
 d42:	17 06       	cpc	r1, r23
 d44:	18 06       	cpc	r1, r24
 d46:	09 06       	cpc	r0, r25
 d48:	08 95       	ret

00000d4a <__fp_pscB>:
 d4a:	00 24       	eor	r0, r0
 d4c:	0a 94       	dec	r0
 d4e:	12 16       	cp	r1, r18
 d50:	13 06       	cpc	r1, r19
 d52:	14 06       	cpc	r1, r20
 d54:	05 06       	cpc	r0, r21
 d56:	08 95       	ret

00000d58 <__fp_round>:
 d58:	09 2e       	mov	r0, r25
 d5a:	03 94       	inc	r0
 d5c:	00 0c       	add	r0, r0
 d5e:	11 f4       	brne	.+4      	; 0xd64 <__fp_round+0xc>
 d60:	88 23       	and	r24, r24
 d62:	52 f0       	brmi	.+20     	; 0xd78 <__fp_round+0x20>
 d64:	bb 0f       	add	r27, r27
 d66:	40 f4       	brcc	.+16     	; 0xd78 <__fp_round+0x20>
 d68:	bf 2b       	or	r27, r31
 d6a:	11 f4       	brne	.+4      	; 0xd70 <__fp_round+0x18>
 d6c:	60 ff       	sbrs	r22, 0
 d6e:	04 c0       	rjmp	.+8      	; 0xd78 <__fp_round+0x20>
 d70:	6f 5f       	subi	r22, 0xFF	; 255
 d72:	7f 4f       	sbci	r23, 0xFF	; 255
 d74:	8f 4f       	sbci	r24, 0xFF	; 255
 d76:	9f 4f       	sbci	r25, 0xFF	; 255
 d78:	08 95       	ret

00000d7a <__udivmodsi4>:
 d7a:	a1 e2       	ldi	r26, 0x21	; 33
 d7c:	1a 2e       	mov	r1, r26
 d7e:	aa 1b       	sub	r26, r26
 d80:	bb 1b       	sub	r27, r27
 d82:	fd 01       	movw	r30, r26
 d84:	0d c0       	rjmp	.+26     	; 0xda0 <__udivmodsi4_ep>

00000d86 <__udivmodsi4_loop>:
 d86:	aa 1f       	adc	r26, r26
 d88:	bb 1f       	adc	r27, r27
 d8a:	ee 1f       	adc	r30, r30
 d8c:	ff 1f       	adc	r31, r31
 d8e:	a2 17       	cp	r26, r18
 d90:	b3 07       	cpc	r27, r19
 d92:	e4 07       	cpc	r30, r20
 d94:	f5 07       	cpc	r31, r21
 d96:	20 f0       	brcs	.+8      	; 0xda0 <__udivmodsi4_ep>
 d98:	a2 1b       	sub	r26, r18
 d9a:	b3 0b       	sbc	r27, r19
 d9c:	e4 0b       	sbc	r30, r20
 d9e:	f5 0b       	sbc	r31, r21

00000da0 <__udivmodsi4_ep>:
 da0:	66 1f       	adc	r22, r22
 da2:	77 1f       	adc	r23, r23
 da4:	88 1f       	adc	r24, r24
 da6:	99 1f       	adc	r25, r25
 da8:	1a 94       	dec	r1
 daa:	69 f7       	brne	.-38     	; 0xd86 <__udivmodsi4_loop>
 dac:	60 95       	com	r22
 dae:	70 95       	com	r23
 db0:	80 95       	com	r24
 db2:	90 95       	com	r25
 db4:	9b 01       	movw	r18, r22
 db6:	ac 01       	movw	r20, r24
 db8:	bd 01       	movw	r22, r26
 dba:	cf 01       	movw	r24, r30
 dbc:	08 95       	ret

00000dbe <_exit>:
 dbe:	f8 94       	cli

00000dc0 <__stop_program>:
 dc0:	ff cf       	rjmp	.-2      	; 0xdc0 <__stop_program>
